diff --git a/base/base.gypi b/base/base.gypi
index a89a251..2cc906f 100644
--- a/base/base.gypi
+++ b/base/base.gypi
@@ -183,21 +183,6 @@
           'environment.h',
           'feature_list.cc',
           'feature_list.h',
-          'features/command_line_feature_reader.cc',
-          'features/command_line_feature_reader.h',
-          'features/feature_checker.cc',
-          'features/feature_checker.h',
-          'features/feature_checker_factory.cc',
-          'features/feature_checker_factory.h',
-          'features/feature_reader.h',
-          'features/feature_status_override.cc',
-          'features/feature_status_override.h',
-          'features/features.cc',
-          'features/features.h',
-          'features/scoped_test_feature_override.cc',
-          'features/scoped_test_feature_override.h',
-          'features/submodule_features.cc',
-          'features/submodule_features.h',
           'file_descriptor_posix.h',
           'file_version_info.h',
           'file_version_info_mac.h',
diff --git a/base/features/command_line_feature_reader.cc b/base/features/command_line_feature_reader.cc
deleted file mode 100644
index 5494b0d..0000000
--- a/base/features/command_line_feature_reader.cc
+++ /dev/null
@@ -1,53 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "base/features/command_line_feature_reader.h"
-
-#include "base/logging.h"
-#include "base/strings/string_util.h"
-
-namespace base {
-
-const char CommandLineFeatureReader::kFeaturePrefix[] = "with-feature:";
-
-CommandLineFeatureReader::CommandLineFeatureReader(
-    const base::CommandLine& command_line)
-    : command_line_(command_line) {
-}
-
-CommandLineFeatureReader::~CommandLineFeatureReader() {
-}
-
-void CommandLineFeatureReader::ReadOverrides(
-    std::vector<FeatureStatusOverride>* overrides) const {
-  for (auto cl_switch : command_line_.GetSwitches()) {
-    if (StartsWith(cl_switch.first, kFeaturePrefix, base::CompareCase::SENSITIVE)) {
-      std::string feature_name = cl_switch.first;
-      ReplaceFirstSubstringAfterOffset(&feature_name, 0, kFeaturePrefix, "");
-      const std::string switch_value =
-          command_line_.GetSwitchValueASCII(cl_switch.first);
-      if (!switch_value.empty() && switch_value != "off" &&
-          switch_value != "on") {
-        LOG(WARNING)
-            << cl_switch.first << " has unhandled value: \"" << switch_value
-            << "\" did you mean \"on\" or \"off\"? Using default setting.";
-        continue;
-      }
-      overrides->push_back(
-          FeatureStatusOverride(feature_name, switch_value != "off"));
-    }
-  }
-}
-
-// static
-std::string CommandLineFeatureReader::GetSwitchForFeature(
-    base::StringPiece feature_name) {
-  std::string switch_name(kFeaturePrefix);
-  feature_name.AppendToString(&switch_name);
-  return switch_name;
-}
-
-}  // namespace base
diff --git a/base/features/command_line_feature_reader.h b/base/features/command_line_feature_reader.h
deleted file mode 100644
index 9e9f2c3..0000000
--- a/base/features/command_line_feature_reader.h
+++ /dev/null
@@ -1,49 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef BASE_FEATURES_COMMAND_LINE_FEATURE_READER_H_
-#define BASE_FEATURES_COMMAND_LINE_FEATURE_READER_H_
-
-#include <string>
-#include <vector>
-
-#include "base/base_export.h"
-#include "base/command_line.h"
-#include "base/compiler_specific.h"
-#include "base/features/feature_reader.h"
-#include "base/strings/string_piece.h"
-
-namespace base {
-
-// Parses the command line for explicitly enabled or disabled features.
-// To enable a feature, pass --with-feature:[feature name].
-// To disable a feature, pass --with-feature:[feature name]=off.
-class BASE_EXPORT CommandLineFeatureReader : public FeatureReader {
- public:
-  static const char kFeaturePrefix[];
-
-  explicit CommandLineFeatureReader(const base::CommandLine& command_line);
-  ~CommandLineFeatureReader() override;
-
-  void ReadOverrides(
-      std::vector<FeatureStatusOverride>* overrides) const override;
-
-  // Returns the name of a command line flag for a given |feature_name|.
-  static std::string GetSwitchForFeature(base::StringPiece feature_name);
-
- private:
-  const base::CommandLine& command_line_;
-  DISALLOW_COPY_AND_ASSIGN(CommandLineFeatureReader);
-};
-
-}  // namespace base
-
-namespace opera {
-// TODO(mpawlowski): Remove (DNA-37006)
-using base::CommandLineFeatureReader;
-}
-
-#endif  // BASE_FEATURES_COMMAND_LINE_FEATURE_READER_H_
diff --git a/base/features/feature_checker.cc b/base/features/feature_checker.cc
deleted file mode 100644
index 99fbfd9..0000000
--- a/base/features/feature_checker.cc
+++ /dev/null
@@ -1,135 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "base/features/feature_checker.h"
-
-#include <algorithm>
-
-#include "base/features/feature_reader.h"
-#include "base/features/scoped_test_feature_override.h"
-
-namespace {
-// Unary predicate for finding features in collections by name().
-struct MatchByName {
-  explicit MatchByName(base::StringPiece name) : searched_name(name) {}
-
-  template <typename T>
-  bool operator()(const T& feature) const {
-    return feature.name() == searched_name;
-  }
-
-  template <typename T>
-  bool operator()(const T* feature) const {
-    return feature->name() == searched_name;
-  }
-
-  base::StringPiece searched_name;
-};
-
-}  // namespace
-
-namespace base {
-
-FeatureChecker::RegisteredFeature::RegisteredFeature(base::StringPiece name,
-                                                     bool enabled_by_default,
-                                                     bool settable)
-    : name_(name.as_string()),
-      enabled_by_default_(enabled_by_default),
-      settable_(settable) {
-}
-
-FeatureChecker::RegisteredFeature::~RegisteredFeature() = default;
-
-FeatureChecker::FeatureChecker() : read_status_called_(false) {
-}
-
-FeatureChecker::~FeatureChecker() = default;
-
-void FeatureChecker::RegisterFeature(base::StringPiece feature_name,
-                                     bool enabled_by_default,
-                                     bool settable) {
-  // Make sure no feature of this name is registered already. This is O(N) so
-  // it makes sense to avoid it in Release builds.
-  DCHECK(std::find_if(registered_features_.begin(), registered_features_.end(),
-                      MatchByName(feature_name)) == registered_features_.end());
-  registered_features_.push_back(
-      RegisteredFeature(feature_name, enabled_by_default, settable));
-}
-
-bool FeatureChecker::IsFeatureEnabled(base::StringPiece feature_name) const {
-  // Check test overrides first. Search from the back, as overrides can be
-  // nested and the last one with matching name defines the state to use.
-  const auto test_override_it =
-      std::find_if(test_feature_overrides_.rbegin(),
-                   test_feature_overrides_.rend(), MatchByName(feature_name));
-  if (test_override_it != test_feature_overrides_.rend())
-    return (*test_override_it)->enabled();
-
-  const auto registered_feature_it =
-      std::find_if(registered_features_.begin(), registered_features_.end(),
-                   MatchByName(feature_name));
-  if (registered_feature_it == registered_features_.end())
-    // This feature was not registered.
-    return false;
-  const RegisteredFeature& registered_feature = *registered_feature_it;
-  if (!registered_feature.settable())
-    // Feature's state is not allowed to change from the default.
-    return registered_feature.enabled_by_default();
-  // Feature is registered and settable, its state may be explicitly set by the
-  // user, so check the overrides.
-  DCHECK(read_status_called_)
-      << "Feature \"" << feature_name
-      << "\" is settable but ReadStatus() wasn't called yet.";
-  const auto override_it = std::find_if(overrides_.rbegin(), overrides_.rend(),
-                                        MatchByName(feature_name));
-  if (override_it != overrides_.rend()) {
-    // An override has been set for this feature.
-    const FeatureStatusOverride& status_override = *override_it;
-    return status_override.enabled();
-  }
-  // The state of this feature was not altered by any override, return default.
-  return registered_feature.enabled_by_default();
-}
-
-void FeatureChecker::ReadStatus(const FeatureReader& state_reader) {
-  read_status_called_ = true;
-  state_reader.ReadOverrides(&overrides_);
-}
-
-std::vector<FeatureStatusOverride> FeatureChecker::GetOverrides() const {
-  // Translate ScopedTestFeatureOverrides into FeatureStatusOverrides:
-  std::vector<FeatureStatusOverride> test_overrides(
-      test_feature_overrides_.size());
-  std::transform(test_feature_overrides_.begin(), test_feature_overrides_.end(),
-                 test_overrides.begin(),
-                 [](const ScopedTestFeatureOverride* test_override) {
-                   return FeatureStatusOverride(test_override->name(),
-                                                test_override->enabled());
-                 });
-  // Append those test overrides to the ones read in ReadStatus().
-  std::vector<FeatureStatusOverride> overrides = overrides_;
-  overrides.insert(overrides.end(), test_overrides.begin(),
-                   test_overrides.end());
-  return overrides;
-}
-
-void FeatureChecker::PushTestFeatureOverride(
-    const ScopedTestFeatureOverride* feature_override) {
-  // One override cannot be pushed twice.
-  CHECK(std::find(test_feature_overrides_.begin(),
-                  test_feature_overrides_.end(),
-                  feature_override) == test_feature_overrides_.end());
-  test_feature_overrides_.push_back(feature_override);
-}
-
-void FeatureChecker::PopTestFeatureOverride(
-    const ScopedTestFeatureOverride* feature_override) {
-  // The popped override should be the last one on our list.
-  CHECK_EQ(feature_override, *test_feature_overrides_.rbegin());
-  test_feature_overrides_.pop_back();
-}
-
-}  // namespace base
diff --git a/base/features/feature_checker.h b/base/features/feature_checker.h
deleted file mode 100644
index 0e7678f..0000000
--- a/base/features/feature_checker.h
+++ /dev/null
@@ -1,100 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef BASE_FEATURES_FEATURE_CHECKER_H_
-#define BASE_FEATURES_FEATURE_CHECKER_H_
-
-#include <string>
-#include <vector>
-
-#include "base/base_export.h"
-#include "base/features/feature_status_override.h"
-#include "base/macros.h"
-#include "base/memory/scoped_vector.h"
-#include "base/strings/string_piece.h"
-
-namespace base {
-
-class FeatureReader;
-class ScopedTestFeatureOverride;
-
-// Checks whether certain browser features are enabled in runtime.
-class BASE_EXPORT FeatureChecker {
- public:
-  FeatureChecker();
-  ~FeatureChecker();
-
-  // Registers a feature called |feature_name|. The name should be short, ex.
-  // "hardware-acceleration" or "turbo". |enabled_by_default| controls whether
-  // the feature should be reported enabled or disabled when not explicitly
-  // set. |settable| controls whether the state of the feature can be set to
-  // anything other than default. Non-settable features will retain their
-  // default state regardless of whether they are overriden by a FeatureReader.
-  //
-  // It's safest to make all calls to RegisterFeature() and ReadStatus() before
-  // secondary browser threads are launched. If the product cannot guarantee
-  // this behaviour, it's the products responsibility to ensure thread safety.
-  void RegisterFeature(base::StringPiece feature_name,
-                       bool enabled_by_default,
-                       bool settable);
-
-  // Checks whether a feature |feature_name| is currently enabled.
-  // Returns true if feature is enabled, false otherwise. If a feature of that
-  // name wasn't registered, returns false.
-  //
-  // May be called from any thread after initialization has finished (ie.
-  // all calls to RegisterFeature() and ReadStatus()).
-  bool IsFeatureEnabled(base::StringPiece feature_name) const;
-
-  // Reads the status of explicitly set features from |state_reader|. The status
-  // is read once and remembered. Multiple calls can be made if more than one
-  // FeatureReader is in use.
-  void ReadStatus(const FeatureReader& state_reader);
-
-  // Returns the FeatureStatusOverrides currently in action. This includes
-  // those set by FeatureReaders (see ReadStatus()) and
-  // ScopedTestFeatureOverrides that exist at the moment of calling.
-  std::vector<FeatureStatusOverride> GetOverrides() const;
-
- private:
-  friend class ScopedTestFeatureOverride;
-
-  class RegisteredFeature {
-   public:
-    RegisteredFeature(base::StringPiece name,
-                      bool enabled_by_default,
-                      bool settable);
-    ~RegisteredFeature();
-
-    const std::string& name() const { return name_; }
-    bool enabled_by_default() const { return enabled_by_default_; }
-    bool settable() const { return settable_; }
-
-   private:
-    std::string name_;
-    bool enabled_by_default_;
-    bool settable_;
-  };
-
-  void PushTestFeatureOverride(
-      const ScopedTestFeatureOverride* feature_override);
-  void PopTestFeatureOverride(
-      const ScopedTestFeatureOverride* feature_override);
-
-  std::vector<RegisteredFeature> registered_features_;
-  std::vector<FeatureStatusOverride> overrides_;
-  std::vector<const ScopedTestFeatureOverride*> test_feature_overrides_;
-
-  // Used to verify that ReadStatus() was called at least once before
-  // IsFeatureEnabled is called for a settable feature.
-  bool read_status_called_;
-
-  DISALLOW_COPY_AND_ASSIGN(FeatureChecker);
-};
-
-}  // namespace base
-
-#endif  // BASE_FEATURES_FEATURE_CHECKER_H_
diff --git a/base/features/feature_checker_factory.cc b/base/features/feature_checker_factory.cc
deleted file mode 100644
index 428d431..0000000
--- a/base/features/feature_checker_factory.cc
+++ /dev/null
@@ -1,26 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "base/features/feature_checker_factory.h"
-
-namespace base {
-
-FeatureCheckerFactory::FeatureCheckerFactory() = default;
-FeatureCheckerFactory::~FeatureCheckerFactory() = default;
-
-// static
-FeatureChecker* FeatureCheckerFactory::Get() {
-  FeatureCheckerFactory* fcf = GetInstance();
-  return &fcf->feature_checker_;
-}
-
-// static
-FeatureCheckerFactory* FeatureCheckerFactory::GetInstance() {
-  return Singleton<FeatureCheckerFactory,
-                   LeakySingletonTraits<FeatureCheckerFactory>>::get();
-}
-
-}  // namespace base
diff --git a/base/features/feature_checker_factory.h b/base/features/feature_checker_factory.h
deleted file mode 100644
index aa0f6aa..0000000
--- a/base/features/feature_checker_factory.h
+++ /dev/null
@@ -1,34 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef BASE_FEATURES_FEATURE_CHECKER_FACTORY_H_
-#define BASE_FEATURES_FEATURE_CHECKER_FACTORY_H_
-
-#include "base/base_export.h"
-#include "base/features/feature_checker.h"
-#include "base/memory/singleton.h"
-
-namespace base {
-
-class BASE_EXPORT FeatureCheckerFactory {
- public:
-  // Note, when the FeatureChecker is returned the first time, it's not
-  // initialized, ie. no features are registered and no FeatureReaders are
-  // added. It's the product's/platform's job to set those things early on
-  // startup.
-  static FeatureChecker* Get();
-  static FeatureCheckerFactory* GetInstance();
-
- private:
-  friend struct DefaultSingletonTraits<FeatureCheckerFactory>;
-  FeatureCheckerFactory();
-  virtual ~FeatureCheckerFactory();
-
-  FeatureChecker feature_checker_;
-};
-
-}  // namespace base
-#endif  // BASE_FEATURES_FEATURE_CHECKER_FACTORY_H_
diff --git a/base/features/feature_reader.h b/base/features/feature_reader.h
deleted file mode 100644
index 3fbe39d..0000000
--- a/base/features/feature_reader.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef BASE_FEATURES_FEATURE_READER_H_
-#define BASE_FEATURES_FEATURE_READER_H_
-
-#include <vector>
-
-#include "base/base_export.h"
-#include "base/features/feature_status_override.h"
-
-namespace base {
-
-// Reads state of a feature from some medium to inform whether it's been
-// explicitly enabled or disabled.
-class BASE_EXPORT FeatureReader {
- public:
-  virtual ~FeatureReader() {}
-
-  // Fills |overrides| with states of features that were explicitly enabled or
-  // disabled. |overrides| must not be null.
-  virtual void ReadOverrides(
-      std::vector<FeatureStatusOverride>* overrides) const = 0;
-};
-
-}  // namespace base
-
-#endif  // BASE_FEATURES_FEATURE_READER_H_
diff --git a/base/features/feature_status_override.cc b/base/features/feature_status_override.cc
deleted file mode 100644
index 612c7b0..0000000
--- a/base/features/feature_status_override.cc
+++ /dev/null
@@ -1,33 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "base/features/feature_status_override.h"
-
-namespace base {
-
-FeatureStatusOverride::FeatureStatusOverride() = default;
-
-FeatureStatusOverride::FeatureStatusOverride(const std::string& name,
-                                             bool enabled)
-    : name_(name), enabled_(enabled) {
-}
-
-FeatureStatusOverride::~FeatureStatusOverride() = default;
-
-const std::string& FeatureStatusOverride::name() const {
-  return name_;
-}
-
-bool FeatureStatusOverride::enabled() const {
-  return enabled_;
-}
-
-bool FeatureStatusOverride::operator==(
-    const FeatureStatusOverride& other) const {
-  return name() == other.name() && enabled() == other.enabled();
-}
-
-}  // namespace base
diff --git a/base/features/feature_status_override.h b/base/features/feature_status_override.h
deleted file mode 100644
index 0d8df9e..0000000
--- a/base/features/feature_status_override.h
+++ /dev/null
@@ -1,34 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef BASE_FEATURES_FEATURE_STATUS_OVERRIDE_H_
-#define BASE_FEATURES_FEATURE_STATUS_OVERRIDE_H_
-
-#include <string>
-
-#include "base/base_export.h"
-
-namespace base {
-
-// Represents an overriden (explicitly set) state of a feature.
-class BASE_EXPORT FeatureStatusOverride {
- public:
-  FeatureStatusOverride();
-  FeatureStatusOverride(const std::string& name, bool enabled);
-  ~FeatureStatusOverride();
-
-  const std::string& name() const;
-  bool enabled() const;
-  bool operator==(const FeatureStatusOverride& other) const;
-
- private:
-  std::string name_;
-  bool enabled_;
-};
-
-}  // namespace base
-
-#endif  // BASE_FEATURES_FEATURE_STATUS_OVERRIDE_H_
diff --git a/base/features/features.cc b/base/features/features.cc
deleted file mode 100644
index 97690f0..0000000
--- a/base/features/features.cc
+++ /dev/null
@@ -1,36 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "base/features/features.h"
-
-#include <vector>
-
-#include "base/command_line.h"
-#include "base/features/command_line_feature_reader.h"
-#include "base/features/feature_checker_factory.h"
-
-namespace base {
-
-bool IsFeatureEnabled(base::StringPiece feature_name) {
-  return FeatureCheckerFactory::Get()->IsFeatureEnabled(feature_name);
-}
-
-bool IsCustomizationEnabled(base::StringPiece feature_name) {
-  return IsFeatureEnabled(feature_name);
-}
-
-void AppendExplicitlySetFeaturesToCommandLine(base::CommandLine* cmd_line) {
-  const std::vector<FeatureStatusOverride>& features_set_by_user =
-      FeatureCheckerFactory::Get()->GetOverrides();
-  for (auto i = features_set_by_user.begin(); i != features_set_by_user.end();
-       ++i) {
-    cmd_line->AppendSwitchASCII(
-        CommandLineFeatureReader::kFeaturePrefix + i->name(),
-        i->enabled() ? "on" : "off");
-  }
-}
-
-}  // namespace base
diff --git a/base/features/features.h b/base/features/features.h
deleted file mode 100644
index 1bbd000f..0000000
--- a/base/features/features.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2013 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef BASE_FEATURES_FEATURES_H_
-#define BASE_FEATURES_FEATURES_H_
-
-#include "base/base_export.h"
-#include "base/features/submodule_features.h"
-#include "base/strings/string_piece.h"
-
-namespace base {
-
-class CommandLine;
-
-// Shorthand for retrieving the FeatureChecker from FeatureCheckerFactory and
-// calling IsFeatureEnabled.
-// Note that features must be registered before checking, otherwise this will
-// always return false. See FeatureChecker::RegisterFeature() and
-// FeatureCheckerFactory::Get().
-//
-// May be called from any thread, as long as the features are registered and
-// their status is read. Has no side effects.
-bool BASE_EXPORT IsFeatureEnabled(base::StringPiece feature_name);
-
-// Same as IsFeatureEnabled() but used to indicate that a feature check is for
-// long-lived customizations rather than normal work-in-progress features.
-bool BASE_EXPORT IsCustomizationEnabled(base::StringPiece feature_name);
-
-// Appeds all set feature flags to command line to pass features to
-// renderer and utility processes.
-// This isn't very elegant, design-wise, since we're assuming these other
-// processes will be checking feature state via CommandLineFeatureReaders,
-// and that is a violation of abstractions, but it's currently the easiest way
-// that doesn't involve a lot of patching.
-void BASE_EXPORT
-AppendExplicitlySetFeaturesToCommandLine(base::CommandLine* cmd_line);
-
-}  // namespace base
-
-#endif  // BASE_FEATURES_FEATURES_H_
diff --git a/base/features/scoped_test_feature_override.cc b/base/features/scoped_test_feature_override.cc
deleted file mode 100644
index 758b762..0000000
--- a/base/features/scoped_test_feature_override.cc
+++ /dev/null
@@ -1,36 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "base/features/scoped_test_feature_override.h"
-
-#include "base/features/feature_checker.h"
-#include "base/features/feature_checker_factory.h"
-
-namespace base {
-
-ScopedTestFeatureOverride::ScopedTestFeatureOverride(base::StringPiece name,
-                                                     bool enabled)
-    : name_(name.as_string()),
-      enabled_(enabled),
-      feature_checker_(FeatureCheckerFactory::Get()) {
-  feature_checker_->PushTestFeatureOverride(this);
-}
-
-ScopedTestFeatureOverride::ScopedTestFeatureOverride(
-    base::StringPiece name,
-    bool enabled,
-    FeatureChecker* feature_checker)
-    : name_(name.as_string()),
-      enabled_(enabled),
-      feature_checker_(feature_checker) {
-  feature_checker_->PushTestFeatureOverride(this);
-}
-
-ScopedTestFeatureOverride::~ScopedTestFeatureOverride() {
-  feature_checker_->PopTestFeatureOverride(this);
-}
-
-}  // namespace base
diff --git a/base/features/scoped_test_feature_override.h b/base/features/scoped_test_feature_override.h
deleted file mode 100644
index dd46cb6..0000000
--- a/base/features/scoped_test_feature_override.h
+++ /dev/null
@@ -1,53 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef BASE_FEATURES_SCOPED_TEST_FEATURE_OVERRIDE_H_
-#define BASE_FEATURES_SCOPED_TEST_FEATURE_OVERRIDE_H_
-
-#include <string>
-
-#include "base/base_export.h"
-#include "base/macros.h"
-#include "base/strings/string_piece.h"
-
-namespace base {
-
-class FeatureChecker;
-
-// Helper class allowing overriding a feature flag in a limited scope.
-//
-// The override will be valid only while the override object is alive.
-// Nested overrides are allowed - the highest one up the stack is the
-// effective override.
-//
-// To be used ONLY in tests.
-class BASE_EXPORT ScopedTestFeatureOverride {
- public:
-  ScopedTestFeatureOverride(base::StringPiece name, bool enabled);
-  ScopedTestFeatureOverride(base::StringPiece name,
-                            bool enabled,
-                            FeatureChecker* feature_checker);
-  ~ScopedTestFeatureOverride();
-
-  const std::string& name() const { return name_; }
-  bool enabled() const { return enabled_; }
-
- private:
-  std::string name_;
-  bool enabled_;
-  FeatureChecker* feature_checker_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScopedTestFeatureOverride);
-};
-
-}  // namespace base
-
-namespace opera {
-// TODO(mpawlowski): Remove (DNA-37006)
-using base::ScopedTestFeatureOverride;
-}
-
-#endif  // BASE_FEATURES_SCOPED_TEST_FEATURE_OVERRIDE_H_
diff --git a/base/features/submodule_features.cc b/base/features/submodule_features.cc
deleted file mode 100644
index e358371..0000000
--- a/base/features/submodule_features.cc
+++ /dev/null
@@ -1,25 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "base/features/submodule_features.h"
-
-namespace base {
-
-const char kSubmoduleFeatureExample[] = "submodule-feature-example";
-
-const char kCustomizationDisablePasswordSavingByDefault[] =
-    "disable-password-saving-by-default";
-const char kFeatureMseAudioMpegAac[] = "mse-audio-mpeg-aac";
-const char kSubmoduleNativeThemeAlt[] = "submodule-native-theme-alt";
-const char kSubmoduleUseGoogleApiKey[] = "submodule-use-google-api-key";
-
-const char kSubmoduleCountDiscardableSharedMemory[] =
-    "submodule-count-discardable-shared-memory";
-const char kSubmoduleBufferedRangesPTS[] = "submodule-buffered-ranges-pts";
-const char kSubmoduleStorageEncryption[] = "submodule-storage-encryption";
-const char kSubmoduleGLESMemoryTuning[] = "submodule-gles-memory-tuning";
-const char kSubmoduleEBUTTDTTMLParser[] = "submodule-ebu-tt-d-ttml-parser";
-}  // namespace base
diff --git a/base/features/submodule_features.h b/base/features/submodule_features.h
deleted file mode 100644
index b3d9439..0000000
--- a/base/features/submodule_features.h
+++ /dev/null
@@ -1,56 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef BASE_FEATURES_SUBMODULE_FEATURES_H_
-#define BASE_FEATURES_SUBMODULE_FEATURES_H_
-
-#include "base/base_export.h"
-
-namespace base {
-
-// This header defines constants for use in feature checking within chromium
-// code. These features must be registered by each product/platform that
-// wishes to use them (see FeatureChecker::RegisterFeature) or left unregistered
-// if they are to be ignored by that product/platform. A short description of
-// feature in a comment is nice to have.
-
-// An example dummy feature. Does nothing, not checked anywhere.
-BASE_EXPORT extern const char kSubmoduleFeatureExample[];
-
-// Controls the default state of passwords saving preference.
-BASE_EXPORT extern const char kCustomizationDisablePasswordSavingByDefault[];
-
-// Enables 'audio/mpeg' and 'audio/aac' in MSE if USE_SYSTEM_PROPRIETARY_CODECS
-// is set.
-BASE_EXPORT extern const char kFeatureMseAudioMpegAac[];
-
-// Enables an alternative native theme implementation.
-BASE_EXPORT extern const char kSubmoduleNativeThemeAlt[];
-
-// Allows to switch usage of Google API key.
-BASE_EXPORT extern const char kSubmoduleUseGoogleApiKey[];
-
-// Enable the memory allowance system to catch how much discardable shared
-// memory is used in the renderer processes. See TVSDK-9903.
-BASE_EXPORT extern const char kSubmoduleCountDiscardableSharedMemory[];
-
-// Enable buffered ranges based on PTS in chunk demuxer.
-BASE_EXPORT extern const char kSubmoduleBufferedRangesPTS[];
-
-// Encrypt the cookie value with AES encryption when persisted to the disk and
-// allows the integration to specify the key. See TVSDK-13605.
-BASE_EXPORT extern const char kSubmoduleStorageEncryption[];
-
-// Turns on the feature to reduce GLES memory usage instead of losing
-// contexts on OOM.
-BASE_EXPORT extern const char kSubmoduleGLESMemoryTuning[];
-
-// This feature enables the EBU-TT-D TTML parser, and disables the old basic
-// TTML parser. See TVSDK-11953.
-BASE_EXPORT extern const char kSubmoduleEBUTTDTTMLParser[];
-}  // namespace base
-
-#endif  // BASE_FEATURES_SUBMODULE_FEATURES_H_
diff --git a/build/common.gypi b/build/common.gypi
index 0054179..1aad5054 100644
--- a/build/common.gypi
+++ b/build/common.gypi
@@ -2673,7 +2673,7 @@
       ['OS=="mac"', {
         # When compiling Objective C, warns if a method is used whose
         # availability is newer than the deployment target.
-        #'xcode_settings': { 'WARNING_CFLAGS': ['-Wpartial-availability']},
+        'xcode_settings': { 'WARNING_CFLAGS': ['-Wpartial-availability']},
       }],
       ['(OS=="mac" or OS=="ios") and asan==1', {
         'dependencies': [
@@ -2781,9 +2781,6 @@
       ['enable_wifi_display==1', {
         'defines': ['ENABLE_WIFI_DISPLAY=1'],
       }],
-      ['system_proprietary_codecs==1', {
-        'defines': ['USE_SYSTEM_PROPRIETARY_CODECS'],
-      }],
       ['use_udev==1', {
         'defines': ['USE_UDEV'],
       }],
diff --git a/content/browser/gpu/gpu_process_host.cc b/content/browser/gpu/gpu_process_host.cc
index 964b4eb..1f03d63 100644
--- a/content/browser/gpu/gpu_process_host.cc
+++ b/content/browser/gpu/gpu_process_host.cc
@@ -313,8 +313,7 @@ GpuProcessHost* GpuProcessHost::Get(GpuProcessKind kind,
   // Don't grant further access to GPU if it is not allowed.
   GpuDataManagerImpl* gpu_data_manager = GpuDataManagerImpl::GetInstance();
   DCHECK(gpu_data_manager);
-  if (cause != CAUSE_FOR_GPU_LAUNCH_PLATFORM_MEDIA_PIPELINE &&
-      !gpu_data_manager->GpuAccessAllowed(NULL))
+  if (!gpu_data_manager->GpuAccessAllowed(NULL))
     return NULL;
 
   if (g_gpu_process_hosts[kind] && ValidateHost(g_gpu_process_hosts[kind]))
@@ -699,47 +698,11 @@ void GpuProcessHost::EstablishGpuChannel(
     bool allow_view_command_buffers,
     bool allow_real_time_streams,
     const EstablishChannelCallback& callback) {
-  EstablishGpuChannelInternal(
-      client_id,
-      client_tracing_id,
-      preempts,
-      allow_view_command_buffers,
-      allow_real_time_streams,
-      callback,
-      false);
-}
-
-void GpuProcessHost::EstablishGpuChannelIgnoreDisallowedGpu(
-    int client_id,
-    uint64_t client_tracing_id,
-    bool preempts,
-    bool allow_view_command_buffers,
-    bool allow_real_time_streams,
-    const EstablishChannelCallback& callback) {
-  EstablishGpuChannelInternal(
-      client_id,
-      client_tracing_id,
-      preempts,
-      allow_view_command_buffers,
-      allow_real_time_streams,
-      callback,
-      true);
-}
-
-void GpuProcessHost::EstablishGpuChannelInternal(
-    int client_id,
-    uint64_t client_tracing_id,
-    bool preempts,
-    bool allow_view_command_buffers,
-    bool allow_real_time_streams,
-    const EstablishChannelCallback& callback,
-    bool ignore_disallowed_gpu) {
   DCHECK(CalledOnValidThread());
   TRACE_EVENT0("gpu", "GpuProcessHost::EstablishGpuChannel");
 
   // If GPU features are already blacklisted, no need to establish the channel.
-  if (!ignore_disallowed_gpu &&
-      !GpuDataManagerImpl::GetInstance()->GpuAccessAllowed(NULL)) {
+  if (!GpuDataManagerImpl::GetInstance()->GpuAccessAllowed(NULL)) {
     DVLOG(1) << "GPU blacklisted, refusing to open a GPU channel.";
     callback.Run(IPC::ChannelHandle(), gpu::GPUInfo());
     return;
@@ -755,7 +718,6 @@ void GpuProcessHost::EstablishGpuChannelInternal(
     EstablishChannelRequest request;
     request.client_id = client_id;
     request.callback = callback;
-    request.ignore_disallowed_gpu = ignore_disallowed_gpu;
     channel_requests_.push(request);
   } else {
     DVLOG(1) << "Failed to send GpuMsg_EstablishChannel.";
@@ -858,7 +820,7 @@ void GpuProcessHost::OnChannelEstablished(
 
   // Currently if any of the GPU features are blacklisted, we don't establish a
   // GPU channel.
-  if (!request.ignore_disallowed_gpu && !channel_handle.name.empty() &&
+  if (!channel_handle.name.empty() &&
       !GpuDataManagerImpl::GetInstance()->GpuAccessAllowed(NULL)) {
     Send(new GpuMsg_CloseChannel(request.client_id));
     request.callback.Run(IPC::ChannelHandle(), gpu::GPUInfo());
diff --git a/content/browser/gpu/gpu_process_host.h b/content/browser/gpu/gpu_process_host.h
index 45e8c06..0b35c56 100644
--- a/content/browser/gpu/gpu_process_host.h
+++ b/content/browser/gpu/gpu_process_host.h
@@ -11,7 +11,6 @@
 #include <queue>
 #include <set>
 #include <string>
-#include <utility>
 
 #include "base/callback.h"
 #include "base/containers/hash_tables.h"
@@ -76,7 +75,6 @@ class GpuProcessHost : public BrowserChildProcessHostDelegate,
     ~EstablishChannelRequest();
     int32_t client_id;
     EstablishChannelCallback callback;
-    bool ignore_disallowed_gpu;
   };
 
   typedef base::Callback<void(const gfx::GpuMemoryBufferHandle& handle)>
@@ -130,14 +128,6 @@ class GpuProcessHost : public BrowserChildProcessHostDelegate,
                            bool allow_view_command_buffers,
                            bool allow_real_time_streams,
                            const EstablishChannelCallback& callback);
-  // TODO(mmaliszkiewicz): Remove when media pipeline has its own process.
-  void EstablishGpuChannelIgnoreDisallowedGpu(
-      int client_id,
-      uint64_t client_tracing_id,
-      bool preempts,
-      bool allow_view_command_buffers,
-      bool allow_real_time_streams,
-      const EstablishChannelCallback& callback);
 
   // Tells the GPU process to create a new GPU memory buffer.
   void CreateGpuMemoryBuffer(gfx::GpuMemoryBufferId id,
@@ -233,14 +223,6 @@ class GpuProcessHost : public BrowserChildProcessHostDelegate,
 
   std::string GetShaderPrefixKey();
 
-  void EstablishGpuChannelInternal(int client_id,
-                                   uint64_t client_tracing_id,
-                                   bool preempts,
-                                   bool allow_view_command_buffers,
-                                   bool allow_real_time_streams,
-                                   const EstablishChannelCallback& callback,
-                                   bool ignore_disallowed_gpu);
-
   // The serial number of the GpuProcessHost / GpuProcessHostUIShim pair.
   int host_id_;
 
diff --git a/content/browser/media/media_canplaytype_browsertest.cc b/content/browser/media/media_canplaytype_browsertest.cc
index e70ee9e..17d1347 100644
--- a/content/browser/media/media_canplaytype_browsertest.cc
+++ b/content/browser/media/media_canplaytype_browsertest.cc
@@ -20,7 +20,7 @@ const char kProbably[] = "probably";
 const char kMaybe[] = "maybe";
 const char kNot[] = "";
 
-#if !defined(OS_LINUX) && defined(USE_PROPRIETARY_CODECS)
+#if defined(USE_PROPRIETARY_CODECS)
 const char* kPropProbably = kProbably;
 const char* kPropMaybe = kMaybe;
 #else
diff --git a/content/browser/media/media_internals.cc b/content/browser/media/media_internals.cc
index 005f610..02e40ce 100644
--- a/content/browser/media/media_internals.cc
+++ b/content/browser/media/media_internals.cc
@@ -28,10 +28,6 @@
 #include "media/filters/decrypting_video_decoder.h"
 #endif
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/base/pipeline_stats.h"
-#endif
-
 namespace {
 
 static base::LazyInstance<content::MediaInternals>::Leaky g_media_internals =
@@ -368,9 +364,6 @@ void MediaInternals::MediaInternalsUMAHandler::SavePlayerState(
     default:
       break;
   }
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  media::pipeline_stats::DeserializeAndReport(event.params);
-#endif
   return;
 }
 
diff --git a/content/browser/renderer_host/input/synthetic_gesture_target_mac.mm b/content/browser/renderer_host/input/synthetic_gesture_target_mac.mm
index 6004636..92d3617 100644
--- a/content/browser/renderer_host/input/synthetic_gesture_target_mac.mm
+++ b/content/browser/renderer_host/input/synthetic_gesture_target_mac.mm
@@ -21,7 +21,7 @@
 // Filled with default values.
 @property(readonly) CGFloat deltaX;
 @property(readonly) CGFloat deltaY;
-@property(readonly) NSUInteger modifierFlags;
+@property(readonly) NSEventModifierFlags modifierFlags;
 @property(readonly) NSTimeInterval timestamp;
 
 @end
diff --git a/content/browser/renderer_host/render_message_filter.cc b/content/browser/renderer_host/render_message_filter.cc
index 2d14412..c4a1046 100644
--- a/content/browser/renderer_host/render_message_filter.cc
+++ b/content/browser/renderer_host/render_message_filter.cc
@@ -705,23 +705,13 @@ void RenderMessageFilter::OnEstablishGpuChannel(
   bool preempts = false;
   bool allow_view_command_buffers = false;
   bool allow_real_time_streams = false;
-  const GpuProcessHost::EstablishChannelCallback callback =
-      base::Bind(&RenderMessageFilter::EstablishChannelCallback,
-                 weak_ptr_factory_.GetWeakPtr(), base::Passed(&reply));
-  if (cause_for_gpu_launch != CAUSE_FOR_GPU_LAUNCH_PLATFORM_MEDIA_PIPELINE)
-    host->EstablishGpuChannel(
+  host->EstablishGpuChannel(
       render_process_id_,
       ChildProcessHostImpl::ChildProcessUniqueIdToTracingProcessId(
           render_process_id_),
       preempts, allow_view_command_buffers, allow_real_time_streams,
-      callback);
-  else
-    host->EstablishGpuChannelIgnoreDisallowedGpu(
-      render_process_id_,
-      ChildProcessHostImpl::ChildProcessUniqueIdToTracingProcessId(
-           render_process_id_),
-      preempts, allow_view_command_buffers, allow_real_time_streams,
-      callback);
+      base::Bind(&RenderMessageFilter::EstablishChannelCallback,
+                 weak_ptr_factory_.GetWeakPtr(), base::Passed(&reply)));
 }
 
 void RenderMessageFilter::OnHasGpuProcess(IPC::Message* reply_ptr) {
diff --git a/content/common/content_message_generator.h b/content/common/content_message_generator.h
index 747aa58..c26352d0 100644
--- a/content/common/content_message_generator.h
+++ b/content/common/content_message_generator.h
@@ -80,7 +80,3 @@
 #if defined(OS_WIN)
 #include "content/common/dwrite_font_proxy_messages.h"
 #endif  // defined(OS_WIN)
-
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "content/common/media/media_pipeline_messages.h"
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
diff --git a/content/common/gpu/media/at_init.cc b/content/common/gpu/media/at_init.cc
deleted file mode 100644
index de8357e..0000000
--- a/content/common/gpu/media/at_init.cc
+++ /dev/null
@@ -1,41 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/at_init.h"
-
-#include "media/base/mac/scoped_audio_queue_ref.h"
-
-namespace content {
-
-namespace {
-
-void DummyOutputCallback(void* inUserData,
-                         AudioQueueRef inAQ,
-                         AudioQueueBufferRef inBuffer) {
-  NOTREACHED();
-}
-
-}  // namespace
-
-void InitializeAudioToolbox() {
-  // Create and start a dummy AudioQueue to preload the resources used when
-  // decoding audio.
-  AudioStreamBasicDescription format;
-  memset(&format, 0, sizeof(format));
-  format.mFormatID = '.mp3';
-  format.mSampleRate = 44100;
-  format.mChannelsPerFrame = 2;
-
-  media::ScopedAudioQueueRef queue;
-  AudioQueueNewOutput(&format, &DummyOutputCallback, nullptr, nullptr, nullptr,
-                      0, queue.InitializeInto());
-  if (queue) {
-    if (AudioQueueStart(queue, nullptr) == noErr)
-      AudioQueueStop(queue, true);
-  }
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/at_init.h b/content/common/gpu/media/at_init.h
deleted file mode 100644
index d8b3a52..0000000
--- a/content/common/gpu/media/at_init.h
+++ /dev/null
@@ -1,18 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_AT_INIT_H_
-#define CONTENT_COMMON_GPU_MEDIA_AT_INIT_H_
-
-namespace content {
-
-// Calls the minimum amount of the AudioToolbox API with the sole purpose of
-// warming up the sandbox for audio decoding.
-void InitializeAudioToolbox();
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_AT_INIT_H_
diff --git a/content/common/gpu/media/avf_audio_tap.h b/content/common/gpu/media/avf_audio_tap.h
deleted file mode 100644
index 98e9e60..0000000
--- a/content/common/gpu/media/avf_audio_tap.h
+++ /dev/null
@@ -1,59 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_AVF_AUDIO_TAP_H_
-#define CONTENT_COMMON_GPU_MEDIA_AVF_AUDIO_TAP_H_
-
-#import <CoreAudio/CoreAudio.h>
-
-#include "base/callback.h"
-#include "base/mac/scoped_nsobject.h"
-
-@class AVAssetTrack;
-@class AVAudioMix;
-
-namespace base {
-class SingleThreadTaskRunner;
-}  // namespace base
-
-namespace media {
-class DataBuffer;
-}  // namespace media
-
-namespace content {
-
-// Used to grab decoded audio samples from an AVPlayerItem, see
-// |GetAudioMix()|.
-class AVFAudioTap {
- public:
-  using FormatKnownCB =
-      base::Callback<void(const AudioStreamBasicDescription& format)>;
-  using SamplesReadyCB =
-      base::Callback<void(const scoped_refptr<media::DataBuffer>& buffer)>;
-
-  AVFAudioTap(AVAssetTrack* audio_track,
-              const scoped_refptr<base::SingleThreadTaskRunner>& task_runner,
-              const FormatKnownCB& format_known_cb,
-              const SamplesReadyCB& samples_ready_cb);
-  ~AVFAudioTap();
-
-  // Returns an AVAudioMix with an audio processing tap attached to it.  Set
-  // the AVAudioMix on an AVPlayerItem to receive decoded audio samples through
-  // |samples_ready_cb_|.  Returns nil on error to initialize the AVAudioMix.
-  base::scoped_nsobject<AVAudioMix> GetAudioMix();
-
- private:
-  AVAssetTrack* audio_track_;
-  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-  FormatKnownCB format_known_cb_;
-  SamplesReadyCB samples_ready_cb_;
-
-  DISALLOW_COPY_AND_ASSIGN(AVFAudioTap);
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_AVF_AUDIO_TAP_H_
diff --git a/content/common/gpu/media/avf_audio_tap.mm b/content/common/gpu/media/avf_audio_tap.mm
deleted file mode 100644
index d8741ec..0000000
--- a/content/common/gpu/media/avf_audio_tap.mm
+++ /dev/null
@@ -1,343 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "content/common/gpu/media/avf_audio_tap.h"
-
-#include <deque>
-
-#import <AVFoundation/AVFoundation.h>
-
-#include "base/bind.h"
-#include "base/callback_helpers.h"
-#include "base/location.h"
-#include "base/mac/scoped_cftyperef.h"
-#include "base/memory/weak_ptr.h"
-#include "base/single_thread_task_runner.h"
-#include "base/synchronization/lock.h"
-#include "base/trace_event/trace_event.h"
-#include "media/base/data_buffer.h"
-#include "media/base/mac/avfoundation_glue.h"
-#include "media/base/mac/framework_type_conversions.h"
-#include "media/base/mac/mediatoolbox_glue.h"
-
-namespace content {
-
-namespace {
-
-// The maximum number of DataBuffers pre-allocated ahead of time so that
-// Process() doesn't have to allocate memory (which would interfere with its
-// real-time processing nature, according to the documentation of
-// MTAudioProcessingTapProcessCallback).
-const size_t kMaxPreallocatedBufferCount = 5;
-
-}  // namespace
-
-namespace audio_tap {
-
-// A context for the audio processor.  Manages DataBuffers that the tap
-// callbacks fill with decoded audio.  Dispatches tasks between audio tap
-// threads and the Chrome platform media pipeline thread.
-class Context {
- public:
-  struct InitParams {
-    AVFAudioTap::FormatKnownCB format_known_cb;
-    AVFAudioTap::SamplesReadyCB samples_ready_cb;
-
-    // The task runner of the Chrome platform media pipeline thread.
-    scoped_refptr<base::SingleThreadTaskRunner> task_runner;
-  };
-
-  explicit Context(const InitParams& params);
-  ~Context();
-
-  static void Destroy(Context* context);
-  static Context* FromTap(MediaToolboxGlue::MTAudioProcessingTapRef tap);
-
-  void FormatKnown(const AudioStreamBasicDescription& processing_format,
-                   MediaToolboxGlue::CMItemCount max_frame_count);
-
-  scoped_refptr<media::DataBuffer> GetDataBuffer(int buffer_size);
-
-  void BufferFilled(const scoped_refptr<media::DataBuffer>& buffer);
-
-  const AudioStreamBasicDescription& stream_format() const {
-    return stream_format_;
-  }
-
- private:
-  void PreallocateBuffers(int size);
-  void BufferFilledInternal(const scoped_refptr<media::DataBuffer>& buffer);
-
-  AVFAudioTap::FormatKnownCB format_known_cb_;
-  AVFAudioTap::SamplesReadyCB samples_ready_cb_;
-
-  // Used to protect access to |buffers|.
-  base::Lock buffer_lock_;
-  std::deque<scoped_refptr<media::DataBuffer>> buffers_;
-
-  base::Callback<void(const scoped_refptr<media::DataBuffer>&)>
-      buffer_filled_cb_;
-
-  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-
-  AudioStreamBasicDescription stream_format_;
-
-  base::WeakPtrFactory<Context> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(Context);
-};
-
-Context::Context(const InitParams& params)
-    : format_known_cb_(params.format_known_cb),
-      samples_ready_cb_(params.samples_ready_cb),
-      task_runner_(params.task_runner),
-      weak_ptr_factory_(this) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-  buffer_filled_cb_ = base::Bind(&Context::BufferFilledInternal,
-                                 weak_ptr_factory_.GetWeakPtr());
-}
-
-Context::~Context() {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(task_runner_->BelongsToCurrentThread());
-}
-
-// static
-void Context::Destroy(Context* context) {
-  context->task_runner_->DeleteSoon(FROM_HERE, context);
-}
-
-// static
-inline Context* Context::FromTap(
-    MediaToolboxGlue::MTAudioProcessingTapRef tap) {
-  return reinterpret_cast<Context*>(
-      MediaToolboxGlue::MTAudioProcessingTapGetStorage(tap));
-}
-
-void Context::FormatKnown(const AudioStreamBasicDescription& processing_format,
-                          MediaToolboxGlue::CMItemCount max_frame_count) {
-  stream_format_ = processing_format;
-  DCHECK_NE(stream_format_.mFormatFlags & kAudioFormatFlagIsNonInterleaved, 0u);
-
-  if (!format_known_cb_.is_null()) {
-    task_runner_->PostTask(FROM_HERE,
-                           base::Bind(format_known_cb_, stream_format_));
-  }
-
-  const int buffer_size = max_frame_count * stream_format_.mBytesPerFrame *
-                          stream_format_.mChannelsPerFrame;
-  DVLOG(3) << "Audio Tap Processor buffer size: " << buffer_size;
-  PreallocateBuffers(buffer_size);
-}
-
-scoped_refptr<media::DataBuffer> Context::GetDataBuffer(int buffer_size) {
-  scoped_refptr<media::DataBuffer> buffer;
-
-  {
-    base::AutoLock auto_lock(buffer_lock_);
-    if (!buffers_.empty()) {
-      buffer = buffers_.front();
-      buffers_.pop_front();
-      buffer->set_data_size(buffer_size);
-    }
-  }
-
-  if (!buffer) {
-    DVLOG(1) << "Ran out of pre-allocated buffers";
-    buffer = new media::DataBuffer(buffer_size);
-    buffer->set_data_size(buffer_size);
-  }
-
-  return buffer;
-}
-
-void Context::BufferFilled(const scoped_refptr<media::DataBuffer>& buffer) {
-  task_runner_->PostTask(FROM_HERE, base::Bind(buffer_filled_cb_, buffer));
-}
-
-void Context::PreallocateBuffers(int size) {
-  base::AutoLock auto_lock(buffer_lock_);
-  while (buffers_.size() < kMaxPreallocatedBufferCount) {
-    buffers_.push_back(new media::DataBuffer(size));
-    buffers_.back()->set_data_size(size);
-  }
-}
-
-void Context::BufferFilledInternal(
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  samples_ready_cb_.Run(buffer);
-
-  PreallocateBuffers(buffer->data_size());
-}
-
-void Init(MediaToolboxGlue::MTAudioProcessingTapRef tap,
-          void* client_info,
-          void** tap_storage_out) {
-  DCHECK(client_info != NULL);
-  DVLOG(1) << "Initialising the Audio Tap Processor";
-
-  const Context::InitParams& params =
-      *reinterpret_cast<Context::InitParams*>(client_info);
-  *tap_storage_out = new Context(params);
-}
-
-void Finalize(MediaToolboxGlue::MTAudioProcessingTapRef tap) {
-  DVLOG(1) << "Finalizing the Audio Tap Processor";
-
-  Context* context = Context::FromTap(tap);
-  Context::Destroy(context);
-}
-
-void Prepare(MediaToolboxGlue::MTAudioProcessingTapRef tap,
-             MediaToolboxGlue::CMItemCount max_frame_count,
-             const AudioStreamBasicDescription* processing_format) {
-  DVLOG(1) << "Preparing the Audio Tap Processor";
-
-  Context* context = Context::FromTap(tap);
-  context->FormatKnown(*processing_format, max_frame_count);
-}
-
-void Process(MediaToolboxGlue::MTAudioProcessingTapRef tap,
-             MediaToolboxGlue::CMItemCount frame_count,
-             MediaToolboxGlue::MTAudioProcessingTapFlags flags,
-             AudioBufferList* buffer_list,
-             MediaToolboxGlue::CMItemCount* frame_count_out,
-             MediaToolboxGlue::MTAudioProcessingTapFlags* flags_out) {
-  DVLOG(5) << "The Audio Tap Processor is processing";
-
-  Context* context = Context::FromTap(tap);
-
-  CMTimeRange time_range;
-  const OSStatus status = MediaToolboxGlue::MTAudioProcessingTapGetSourceAudio(
-      tap,
-      frame_count,
-      buffer_list,
-      flags_out,
-      reinterpret_cast<CoreMediaGlue::CMTimeRange*>(&time_range),
-      frame_count_out);
-
-  if (status != 0) {
-    DVLOG(1) << "There was an error getting audio buffers from the stream.";
-    return;
-  }
-  DCHECK_EQ(frame_count, *frame_count_out);
-  // TODO(wdzierzanowski): How to handle this?  This is set for some movies.
-  DVLOG_IF(
-      1,
-      (((flags | *flags_out) &
-        MediaToolboxGlue::kMTAudioProcessingTapFlag_StartOfStream) != 0))
-      << "StartOfStream flag set";
-  DCHECK(((flags | *flags_out) &
-          MediaToolboxGlue::kMTAudioProcessingTapFlag_EndOfStream) == 0);
-
-  const base::TimeDelta timestamp = media::CMTimeToTimeDelta(time_range.start);
-  const base::TimeDelta duration =
-      media::CMTimeToTimeDelta(time_range.duration);
-
-  DVLOG(1) << "Timestamp: " << timestamp.InMicroseconds() << ", duration "
-           << duration.InMicroseconds();
-  if (duration.InMicroseconds() <= 0) {
-    DVLOG(3) << "Non-positive duration " << duration.InMicroseconds()
-             << " @ timestamp " << timestamp.InMicroseconds()
-             << ", dropping audio buffers";
-    return;
-  }
-  const unsigned channel_buffer_size =
-      buffer_list->mNumberBuffers > 0 ? buffer_list->mBuffers[0].mDataByteSize
-                                      : 0;
-  const unsigned channel_count = context->stream_format().mChannelsPerFrame;
-  DCHECK_EQ(channel_count, buffer_list->mNumberBuffers);
-
-  const int buffer_size = channel_buffer_size * channel_count;
-  scoped_refptr<media::DataBuffer> buffer = context->GetDataBuffer(buffer_size);
-
-  for (unsigned channel = 0; channel < channel_count; ++channel) {
-    const AudioBuffer& channel_buffer = buffer_list->mBuffers[channel];
-    DCHECK_EQ(channel_buffer_size, channel_buffer.mDataByteSize);
-    std::copy((const uint8_t*)channel_buffer.mData,
-              (const uint8_t*)channel_buffer.mData + channel_buffer_size,
-              buffer->writable_data() + channel * channel_buffer_size);
-  }
-
-  buffer->set_timestamp(timestamp);
-  buffer->set_duration(duration);
-
-  context->BufferFilled(buffer);
-}
-
-void Unprepare(MediaToolboxGlue::MTAudioProcessingTapRef tap) {
-  DVLOG(1) << "Unpreparing the Audio Tap Processor";
-}
-
-}  // audio_tap
-
-AVFAudioTap::AVFAudioTap(
-    AVAssetTrack* audio_track,
-    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner,
-    const FormatKnownCB& format_known_cb,
-    const SamplesReadyCB& samples_ready_cb)
-    : audio_track_(audio_track),
-      task_runner_(task_runner),
-      format_known_cb_(format_known_cb),
-      samples_ready_cb_(samples_ready_cb) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-}
-
-AVFAudioTap::~AVFAudioTap() {
-  DVLOG(1) << __FUNCTION__;
-}
-
-base::scoped_nsobject<AVAudioMix> AVFAudioTap::GetAudioMix() {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  TRACE_EVENT0("IPC_MEDIA", __FUNCTION__);
-
-  audio_tap::Context::InitParams params;
-  params.task_runner = task_runner_;
-  params.format_known_cb = base::ResetAndReturn(&format_known_cb_);
-  params.samples_ready_cb = samples_ready_cb_;
-
-  MediaToolboxGlue::MTAudioProcessingTapCallbacks tap_callbacks;
-  tap_callbacks.version =
-      MediaToolboxGlue::kMTAudioProcessingTapCallbacksVersion_0;
-  tap_callbacks.clientInfo = &params;
-  tap_callbacks.init = audio_tap::Init;
-  tap_callbacks.prepare = audio_tap::Prepare;
-  tap_callbacks.process = audio_tap::Process;
-  tap_callbacks.unprepare = audio_tap::Unprepare;
-  tap_callbacks.finalize = audio_tap::Finalize;
-
-  MediaToolboxGlue::MTAudioProcessingTapRef tap = NULL;
-  const OSStatus status = MediaToolboxGlue::MTAudioProcessingTapCreate(
-      kCFAllocatorDefault,
-      reinterpret_cast<MediaToolboxGlue::MTAudioProcessingTapCallbacks*>
-          (&tap_callbacks),
-      MediaToolboxGlue::kMTAudioProcessingTapCreationFlag_PreEffects,
-      &tap);
-  if (status != 0 || tap == NULL) {
-    DVLOG(1) << "Unable to create the audio processing tap";
-    return base::scoped_nsobject<AVAudioMix>();
-  }
-  DCHECK(tap != NULL);
-  base::ScopedCFTypeRef<MediaToolboxGlue::MTAudioProcessingTapRef> scoped_tap(
-      tap);
-
-  CrAVMutableAudioMixInputParameters* input_parameters =
-      reinterpret_cast<CrAVMutableAudioMixInputParameters*>
-          ([AVFoundationGlue::AVMutableAudioMixInputParametersClass()
-              audioMixInputParametersWithTrack:audio_track_]);
-  [input_parameters setAudioTapProcessor:tap];
-
-  AVMutableAudioMix* audio_mix =
-      [AVFoundationGlue::AVMutableAudioMixClass() audioMix];
-  [audio_mix setInputParameters:@[input_parameters]];
-
-  return base::scoped_nsobject<AVAudioMix>([audio_mix retain]);
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/avf_data_buffer_queue.h b/content/common/gpu/media/avf_data_buffer_queue.h
deleted file mode 100644
index 9b67366..0000000
--- a/content/common/gpu/media/avf_data_buffer_queue.h
+++ /dev/null
@@ -1,74 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_AVF_DATA_BUFFER_QUEUE_H_
-#define CONTENT_COMMON_GPU_MEDIA_AVF_DATA_BUFFER_QUEUE_H_
-
-#include <string>
-
-#include "base/callback.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/threading/thread_checker.h"
-#include "base/time/time.h"
-#include "content/common/content_export.h"
-
-namespace media {
-class DataBuffer;
-}
-
-namespace content {
-
-class CONTENT_EXPORT AVFDataBufferQueue {
- public:
-  // Used for debugging only.
-  enum Type { AUDIO, VIDEO };
-
-  using ReadCB = base::Callback<void(const scoped_refptr<media::DataBuffer>&)>;
-
-  AVFDataBufferQueue(Type type,
-                     const base::TimeDelta& capacity,
-                     const base::Closure& capacity_available_cb,
-                     const base::Closure& capacity_depleted_cb);
-  ~AVFDataBufferQueue();
-
-  void Read(const ReadCB& read_cb);
-
-  void BufferReady(const scoped_refptr<media::DataBuffer>& buffer);
-
-  void SetEndOfStream();
-
-  void Flush();
-
-  bool HasAvailableCapacity() const;
-
-  size_t memory_usage() const;
-
- private:
-  class Queue;
-
-  std::string DescribeBufferSize() const;
-  void SatisfyPendingRead();
-
-  const Type type_;
-  const base::TimeDelta capacity_;
-  base::Closure capacity_available_cb_;
-  base::Closure capacity_depleted_cb_;
-  ReadCB read_cb_;
-  scoped_ptr<Queue> buffer_queue_;
-
-  // We are "catching up" if the stream associated with this queue lags behind
-  // another stream.  This is when we want to allow the queue to return any
-  // buffers it currently has as quickly as possible.
-  bool catching_up_;
-
-  bool end_of_stream_;
-
-  base::ThreadChecker thread_checker_;
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_AVF_DATA_BUFFER_QUEUE_H_
diff --git a/content/common/gpu/media/avf_data_buffer_queue.mm b/content/common/gpu/media/avf_data_buffer_queue.mm
deleted file mode 100644
index 43c6c0b..0000000
--- a/content/common/gpu/media/avf_data_buffer_queue.mm
+++ /dev/null
@@ -1,187 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "content/common/gpu/media/avf_data_buffer_queue.h"
-
-#include <deque>
-
-#include "base/callback_helpers.h"
-#include "base/strings/stringprintf.h"
-#include "media/base/data_buffer.h"
-#include "media/base/timestamp_constants.h"
-
-namespace content {
-
-class AVFDataBufferQueue::Queue {
- public:
-  Queue() : data_size_(0) {}
-
-  void Push(const scoped_refptr<media::DataBuffer>& buffer);
-  scoped_refptr<media::DataBuffer> Pop();
-
-  void Clear();
-
-  bool empty() const { return buffers_.empty(); }
-  size_t data_size() const { return data_size_; }
-  base::TimeDelta GetDuration() const;
-
- private:
-  std::deque<scoped_refptr<media::DataBuffer>> buffers_;
-  size_t data_size_;
-};
-
-void AVFDataBufferQueue::Queue::Push(
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  DCHECK(buffer->timestamp() != media::kNoTimestamp());
-  DCHECK(buffers_.empty() || buffer->timestamp() > buffers_.back()->timestamp())
-      << "Out-of-order buffer @" << buffer->timestamp().InMicroseconds();
-  DCHECK_GE(buffer->data_size(), 0);
-
-  buffers_.push_back(buffer);
-  data_size_ += buffer->data_size();
-}
-
-scoped_refptr<media::DataBuffer> AVFDataBufferQueue::Queue::Pop() {
-  scoped_refptr<media::DataBuffer> buffer = buffers_.front();
-  buffers_.pop_front();
-  data_size_ -= buffer->data_size();
-  return buffer;
-}
-
-void AVFDataBufferQueue::Queue::Clear() {
-  buffers_.clear();
-  data_size_ = 0;
-}
-
-base::TimeDelta AVFDataBufferQueue::Queue::GetDuration() const {
-  if (buffers_.size() < 2)
-    return base::TimeDelta();
-
-  return buffers_.back()->timestamp() - buffers_.front()->timestamp();
-}
-
-
-AVFDataBufferQueue::AVFDataBufferQueue(
-    Type type,
-    const base::TimeDelta& capacity,
-    const base::Closure& capacity_available_cb,
-    const base::Closure& capacity_depleted_cb)
-    : type_(type),
-      capacity_(capacity),
-      capacity_available_cb_(capacity_available_cb),
-      capacity_depleted_cb_(capacity_depleted_cb),
-      buffer_queue_(new Queue),
-      catching_up_(false),
-      end_of_stream_(false) {
-  DCHECK(!capacity_available_cb_.is_null());
-  DCHECK(!capacity_depleted_cb_.is_null());
-}
-
-AVFDataBufferQueue::~AVFDataBufferQueue() = default;
-
-void AVFDataBufferQueue::Read(const ReadCB& read_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(read_cb_.is_null());
-
-  DVLOG(7) << "Read()";
-
-  read_cb_ = read_cb;
-  SatisfyPendingRead();
-}
-
-void AVFDataBufferQueue::BufferReady(
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(buffer.get() != NULL);
-  DCHECK(!end_of_stream_) << "Can't enqueue buffers anymore";
-
-  DVLOG(7) << (type_ == AUDIO ? "AUDIO" : "VIDEO")
-           << " buffer ready: timestamp="
-           << buffer->timestamp().InMicroseconds()
-           << " duration=" << buffer->duration().InMicroseconds()
-           << " size=" << buffer->data_size();
-
-  buffer_queue_->Push(buffer);
-  DVLOG(7) << DescribeBufferSize();
-
-  if (!HasAvailableCapacity())
-    catching_up_ = false;
-
-  SatisfyPendingRead();
-}
-
-void AVFDataBufferQueue::SetEndOfStream() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  end_of_stream_ = true;
-  SatisfyPendingRead();
-}
-
-void AVFDataBufferQueue::Flush() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  end_of_stream_ = false;
-  buffer_queue_->Clear();
-  catching_up_ = false;
-
-  DVLOG(7) << DescribeBufferSize();
-}
-
-bool AVFDataBufferQueue::HasAvailableCapacity() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  return buffer_queue_->GetDuration() < capacity_;
-}
-
-size_t AVFDataBufferQueue::memory_usage() const {
-  return buffer_queue_->data_size();
-}
-
-std::string AVFDataBufferQueue::DescribeBufferSize() const {
-  return base::StringPrintf("Have %lld us of queued %s data, queue size: %lu",
-                            buffer_queue_->GetDuration().InMicroseconds(),
-                            type_ == AUDIO ? "AUDIO" : "VIDEO",
-                            buffer_queue_->data_size());
-}
-
-void AVFDataBufferQueue::SatisfyPendingRead() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (!read_cb_.is_null()) {
-    scoped_refptr<media::DataBuffer> buffer;
-
-    if (end_of_stream_) {
-      buffer = !buffer_queue_->empty() ? buffer_queue_->Pop()
-                                       : media::DataBuffer::CreateEOSBuffer();
-    } else if (!HasAvailableCapacity() ||
-               (catching_up_ && !buffer_queue_->empty())) {
-      // The condition above will allow the queue to collect some number of
-      // buffers before we start to return them.  Unless we are in the
-      // "catching up" mode, which is when we want to return the buffers as
-      // quickly as possible.
-      buffer = buffer_queue_->Pop();
-      catching_up_ = true;
-    }
-
-    if (buffer.get() != NULL) {
-      DVLOG(7) << DescribeBufferSize();
-      base::ResetAndReturn(&read_cb_).Run(buffer);
-    } else {
-      DVLOG(7) << "Not enough data available to satisfy read request. Request "
-                  "is pending.";
-    }
-
-    if (buffer_queue_->empty())
-      catching_up_ = false;
-  }
-
-  if (HasAvailableCapacity() && !end_of_stream_)
-    capacity_available_cb_.Run();
-  else if (!HasAvailableCapacity())
-    capacity_depleted_cb_.Run();
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/avf_data_buffer_queue_unittest.mm b/content/common/gpu/media/avf_data_buffer_queue_unittest.mm
deleted file mode 100644
index a1d91bf..0000000
--- a/content/common/gpu/media/avf_data_buffer_queue_unittest.mm
+++ /dev/null
@@ -1,160 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "content/common/gpu/media/avf_data_buffer_queue.h"
-
-#include "base/bind.h"
-#include "media/base/data_buffer.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace content {
-namespace {
-
-const base::TimeDelta kCapacity = base::TimeDelta::FromMicroseconds(16);
-
-scoped_refptr<media::DataBuffer> CreateBuffer(const base::TimeDelta& timestamp,
-                                              const base::TimeDelta& duration) {
-  scoped_refptr<media::DataBuffer> buffer(new media::DataBuffer(1));
-  buffer->set_timestamp(timestamp);
-  buffer->set_duration(duration);
-  return buffer;
-}
-
-class AVFDataBufferQueueTest : public testing::Test {
- public:
-  AVFDataBufferQueueTest()
-      : queue_(AVFDataBufferQueue::Type(),
-               kCapacity,
-               base::Bind(&AVFDataBufferQueueTest::CapacityAvailable,
-                          base::Unretained(this)),
-               base::Bind(&AVFDataBufferQueueTest::CapacityDepleted,
-                          base::Unretained(this))),
-        capacity_available_(false),
-        capacity_depleted_(false) {}
-
- protected:
-  AVFDataBufferQueue::ReadCB read_cb() {
-    return base::Bind(&AVFDataBufferQueueTest::OnRead, base::Unretained(this));
-  }
-
-  AVFDataBufferQueue queue_;
-  bool capacity_available_;
-  bool capacity_depleted_;
-  scoped_refptr<media::DataBuffer> last_buffer_read_;
-
- private:
-  void CapacityAvailable() { capacity_available_ = true; }
-  void CapacityDepleted() { capacity_depleted_ = true; }
-  void OnRead(const scoped_refptr<media::DataBuffer>& buffer) {
-    last_buffer_read_ = buffer;
-  }
-};
-
-TEST_F(AVFDataBufferQueueTest, DepleteCapacity) {
-  ASSERT_TRUE(queue_.HasAvailableCapacity());
-  ASSERT_FALSE(capacity_depleted_);
-
-  queue_.BufferReady(CreateBuffer(base::TimeDelta(), kCapacity));
-  EXPECT_TRUE(queue_.HasAvailableCapacity());
-  EXPECT_FALSE(capacity_depleted_);
-
-  queue_.BufferReady(CreateBuffer(kCapacity, kCapacity));
-  EXPECT_FALSE(queue_.HasAvailableCapacity());
-  EXPECT_TRUE(capacity_depleted_);
-}
-
-TEST_F(AVFDataBufferQueueTest, FreeCapacity) {
-  queue_.BufferReady(CreateBuffer(base::TimeDelta(), kCapacity));
-  queue_.BufferReady(CreateBuffer(kCapacity, kCapacity));
-  queue_.BufferReady(CreateBuffer(kCapacity * 2, kCapacity));
-  ASSERT_FALSE(queue_.HasAvailableCapacity());
-  capacity_available_ = false;
-
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  ASSERT_FALSE(last_buffer_read_.get() == NULL);
-  EXPECT_FALSE(capacity_available_);
-
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  EXPECT_FALSE(last_buffer_read_.get() == NULL);
-  EXPECT_TRUE(capacity_available_);
-}
-
-TEST_F(AVFDataBufferQueueTest, CatchUpMode) {
-  // Normally, we want the queue to collect some buffers before it starts to
-  // return them.
-
-  queue_.BufferReady(CreateBuffer(base::TimeDelta(), kCapacity / 2));
-
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  ASSERT_TRUE(last_buffer_read_.get() == NULL);
-
-  queue_.BufferReady(CreateBuffer(kCapacity / 2, kCapacity / 2));
-
-  ASSERT_TRUE(last_buffer_read_.get() == NULL);
-
-  // But when we enter the "catching-up" mode, we want all the buffers it's
-  // got, NOW!
-
-  queue_.BufferReady(CreateBuffer(kCapacity, kCapacity / 2));
-
-  ASSERT_FALSE(last_buffer_read_.get() == NULL);
-
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  ASSERT_FALSE(last_buffer_read_.get() == NULL);
-
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  ASSERT_FALSE(last_buffer_read_.get() == NULL);
-
-  // An empty queue should take the time to collect some buffers again before
-  // it resumes returning them.
-
-  queue_.BufferReady(CreateBuffer(3 * kCapacity / 2, kCapacity / 2));
-
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  ASSERT_TRUE(last_buffer_read_.get() == NULL);
-}
-
-TEST_F(AVFDataBufferQueueTest, Flush) {
-  queue_.BufferReady(CreateBuffer(base::TimeDelta(), kCapacity));
-  queue_.Flush();
-
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  EXPECT_TRUE(last_buffer_read_.get() == NULL);
-}
-
-TEST_F(AVFDataBufferQueueTest, EndOfStream) {
-  queue_.BufferReady(CreateBuffer(base::TimeDelta(), kCapacity));
-
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  ASSERT_TRUE(last_buffer_read_.get() == NULL);
-
-  queue_.SetEndOfStream();
-
-  ASSERT_FALSE(last_buffer_read_.get() == NULL);
-  EXPECT_FALSE(last_buffer_read_->end_of_stream());
-
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  ASSERT_FALSE(last_buffer_read_.get() == NULL);
-  EXPECT_TRUE(last_buffer_read_->end_of_stream());
-
-  // All further reads should return the EOS buffer, too.
-  last_buffer_read_ = NULL;
-  queue_.Read(read_cb());
-  ASSERT_FALSE(last_buffer_read_.get() == NULL);
-  EXPECT_TRUE(last_buffer_read_->end_of_stream());
-}
-
-}  // namespace
-}  // namespace content
diff --git a/content/common/gpu/media/avf_media_decoder.h b/content/common/gpu/media/avf_media_decoder.h
deleted file mode 100644
index dc3a7cf..0000000
--- a/content/common/gpu/media/avf_media_decoder.h
+++ /dev/null
@@ -1,213 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_DECODER_H_
-#define CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_DECODER_H_
-
-#import <AudioToolbox/AudioToolbox.h>
-#import <AVFoundation/AVFoundation.h>
-
-#include <string>
-
-#include "base/callback.h"
-#include "base/mac/scoped_nsobject.h"
-#include "base/mac/sdk_forward_declarations.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/memory/weak_ptr.h"
-#include "base/strings/string_piece.h"
-#include "base/synchronization/cancellation_flag.h"
-#include "base/threading/thread_checker.h"
-#include "ui/gfx/geometry/size.h"
-
-@class DataSourceLoader;
-@class PlayerNotificationObserver;
-@class PlayerObserver;
-
-namespace media {
-class DataBuffer;
-}  // namespace media
-
-namespace content {
-
-class AVFAudioTap;
-class IPCDataSource;
-
-class AVFMediaDecoderClient {
- public:
-  virtual ~AVFMediaDecoderClient() {}
-
-  virtual void AudioSamplesReady(
-      const scoped_refptr<media::DataBuffer>& buffer) = 0;
-  virtual void VideoFrameReady(
-      const scoped_refptr<media::DataBuffer>& buffer) = 0;
-  virtual void StreamHasEnded() = 0;
-
-  virtual bool HasAvailableCapacity() = 0;
-};
-
-
-// The glue between AV Foundation and the media module used for media playback.
-//
-// This class mediates between AV Foundation and Chrome's classes and data
-// structures to allow media decoding through PlatformMediaPipeline on Mac.  An
-// AVFMediaDecoder object must be created for each media element that is
-// decoded through PlatformMediaPipeline.
-//
-// AVFMediaDecoder takes raw media data as input and outputs decoded audio and
-// video data, handling the demuxing and decoding internally.  Input data is
-// provided via an IPCDataSource, and output data is consumed by an
-// AVFMediaDecoderClient.
-class AVFMediaDecoder {
- public:
-  typedef base::Callback<void(bool success)> ResultCB;
-  typedef base::RefCountedData<base::CancellationFlag> SharedCancellationFlag;
-
-  // |client| must outlive AVFMediaDecoder.
-  explicit AVFMediaDecoder(AVFMediaDecoderClient* client);
-  ~AVFMediaDecoder();
-
-  void Initialize(IPCDataSource* data_source,
-                  const std::string& mime_type,
-                  const ResultCB& result_cb);
-  void Seek(const base::TimeDelta& time, const ResultCB& result_cb);
-
-  void NotifyStreamCapacityDepleted();
-  void NotifyStreamCapacityAvailable();
-
-  bool has_audio_track() const { return AudioTrack() != nil; }
-  bool has_video_track() const { return VideoTrack() != nil; }
-
-  base::TimeDelta duration() const { return duration_; }
-  base::TimeDelta start_time() const;
-  const AudioStreamBasicDescription& audio_stream_format() const {
-    DCHECK(!has_audio_track() || is_audio_format_known());
-    return audio_stream_format_;
-  }
-  CMFormatDescriptionRef video_stream_format() const {
-    DCHECK(!has_video_track() || is_video_format_known());
-    return video_stream_format_;
-  }
-  CGAffineTransform video_transform() const {
-    DCHECK(has_video_track());
-    return [VideoTrack() preferredTransform];
-  }
-  gfx::Size video_coded_size() const { return video_coded_size_; }
-  int bitrate() const {
-    DCHECK_GE(bitrate_, 0);
-    return bitrate_;
-  }
-
- private:
-  enum PlaybackState { STARTING, PLAYING, STOPPING, STOPPED };
-
-  void AssetKeysLoaded(const ResultCB& initialize_cb,
-                       base::scoped_nsobject<AVAsset> asset,
-                       base::scoped_nsobject<NSArray> keys);
-  void PlayerStatusKnown(const ResultCB& initialize_cb,
-                         base::scoped_nsobject<id> status);
-
-  bool CalculateBitrate();
-
-  void InitializeAudioOutput(const ResultCB& initialize_cb);
-  void AudioFormatKnown(const ResultCB& initialize_cb,
-                        const AudioStreamBasicDescription& format);
-  bool InitializeVideoOutput();
-
-  void AudioSamplesReady(const scoped_refptr<media::DataBuffer>& buffer);
-  void ReadFromVideoOutput(const CMTime& timestamp);
-
-  void AutoSeekDone();
-  void SeekDone(const ResultCB& result_cb, bool finished);
-  void RunTasksPendingSeekDone();
-
-  void PlayerPlayedToEnd(base::StringPiece source);
-  void PlayerItemTimeRangesChanged(base::scoped_nsobject<id> new_ranges);
-  void PlayerRateChanged(base::scoped_nsobject<id> new_rate);
-  void PlayWhenReady(base::StringPiece reason);
-
-  void PlayIfNotLikelyToStall(base::StringPiece reason, bool likely_to_stall);
-  void SeekIfNotLikelyToStall(bool likely_to_stall);
-
-  void ScheduleSeekTask(const base::Closure& seek_task);
-  void SeekTask(const base::TimeDelta& time, const ResultCB& result_cb);
-  void AutoSeekTask();
-
-  bool is_audio_format_known() const {
-    return audio_stream_format_.mSampleRate != 0;
-  }
-  bool is_video_format_known() const {
-    return video_stream_format_ != NULL;
-  }
-
-  AVAssetTrack* AssetTrackForType(NSString* track_type_name) const;
-  AVAssetTrack* VideoTrack() const;
-  AVAssetTrack* AudioTrack() const;
-  double VideoFrameRate() const;
-
-  // Returns a background runner of long-running tasks.  Certain AVPlayerItem
-  // functions can take a lot more than a few milliseconds, and we can't afford
-  // to block the main thread of the GPU process for that long.
-  scoped_refptr<base::TaskRunner> background_runner() const;
-
-
-  AVFMediaDecoderClient* const client_;
-
-  base::scoped_nsobject<DataSourceLoader> data_source_loader_;
-  base::scoped_nsobject<AVPlayer> player_;
-  base::scoped_nsobject<PlayerObserver> status_observer_;
-  base::scoped_nsobject<PlayerObserver> rate_observer_;
-  base::scoped_nsobject<PlayerNotificationObserver> played_to_end_observer_;
-  base::scoped_nsobject<PlayerObserver> player_item_loaded_times_observer_;
-  base::scoped_nsobject<AVPlayerItemVideoOutput> video_output_;
-  base::scoped_nsobject<id> time_observer_handle_;
-
-  base::TimeDelta duration_;
-  AudioStreamBasicDescription audio_stream_format_;
-  CMFormatDescriptionRef video_stream_format_;
-  gfx::Size video_coded_size_;
-  int bitrate_;
-
-  scoped_ptr<AVFAudioTap> audio_tap_;
-
-  base::TimeDelta last_audio_timestamp_;
-  base::TimeDelta last_video_timestamp_;
-  PlaybackState playback_state_;
-
-  // Whether we are currently processing either a user- or auto-initiated seek
-  // request.
-  bool seeking_;
-
-  // A user- or auto-initiated seek request postponed until AVPlayer is not
-  // considered likely to stall for lack of data.
-  base::Closure pending_seek_task_;
-
-  // Wraps a |PlayWhenReady()| call to be run once AVPlayer is actually paused
-  // following a -[AVPlayer pause] call.
-  base::Closure play_on_pause_done_task_;
-
-  // Wraps a |PlayWhenReady()| call to be run once we are done processing a
-  // seek request.
-  base::Closure play_on_seek_done_task_;
-
-  // Wraps a |Seek()| call to be run once we are done processing an auto-seek
-  // request.
-  base::Closure seek_on_seek_done_task_;
-
-  bool stream_has_ended_;
-  base::TimeDelta min_loaded_range_size_;
-
-  scoped_refptr<SharedCancellationFlag> background_tasks_canceled_;
-
-  base::ThreadChecker thread_checker_;
-  base::WeakPtrFactory<AVFMediaDecoder> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(AVFMediaDecoder);
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_DECODER_H_
diff --git a/content/common/gpu/media/avf_media_decoder.mm b/content/common/gpu/media/avf_media_decoder.mm
deleted file mode 100644
index f57bda7..0000000
--- a/content/common/gpu/media/avf_media_decoder.mm
+++ /dev/null
@@ -1,1073 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "content/common/gpu/media/avf_media_decoder.h"
-
-#include "base/lazy_instance.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/scoped_cftyperef.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/strings/string_util.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/task_runner_util.h"
-#include "base/threading/thread.h"
-#include "base/trace_event/trace_event.h"
-#include "content/common/gpu/media/avf_audio_tap.h"
-#import "content/common/gpu/media/data_source_loader.h"
-#include "media/base/bind_to_current_loop.h"
-#include "media/base/data_buffer.h"
-#include "media/base/mac/avfoundation_glue.h"
-#include "media/base/mac/framework_type_conversions.h"
-#include "media/base/timestamp_constants.h"
-#include "media/base/video_frame.h"
-#include "media/filters/platform_media_pipeline_types_mac.h"
-#include "net/base/mime_util.h"
-
-namespace {
-typedef base::Callback<void(base::scoped_nsobject<id>)> PlayerObserverCallback;
-}  // namespace
-
-@interface AVURLAsset (MavericksSDK)
-@property(nonatomic, readonly) CrAVAssetResourceLoader* resourceLoader;
-@end
-
-@interface PlayerObserver : NSObject {
- @private
-  NSString* keyPath_;
-  PlayerObserverCallback callback_;
-}
-
-@property (retain,readonly) NSString* keyPath;
-
-- (id)initForKeyPath:(NSString*)keyPath
-        withCallback:(const PlayerObserverCallback&)callback;
-@end
-
-@implementation PlayerObserver
-
-@synthesize keyPath = keyPath_;
-
-- (id)initForKeyPath:(NSString*)keyPath
-        withCallback:(const PlayerObserverCallback&)callback {
-  if ((self = [super init])) {
-    keyPath_ = [keyPath retain];
-    callback_ = callback;
-  }
-  return self;
-}
-
-- (void)observeValueForKeyPath:(NSString*)keyPath
-                      ofObject:(id)object
-                        change:(NSDictionary*)change
-                       context:(void*)context {
-  if ([keyPath isEqualToString:[self keyPath]]) {
-    callback_.Run(base::scoped_nsobject<id>(
-        [[change objectForKey:NSKeyValueChangeNewKey] retain]));
-  }
-}
-
-@end
-
-@interface PlayerNotificationObserver : NSObject {
- @private
-  base::Closure callback_;
-}
-- (id)initWithCallback:(const base::Closure&)callback;
-@end
-
-@implementation PlayerNotificationObserver
-
-- (id)initWithCallback:(const base::Closure&)callback {
-  if ((self = [super init])) {
-    callback_ = callback;
-  }
-  return self;
-}
-
-- (void)observe:(NSNotification*)notification {
-  callback_.Run();
-}
-
-@end
-
-namespace content {
-
-namespace {
-
-// The initial value of the amount of data that we require AVPlayer to have in
-// order to consider it unlikely to stall right after starting to play.
-const base::TimeDelta kInitialRequiredLoadedTimeRange =
-    base::TimeDelta::FromMilliseconds(300);
-
-// Each time AVPlayer runs out of data we increase the required loaded time
-// range size up to this value.
-const base::TimeDelta kMaxRequiredLoadedTimeRange =
-    base::TimeDelta::FromSeconds(4);
-
-class BackgroundThread {
- public:
-  BackgroundThread() : thread_("OpMediaDecoder") { CHECK(thread_.Start()); }
-
-  scoped_refptr<base::TaskRunner> task_runner() const {
-    return thread_.task_runner();
-  }
-
- private:
-  base::Thread thread_;
-};
-
-base::LazyInstance<BackgroundThread> g_background_thread =
-    LAZY_INSTANCE_INITIALIZER;
-
-class ScopedBufferLock {
- public:
-  explicit ScopedBufferLock(CVPixelBufferRef buffer) : buffer_(buffer) {
-    CVPixelBufferLockBaseAddress(buffer_, kCVPixelBufferLock_ReadOnly);
-  }
-  ~ScopedBufferLock() {
-    CVPixelBufferUnlockBaseAddress(buffer_, kCVPixelBufferLock_ReadOnly);
-  }
-
- private:
-  const CVPixelBufferRef buffer_;
-};
-
-scoped_refptr<media::DataBuffer> GetVideoFrame(
-    AVPlayerItemVideoOutput* video_output,
-    const CMTime& timestamp,
-    const gfx::Size& coded_size) {
-  TRACE_EVENT0("IPC_MEDIA", __FUNCTION__);
-
-  base::ScopedCFTypeRef<CVPixelBufferRef> pixel_buffer;
-  if ([video_output hasNewPixelBufferForItemTime:timestamp]) {
-    pixel_buffer.reset([video_output copyPixelBufferForItemTime:timestamp
-                                             itemTimeForDisplay:nil]);
-  }
-  if (pixel_buffer == NULL) {
-    DVLOG(3) << "No pixel buffer available for time "
-             << media::CMTimeToTimeDelta(timestamp).InMicroseconds();
-    return NULL;
-  }
-
-  DCHECK_EQ(CVPixelBufferGetPlaneCount(pixel_buffer), 3u);
-
-  // TODO(wdzierzanowski): Don't copy pixel buffers to main memory, share GL
-  // textures with the render process instead. Will be investigated in work
-  // package DNA-21454.
-
-  ScopedBufferLock auto_lock(pixel_buffer);
-
-  int strides[3] = { 0 };
-  size_t plane_sizes[3] = { 0 };
-  const int video_frame_planes[] = { media::VideoFrame::kYPlane,
-                                     media::VideoFrame::kUPlane,
-                                     media::VideoFrame::kVPlane };
-
-  // The planes in the pixel buffer are YUV, but PassThroughVideoDecoder
-  // assumes YVU, so we switch the order of the last two planes.
-  const int planes[] = { 0, 2, 1 };
-  for (int i = 0; i < 3; ++i) {
-    const int plane = planes[i];
-
-    // TODO(wdzierzanowski): Use real stride values for video config. Will be
-    // fixed in work package DNA-21454
-    strides[plane] = CVPixelBufferGetBytesPerRowOfPlane(pixel_buffer, plane);
-    DVLOG(7) << "strides[" << plane << "] = " << strides[plane];
-
-    plane_sizes[plane] = strides[plane] * media::VideoFrame::PlaneSize(
-          media::PIXEL_FORMAT_YV12,
-          video_frame_planes[plane],
-          coded_size).height();
-  }
-
-  // Copy all planes into contiguous memory.
-  const int data_size = plane_sizes[0] + plane_sizes[1] + plane_sizes[2];
-  scoped_refptr<media::DataBuffer> video_data_buffer =
-      new media::DataBuffer(data_size);
-  size_t data_offset = 0;
-  for (int i = 0; i < 3; ++i) {
-    const int plane = planes[i];
-
-    memcpy(video_data_buffer->writable_data() + data_offset,
-           CVPixelBufferGetBaseAddressOfPlane(pixel_buffer, plane),
-           plane_sizes[plane]);
-
-    data_offset += plane_sizes[plane];
-  }
-
-  video_data_buffer->set_data_size(data_size);
-  video_data_buffer->set_timestamp(media::CMTimeToTimeDelta(timestamp));
-
-  return video_data_buffer;
-}
-
-void SetAudioMix(
-    const scoped_refptr<AVFMediaDecoder::SharedCancellationFlag> canceled,
-    AVPlayerItem* item,
-    base::scoped_nsobject<AVAudioMix> audio_mix) {
-  DCHECK(g_background_thread.Get().task_runner()->RunsTasksOnCurrentThread());
-  TRACE_EVENT0("IPC_MEDIA", __FUNCTION__);
-
-  if (canceled->data.IsSet())
-    return;
-
-  [item setAudioMix:audio_mix];
-}
-
-bool IsPlayerLikelyToStallWithRanges(
-    AVPlayerItem* item,
-    base::scoped_nsobject<NSArray> loaded_ranges,
-    base::TimeDelta min_range_size) {
-  // The ranges provided might be discontinuous, but this decoder is interested
-  // only in first continuous range, and how much time is buffered in this
-  // range. Other ranges are not necessary for playback continuation.
-  if ([loaded_ranges count] > 0) {
-    CMTimeRange time_range = [[loaded_ranges objectAtIndex:0] CMTimeRangeValue];
-
-    const base::TimeDelta end_of_loaded_range =
-        media::CMTimeToTimeDelta(time_range.start) +
-        media::CMTimeToTimeDelta(time_range.duration);
-    if (end_of_loaded_range >= media::CMTimeToTimeDelta([item duration]))
-        return false;
-
-    const base::TimeDelta current_time =
-        media::CMTimeToTimeDelta([item currentTime]);
-    return end_of_loaded_range - current_time < min_range_size;
-  }
-
-  DVLOG(5) << "AVPlayerItem does not have any loadedTimeRanges value";
-  return true;
-}
-
-bool IsPlayerLikelyToStall(
-    const scoped_refptr<AVFMediaDecoder::SharedCancellationFlag> canceled,
-    AVPlayerItem* item,
-    base::TimeDelta min_range_size) {
-  DCHECK(g_background_thread.Get().task_runner()->RunsTasksOnCurrentThread());
-  TRACE_EVENT0("IPC_MEDIA", "will stall?");
-
-  if (canceled->data.IsSet())
-    return false;
-
-  return IsPlayerLikelyToStallWithRanges(
-      item,
-      base::scoped_nsobject<NSArray>([[item loadedTimeRanges] retain]),
-      min_range_size);
-}
-
-}  // namespace
-
-
-AVFMediaDecoder::AVFMediaDecoder(AVFMediaDecoderClient* client)
-    : client_(client),
-      audio_stream_format_({0}),
-      bitrate_(-1),
-      last_audio_timestamp_(media::kNoTimestamp()),
-      last_video_timestamp_(media::kNoTimestamp()),
-      playback_state_(STOPPED),
-      seeking_(false),
-      stream_has_ended_(false),
-      min_loaded_range_size_(kInitialRequiredLoadedTimeRange),
-      background_tasks_canceled_(new SharedCancellationFlag),
-      weak_ptr_factory_(this) {
-  DCHECK(client_ != NULL);
-}
-
-AVFMediaDecoder::~AVFMediaDecoder() {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  background_tasks_canceled_->data.Set();
-
-  // Without it, memory allocated by AVFoundation when we call
-  // -[AVAssetResourceLoadingDataRequest respondWithData:] in DataSourceLoader
-  // is never released.  Yes, it's weird, but I don't know how else we can
-  // avoid the memory leak.
-  // Also, the AVSimplePlayer demo application does it, too.
-  [player_ pause];
-
-  [player_ removeTimeObserver:time_observer_handle_];
-
-  [[player_ currentItem] removeOutput:video_output_];
-
-  // This finalizes the audio processing tap.
-  [[player_ currentItem] setAudioMix:nil];
-
-  if (player_item_loaded_times_observer_.get() != nil) {
-    [[player_ currentItem]
-        removeObserver:player_item_loaded_times_observer_
-            forKeyPath:[player_item_loaded_times_observer_ keyPath]];
-  }
-
-  [[NSNotificationCenter defaultCenter] removeObserver:played_to_end_observer_];
-
-  if (rate_observer_.get() != nil) {
-    [player_ removeObserver:rate_observer_ forKeyPath:[rate_observer_ keyPath]];
-  }
-  if (status_observer_.get() != nil) {
-    [player_ removeObserver:status_observer_
-                 forKeyPath:[status_observer_ keyPath]];
-  }
-
-  [data_source_loader_ stop];
-}
-
-void AVFMediaDecoder::Initialize(IPCDataSource* data_source,
-                                 const std::string& mime_type,
-                                 const ResultCB& initialize_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  data_source_loader_.reset([[DataSourceLoader alloc]
-      initWithDataSource:data_source
-            withMIMEType:base::SysUTF8ToNSString(mime_type)]);
-
-  // Use a "custom" URL scheme to force AVURLAsset to ask our instance of
-  // AVAssetResourceLoaderDelegate for data.  This way, we make sure all data
-  // is fetched through Chrome's network stack rather than by AVURLAsset
-  // directly.
-  // AVPlayer does not play some links (without extension, with query or
-  // containing some characters like ';'). To avoid all future problems with
-  // invalid URL, file name set in AVURLAsset is constant.
-  AVURLAsset* url_asset = [AVFoundationGlue::AVAssetClass()
-      assetWithURL:[NSURL URLWithString:@"opop://media_file.mp4"]];
-  base::scoped_nsobject<AVAsset> asset([url_asset retain]);
-
-  [[url_asset resourceLoader] setDelegate:data_source_loader_
-                                    queue:[data_source_loader_ dispatchQueue]];
-
-  base::scoped_nsobject<NSArray> asset_keys_to_load_and_test(
-      [[NSArray arrayWithObjects:@"playable",
-                                 @"hasProtectedContent",
-                                 @"tracks",
-                                 @"duration",
-                                 nil] retain]);
-  const base::Closure asset_keys_loaded_cb =
-      media::BindToCurrentLoop(base::Bind(&AVFMediaDecoder::AssetKeysLoaded,
-                                          weak_ptr_factory_.GetWeakPtr(),
-                                          initialize_cb,
-                                          asset,
-                                          asset_keys_to_load_and_test));
-
-  [url_asset loadValuesAsynchronouslyForKeys:asset_keys_to_load_and_test
-                           completionHandler:^{ asset_keys_loaded_cb.Run(); }];
-}
-
-void AVFMediaDecoder::Seek(const base::TimeDelta& time,
-                           const ResultCB& result_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  TRACE_EVENT_ASYNC_BEGIN0("IPC_MEDIA", "AVFMediaDecoder::Seek", this);
-  DVLOG(1) << "Seeking to " << time.InMicroseconds() << " per pipeline request";
-
-  if (seeking_) {
-    DCHECK(seek_on_seek_done_task_.is_null());
-    DVLOG(1) << "Auto-seeking now, postponing pipeline seek request";
-    seek_on_seek_done_task_ = base::Bind(&AVFMediaDecoder::Seek,
-                                         weak_ptr_factory_.GetWeakPtr(),
-                                         time,
-                                         result_cb);
-    return;
-  }
-
-  ScheduleSeekTask(base::Bind(&AVFMediaDecoder::SeekTask,
-                              weak_ptr_factory_.GetWeakPtr(),
-                              time,
-                              result_cb));
-}
-
-void AVFMediaDecoder::NotifyStreamCapacityDepleted() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DVLOG(5) << __FUNCTION__;
-
-  // We were notified by _a_ stream.  Other streams may still have some
-  // capacity available.
-  if (client_->HasAvailableCapacity())
-    return;
-
-  if (playback_state_ != PLAYING)
-    return;
-
-  if (seeking_) {
-    DVLOG(3) << "Ignoring stream capacity depletion while seeking";
-    return;
-  }
-
-  DVLOG(1) << "PAUSING AVPlayer";
-  playback_state_ = STOPPING;
-  [player_ pause];
-}
-
-void AVFMediaDecoder::NotifyStreamCapacityAvailable() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DVLOG(5) << __FUNCTION__;
-
-  PlayWhenReady("stream capacity available");
-}
-
-base::TimeDelta AVFMediaDecoder::start_time() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  return media::GetStartTimeFromTrack(has_audio_track() ? AudioTrack()
-                                                        : VideoTrack());
-}
-
-void AVFMediaDecoder::AssetKeysLoaded(const ResultCB& initialize_cb,
-                                      base::scoped_nsobject<AVAsset> asset,
-                                      base::scoped_nsobject<NSArray> keys) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  // First test whether the values of each of the keys we need have been
-  // successfully loaded.
-  for (NSString* key in keys.get()) {
-    NSError* error = nil;
-    if ([asset statusOfValueForKey:key error:&error] !=
-        AVKeyValueStatusLoaded) {
-      DVLOG(1) << "Can't access asset key: " << [key UTF8String];
-      initialize_cb.Run(false);
-      return;
-    }
-  }
-
-  if (![asset isPlayable]) {
-    DVLOG(1) << "Asset is not playable";
-    initialize_cb.Run(false);
-    return;
-  }
-
-  if ([asset hasProtectedContent]) {
-    DVLOG(1) << "Asset has protected content";
-    initialize_cb.Run(false);
-    return;
-  }
-
-  // We can play this asset.
-
-  AVPlayerItem* player_item =
-      [AVFoundationGlue::AVPlayerItemClass() playerItemWithAsset:asset];
-  player_.reset([[AVFoundationGlue::AVPlayerClass() alloc]
-      initWithPlayerItem:player_item]);
-
-  const PlayerObserverCallback status_known_cb =
-      media::BindToCurrentLoop(base::Bind(&AVFMediaDecoder::PlayerStatusKnown,
-                                          weak_ptr_factory_.GetWeakPtr(),
-                                          initialize_cb));
-
-  if ([player_ status] == AVPlayerStatusReadyToPlay) {
-    status_known_cb.Run(
-        base::scoped_nsobject<id>([@(AVPlayerStatusReadyToPlay) retain]));
-  } else {
-    DCHECK([player_ status] == AVPlayerStatusUnknown);
-
-    status_observer_.reset(
-        [[PlayerObserver alloc] initForKeyPath:@"status"
-                                  withCallback:status_known_cb]);
-
-    [player_ addObserver:status_observer_
-              forKeyPath:[status_observer_ keyPath]
-                 options:0
-                 context:nil];
-  }
-}
-
-void AVFMediaDecoder::PlayerStatusKnown(
-    const ResultCB& initialize_cb,
-    base::scoped_nsobject<id> /* status */) {
-  DVLOG(1) << "Player status: " << [player_ status];
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if ([player_ status] != AVPlayerStatusReadyToPlay) {
-    DVLOG(1) << "Player status changed to not playable";
-    initialize_cb.Run(false);
-    return;
-  }
-
-  if (!has_video_track() && !has_audio_track()) {
-    DVLOG(1) << "No tracks to play";
-    initialize_cb.Run(false);
-    return;
-  }
-
-  if (!CalculateBitrate()) {
-    DVLOG(1) << "Bitrate unavailable";
-    initialize_cb.Run(false);
-    return;
-  }
-
-  // AVPlayer is ready to play.
-
-  duration_ =
-      media::CMTimeToTimeDelta([[[player_ currentItem] asset] duration]);
-
-  const PlayerObserverCallback rate_cb = media::BindToCurrentLoop(base::Bind(
-      &AVFMediaDecoder::PlayerRateChanged, weak_ptr_factory_.GetWeakPtr()));
-  rate_observer_.reset(
-      [[PlayerObserver alloc] initForKeyPath:@"rate" withCallback:rate_cb]);
-
-  [player_ addObserver:rate_observer_
-            forKeyPath:[rate_observer_ keyPath]
-               options:NSKeyValueObservingOptionNew
-               context:nil];
-
-  const base::Closure finish_cb =
-      media::BindToCurrentLoop(base::Bind(&AVFMediaDecoder::PlayerPlayedToEnd,
-                                          weak_ptr_factory_.GetWeakPtr(),
-                                          "notification"));
-  played_to_end_observer_.reset(
-      [[PlayerNotificationObserver alloc] initWithCallback:finish_cb]);
-
-  [[NSNotificationCenter defaultCenter]
-      addObserver:played_to_end_observer_
-         selector:@selector(observe:)
-             name:AVFoundationGlue::AVPlayerItemDidPlayToEndTimeNotification()
-           object:[player_ currentItem]];
-  [[NSNotificationCenter defaultCenter]
-      addObserver:played_to_end_observer_
-         selector:@selector(observe:)
-             name:AVFoundationGlue::AVPlayerItemFailedToPlayToEndTimeNotification()
-           object:[player_ currentItem]];
-
-  const PlayerObserverCallback time_ranges_changed_cb =
-      media::BindToCurrentLoop(
-          base::Bind(&AVFMediaDecoder::PlayerItemTimeRangesChanged,
-                     weak_ptr_factory_.GetWeakPtr()));
-  player_item_loaded_times_observer_.reset(
-      [[PlayerObserver alloc] initForKeyPath:@"loadedTimeRanges"
-                                withCallback:time_ranges_changed_cb]);
-
-  [[player_ currentItem]
-      addObserver:player_item_loaded_times_observer_
-       forKeyPath:[player_item_loaded_times_observer_ keyPath]
-          options:NSKeyValueObservingOptionNew
-          context:nil];
-
-  InitializeAudioOutput(initialize_cb);
-}
-
-bool AVFMediaDecoder::CalculateBitrate() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  const float bitrate =
-      [AudioTrack() estimatedDataRate] + [VideoTrack() estimatedDataRate];
-  if (std::isnan(bitrate) ||
-      !base::IsValueInRangeForNumericType<decltype(bitrate_)>(bitrate))
-    return false;
-
-  bitrate_ = bitrate;
-  return true;
-}
-
-void AVFMediaDecoder::PlayerItemTimeRangesChanged(
-    base::scoped_nsobject<id> new_ranges) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  base::scoped_nsobject<NSArray> new_ranges_value(
-      [base::mac::ObjCCastStrict<NSArray>(new_ranges.get()) retain]);
-
-  const bool likely_to_stall = IsPlayerLikelyToStallWithRanges(
-      [player_ currentItem], new_ranges_value, min_loaded_range_size_);
-
-  if (!pending_seek_task_.is_null())
-    SeekIfNotLikelyToStall(likely_to_stall);
-  else
-    PlayIfNotLikelyToStall("has enough data", likely_to_stall);
-}
-
-void AVFMediaDecoder::PlayerRateChanged(base::scoped_nsobject<id> new_rate) {
-  const int new_rate_value =
-      [base::mac::ObjCCastStrict<NSNumber>(new_rate.get()) intValue];
-  DVLOG(3) << __FUNCTION__ << ": " << new_rate_value;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (new_rate_value > 0) {
-    DVLOG(1) << "AVPlayer started PLAYING";
-    DCHECK_EQ(playback_state_, STARTING);
-    playback_state_ = PLAYING;
-    return;
-  }
-
-  if (playback_state_ != STOPPING) {
-    // AVPlayer stopped spontaneously.  This happens when it can't load data
-    // fast enough.  Let's try to give it more chance of playing smoothly by
-    // increasing the required amount of data loaded before resuming playback.
-    min_loaded_range_size_ =
-        std::min(min_loaded_range_size_ * 2, kMaxRequiredLoadedTimeRange);
-  }
-
-  playback_state_ = STOPPED;
-
-  const base::TimeDelta current_time =
-      media::CMTimeToTimeDelta([player_ currentTime]);
-  DVLOG(1) << "AVPlayer was PAUSED @" << current_time.InMicroseconds();
-
-  if (last_audio_timestamp_ >= duration_) {
-    PlayerPlayedToEnd("pause");
-  } else if (!seeking_ && last_audio_timestamp_ != media::kNoTimestamp()) {
-    TRACE_EVENT_ASYNC_BEGIN0("IPC_MEDIA", "AVFMediaDecoder::Auto-seek", this);
-
-    DCHECK(has_audio_track());
-
-    // AVFMediaDecoder receives audio ahead of [player_ currentTime].  In order
-    // to preserve audio signal continuity when |player_| resumes playing, we
-    // have to seek forwards to the last audio timestamp we got, see
-    // |AutoSeekTask()|.
-    ScheduleSeekTask(base::Bind(&AVFMediaDecoder::AutoSeekTask,
-                                weak_ptr_factory_.GetWeakPtr()));
-  }
-
-  if (!play_on_pause_done_task_.is_null()) {
-    play_on_pause_done_task_.Run();
-    play_on_pause_done_task_.Reset();
-  }
-}
-
-void AVFMediaDecoder::PlayWhenReady(base::StringPiece reason) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (!client_->HasAvailableCapacity())
-    return;
-
-  if (playback_state_ == PLAYING || playback_state_ == STARTING) {
-    DVLOG(7) << "Giving up on playing AVPlayer when '" << reason
-             << ", because already playing/starting to play";
-    return;
-  }
-
-  if (stream_has_ended_) {
-    DVLOG(3) << "Giving up on playing AVPlayer when '" << reason
-             << "', because the stream has ended";
-    return;
-  }
-
-  base::PostTaskAndReplyWithResult(
-      background_runner().get(),
-      FROM_HERE,
-      base::Bind(&IsPlayerLikelyToStall,
-                 background_tasks_canceled_,
-                 [player_ currentItem],
-                 min_loaded_range_size_),
-      base::Bind(&AVFMediaDecoder::PlayIfNotLikelyToStall,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 reason));
-}
-
-void AVFMediaDecoder::PlayIfNotLikelyToStall(base::StringPiece reason,
-                                             bool likely_to_stall) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (!client_->HasAvailableCapacity())
-    return;
-
-  if (playback_state_ == PLAYING || playback_state_ == STARTING) {
-    DVLOG(7) << "Giving up on playing AVPlayer when '" << reason
-             << "', because already playing/starting to play";
-    return;
-  }
-
-  if (stream_has_ended_) {
-    DVLOG(3) << " Giving up on playing AVPlayer when '" << reason
-             << "', because the stream has ended";
-    return;
-  }
-
-  if (likely_to_stall) {
-    DVLOG(3) << "Giving up on playing AVPlayer when '" << reason
-             << "', because the player is likely to stall";
-    return;
-  }
-
-  // In the following two cases the client might require a new buffer before it
-  // emits another such notification, and we can't provide a new buffer until
-  // we play our AVPlayer again.  Thus, instead of just ignoring this
-  // notification, postpone it.
-  const base::Closure play_task = base::Bind(
-      &AVFMediaDecoder::PlayWhenReady, weak_ptr_factory_.GetWeakPtr(), reason);
-  if (seeking_) {
-    DVLOG(3) << "Temporarily ignoring '" << reason
-             << "' notification while seeking";
-    play_on_seek_done_task_ = play_task;
-    return;
-  }
-  if (playback_state_ == STOPPING) {
-    DVLOG(3) << "Temporarily ignoring '" << reason
-             << "' notification while pausing";
-    play_on_pause_done_task_ = play_task;
-    return;
-  }
-
-  DVLOG(1) << "PLAYING AVPlayer because " << reason;
-  DCHECK_EQ(playback_state_, STOPPED);
-  playback_state_ = STARTING;
-  [player_ play];
-}
-
-void AVFMediaDecoder::SeekIfNotLikelyToStall(bool likely_to_stall) {
-  DVLOG(1) << __FUNCTION__ << '(' << likely_to_stall << ')';
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (likely_to_stall)
-    return;
-
-  // If |PlayerItemTimeRangesChanged()| is called while seek task is scheduled
-  // but not finished yet, then pending_seek_task_ might be consumed already
-  // and might be null here.
-  if (!pending_seek_task_.is_null()) {
-    pending_seek_task_.Run();
-    pending_seek_task_.Reset();
-  }
-}
-
-void AVFMediaDecoder::ScheduleSeekTask(const base::Closure& seek_task) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(!seeking_);
-  DCHECK(pending_seek_task_.is_null());
-
-  // We must not request a seek if AVPlayer's internal buffers are drained.
-  // Sometimes, AVPlayer never finishes the seek if the seek is started in such
-  // a state.
-
-  seeking_ = true;
-  pending_seek_task_ = seek_task;
-
-  base::PostTaskAndReplyWithResult(
-      background_runner().get(),
-      FROM_HERE,
-      base::Bind(&IsPlayerLikelyToStall,
-                 background_tasks_canceled_,
-                 [player_ currentItem],
-                 min_loaded_range_size_),
-      base::Bind(&AVFMediaDecoder::SeekIfNotLikelyToStall,
-                 weak_ptr_factory_.GetWeakPtr()));
-}
-
-void AVFMediaDecoder::SeekTask(const base::TimeDelta& time,
-                               const ResultCB& result_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  const scoped_refptr<base::TaskRunner> runner = background_runner();
-
-  const base::Closure set_audio_mix_task =
-      has_audio_track()
-          // The audio mix will have to be reset to preserve A/V
-          // synchronization.
-          ? base::Bind(&SetAudioMix,
-                       background_tasks_canceled_,
-                       [player_ currentItem],
-                       audio_tap_->GetAudioMix())
-          : base::Closure();
-
-  const base::Callback<void(bool)> seek_done_cb = media::BindToCurrentLoop(
-      base::Bind(&AVFMediaDecoder::SeekDone,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 result_cb));
-
-  [player_ seekToTime:media::TimeDeltaToCMTime(time)
-        toleranceBefore:media::CoreMediaGlueCMTimeToCMTime(
-                            CoreMediaGlue::kCMTimeZero)
-         toleranceAfter:media::CoreMediaGlueCMTimeToCMTime(
-                            CoreMediaGlue::kCMTimeZero)
-      completionHandler:^(BOOL finished) {
-        DVLOG(1) << (finished ? "Seek DONE" : "Seek was interrupted/rejected");
-        if (finished && !set_audio_mix_task.is_null()) {
-          runner->PostTaskAndReply(FROM_HERE, set_audio_mix_task,
-                                   base::Bind(seek_done_cb, true));
-        } else {
-          seek_done_cb.Run(finished);
-        }
-      }];
-}
-
-void AVFMediaDecoder::AutoSeekTask() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK_EQ(playback_state_, STOPPED);
-
-  DVLOG(1) << "Auto-seeking to " << last_audio_timestamp_.InMicroseconds();
-
-  const scoped_refptr<base::TaskRunner> runner = background_runner();
-
-  // The audio mix will have to be reset to prevent a "phase shift" in the
-  // series of audio buffers.  The rendering end of the Chrome pipeline
-  // treats such shifts as errors.
-  const base::Closure set_audio_mix_task =
-      base::Bind(&SetAudioMix,
-                 background_tasks_canceled_,
-                 [player_ currentItem],
-                 audio_tap_->GetAudioMix());
-
-  const base::Closure auto_seek_done_cb = media::BindToCurrentLoop(base::Bind(
-      &AVFMediaDecoder::AutoSeekDone, weak_ptr_factory_.GetWeakPtr()));
-
-  [player_ seekToTime:media::TimeDeltaToCMTime(last_audio_timestamp_)
-        toleranceBefore:media::CoreMediaGlueCMTimeToCMTime(
-                            CoreMediaGlue::kCMTimeZero)
-         toleranceAfter:media::CoreMediaGlueCMTimeToCMTime(
-                            CoreMediaGlue::kCMTimeZero)
-      completionHandler:^(BOOL finished) {
-        DVLOG(1) << (finished ? "Auto-seek DONE"
-                              : "Auto-seek was interrupted/rejected");
-        // Need to set a new audio mix whether the auto-seek was successful
-        // or not.  We will most likely continue decoding.
-        runner->PostTaskAndReply(FROM_HERE, set_audio_mix_task,
-                                 auto_seek_done_cb);
-      }];
-}
-
-void AVFMediaDecoder::InitializeAudioOutput(const ResultCB& initialize_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(player_ != NULL);
-
-  AVAssetTrack* audio_track = AudioTrack();
-
-  // If AVPlayer detects video track but no audio track (or audio format is not
-  // supported) we proceed with video initialization, to show at least
-  // audio-less video.
-  if (audio_track == NULL) {
-    DVLOG(1) << "Playing video only";
-    DCHECK(has_video_track());
-    AudioFormatKnown(initialize_cb, audio_stream_format_);
-    return;
-  }
-
-  // Otherwise, we create an audio processing tap and wait for it to provide
-  // the audio stream format (AudioFormatKnown()).
-  DCHECK(audio_track != NULL);
-
-  // First, though, make sure AVPlayer doesn't emit any sound on its own
-  // (DNA-28672).  The only sound we want is the one played by Chrome from the
-  // samples obtained through the audio processing tap.
-  [player_ setVolume:0.0];
-
-  audio_tap_.reset(
-      new AVFAudioTap(audio_track,
-                      base::MessageLoop::current()->task_runner(),
-                      base::Bind(&AVFMediaDecoder::AudioFormatKnown,
-                                 weak_ptr_factory_.GetWeakPtr(),
-                                 initialize_cb),
-                      base::Bind(&AVFMediaDecoder::AudioSamplesReady,
-                                 weak_ptr_factory_.GetWeakPtr())));
-
-  base::scoped_nsobject<AVAudioMix> audio_mix = audio_tap_->GetAudioMix();
-  if (audio_mix.get() == nil) {
-    DVLOG(1) << "Could not create AVAudioMix with audio processing tap";
-    initialize_cb.Run(false);
-    return;
-  }
-
-  [[player_ currentItem] setAudioMix:audio_mix];
-}
-
-void AVFMediaDecoder::AudioFormatKnown(
-    const ResultCB& initialize_cb,
-    const AudioStreamBasicDescription& format) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(!is_audio_format_known());
-  DCHECK(player_ != NULL);
-
-  audio_stream_format_ = format;
-
-  // The audio output is now fully initialized, proceed to initialize the video
-  // output.
-
-  if (has_video_track()) {
-    if (!InitializeVideoOutput()) {
-      initialize_cb.Run(false);
-      return;
-    }
-  }
-
-  DVLOG(1) << "PLAYING AVPlayer";
-  playback_state_ = STARTING;
-  [player_ play];
-
-  initialize_cb.Run(true);
-}
-
-void AVFMediaDecoder::AudioSamplesReady(
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (seeking_ || stream_has_ended_) {
-    DVLOG(3) << "Ignoring audio samples: " << (seeking_ ? "seeking"
-                                                        : "stream has ended");
-    return;
-  }
-
-  if (last_audio_timestamp_ != media::kNoTimestamp() &&
-      buffer->timestamp() <= last_audio_timestamp_) {
-    DVLOG(1) << "Audio buffer @" << buffer->timestamp().InMicroseconds()
-             << " older than last buffer @"
-             << last_audio_timestamp_.InMicroseconds() << ", dropping";
-    return;
-  }
-
-  last_audio_timestamp_ = buffer->timestamp();
-
-  client_->AudioSamplesReady(buffer);
-}
-
-bool AVFMediaDecoder::InitializeVideoOutput() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(has_video_track());
-
-  if (VideoFrameRate() <= 0.0)
-    return false;
-
-  DCHECK_EQ([[VideoTrack() formatDescriptions] count], 1u);
-  video_stream_format_ = reinterpret_cast<CMFormatDescriptionRef>(
-      [[VideoTrack() formatDescriptions] objectAtIndex:0]);
-
-  const CoreMediaGlue::CMVideoDimensions coded_size =
-      CoreMediaGlue::CMVideoFormatDescriptionGetDimensions(
-          video_stream_format());
-  video_coded_size_ = gfx::Size(coded_size.width, coded_size.height);
-
-  NSDictionary* output_settings = @{
-    base::mac::CFToNSCast(kCVPixelBufferPixelFormatTypeKey) :
-        @(kCVPixelFormatType_420YpCbCr8Planar)
-  };
-  video_output_.reset([[AVFoundationGlue::AVPlayerItemVideoOutputClass() alloc]
-      initWithPixelBufferAttributes:output_settings]);
-
-  [[player_ currentItem] addOutput:video_output_];
-
-  const base::Callback<void(const CMTime&)> periodic_cb =
-      media::BindToCurrentLoop(base::Bind(&AVFMediaDecoder::ReadFromVideoOutput,
-                                          weak_ptr_factory_.GetWeakPtr()));
-
-  CoreMediaGlue::CMTime interval =
-      CoreMediaGlue::CMTimeMake(1, VideoFrameRate());
-  id handle = [player_
-      addPeriodicTimeObserverForInterval:media::CoreMediaGlueCMTimeToCMTime(
-                                             interval)
-                                   queue:nil
-                              usingBlock:^(CMTime time) {
-                                periodic_cb.Run(time);
-                              }];
-  DCHECK(time_observer_handle_.get() == nil);
-  time_observer_handle_.reset([handle retain]);
-
-  return true;
-}
-
-void AVFMediaDecoder::ReadFromVideoOutput(const CMTime& cm_timestamp) {
-  DVLOG(3) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (seeking_ || playback_state_ != PLAYING || stream_has_ended_) {
-    DVLOG(3) << "Not reading video output: "
-             << (seeking_ ? "seeking" : playback_state_ != PLAYING
-                                            ? "not playing"
-                                            : "stream has ended");
-    return;
-  }
-
-  const base::TimeDelta timestamp = media::CMTimeToTimeDelta(cm_timestamp);
-
-  if (last_video_timestamp_ != media::kNoTimestamp() &&
-      timestamp <= last_video_timestamp_) {
-    DVLOG(1) << "Video buffer @" << timestamp.InMicroseconds()
-             << " older than last buffer @"
-             << last_video_timestamp_.InMicroseconds() << ", dropping";
-    return;
-  }
-
-  const scoped_refptr<media::DataBuffer> buffer =
-      GetVideoFrame(video_output_, cm_timestamp, video_coded_size_);
-  if (buffer.get() == NULL) {
-    if (timestamp >= duration_)
-      PlayerPlayedToEnd("video output");
-    return;
-  }
-
-  last_video_timestamp_ = buffer->timestamp();
-
-  client_->VideoFrameReady(buffer);
-}
-
-void AVFMediaDecoder::AutoSeekDone() {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  seeking_ = false;
-
-  RunTasksPendingSeekDone();
-
-  TRACE_EVENT_ASYNC_END0("IPC_MEDIA", "AVFMediaDecoder::Auto-seek", this);
-}
-
-void AVFMediaDecoder::SeekDone(const ResultCB& result_cb, bool finished) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  seeking_ = false;
-  stream_has_ended_ = false;
-
-  last_audio_timestamp_ = media::kNoTimestamp();
-  last_video_timestamp_ = media::kNoTimestamp();
-
-  result_cb.Run(finished);
-
-  RunTasksPendingSeekDone();
-
-  TRACE_EVENT_ASYNC_END0("IPC_MEDIA", "AVFMediaDecoder::Seek", this);
-}
-
-void AVFMediaDecoder::RunTasksPendingSeekDone() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (!seek_on_seek_done_task_.is_null()) {
-    seek_on_seek_done_task_.Run();
-    seek_on_seek_done_task_.Reset();
-  }
-
-  if (!play_on_seek_done_task_.is_null()) {
-    play_on_seek_done_task_.Run();
-    play_on_seek_done_task_.Reset();
-  }
-}
-
-void AVFMediaDecoder::PlayerPlayedToEnd(base::StringPiece source) {
-  DVLOG(1) << __FUNCTION__ << '(' << source << ')';
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (stream_has_ended_)
-    return;
-
-  stream_has_ended_ = true;
-
-  // Typically, we receive the |PlayerRateChanged()| callback for a paused
-  // AVPlayer right before we receive this callback.  Let's cancel the seek we
-  // may have started there.
-  [[player_ currentItem] cancelPendingSeeks];
-
-  client_->StreamHasEnded();
-}
-
-AVAssetTrack* AVFMediaDecoder::AssetTrackForType(
-    NSString* track_type_name) const {
-  NSArray* tracks =
-      [[[player_ currentItem] asset] tracksWithMediaType:track_type_name];
-  return [tracks count] > 0u ? [tracks objectAtIndex:0] : nil;
-}
-
-AVAssetTrack* AVFMediaDecoder::VideoTrack() const {
-  return AssetTrackForType(AVFoundationGlue::AVMediaTypeVideo());
-}
-
-AVAssetTrack* AVFMediaDecoder::AudioTrack() const {
-  return AssetTrackForType(AVFoundationGlue::AVMediaTypeAudio());
-}
-
-double AVFMediaDecoder::VideoFrameRate() const {
-  return [VideoTrack() nominalFrameRate];
-}
-
-scoped_refptr<base::TaskRunner> AVFMediaDecoder::background_runner() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return g_background_thread.Get().task_runner();
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/avf_media_pipeline.h b/content/common/gpu/media/avf_media_pipeline.h
deleted file mode 100644
index 3616f16..0000000
--- a/content/common/gpu/media/avf_media_pipeline.h
+++ /dev/null
@@ -1,67 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_PIPELINE_H_
-#define CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_PIPELINE_H_
-
-#include <string>
-
-#include "base/memory/scoped_ptr.h"
-#include "base/memory/weak_ptr.h"
-#include "base/threading/thread_checker.h"
-#include "content/common/gpu/media/platform_media_pipeline.h"
-
-namespace content {
-
-class AVFDataBufferQueue;
-class AVFMediaDecoder;
-
-class AVFMediaPipeline : public PlatformMediaPipeline {
- public:
-  explicit AVFMediaPipeline(IPCDataSource* data_source_);
-  ~AVFMediaPipeline() override;
-
-  // PlatformMediaPipeline implementation.
-  void Initialize(const std::string& mime_type,
-                  const InitializeCB& initialize_cb) override;
-  void ReadAudioData(const ReadDataCB& read_audio_data_cb) override;
-  void ReadVideoData(const ReadDataCB& read_video_data_cb,
-                     uint32_t /* texture_id */) override;
-  void WillSeek() override {}
-  void Seek(base::TimeDelta time, const SeekCB& seek_cb) override;
-
- private:
-  class MediaDecoderClient;
-  friend class MediaDecoderClient;
-
-  void MediaDecoderInitialized(const InitializeCB& initialize_cb, bool success);
-
-  void DataBufferCapacityAvailable();
-  void DataBufferCapacityDepleted();
-
-  void AudioBufferReady(const ReadDataCB& read_audio_data_cb,
-                        const scoped_refptr<media::DataBuffer>& buffer);
-  void VideoBufferReady(const ReadDataCB& read_video_data_cb,
-                        const scoped_refptr<media::DataBuffer>& buffer);
-
-  void SeekDone(const SeekCB& seek_cb, bool success);
-
-  scoped_ptr<MediaDecoderClient> media_decoder_client_;
-  scoped_ptr<AVFMediaDecoder> media_decoder_;
-
-  scoped_ptr<AVFDataBufferQueue> audio_queue_;
-  scoped_ptr<AVFDataBufferQueue> video_queue_;
-
-  IPCDataSource* data_source_;
-
-  base::ThreadChecker thread_checker_;
-  base::WeakPtrFactory<AVFMediaPipeline> weak_ptr_factory_;
-};
-
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_PIPELINE_H_
diff --git a/content/common/gpu/media/avf_media_pipeline.mm b/content/common/gpu/media/avf_media_pipeline.mm
deleted file mode 100644
index 56527f1..0000000
--- a/content/common/gpu/media/avf_media_pipeline.mm
+++ /dev/null
@@ -1,263 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/avf_media_pipeline.h"
-
-#include "base/bind.h"
-#include "base/time/time.h"
-#include "base/trace_event/trace_event.h"
-#include "content/common/gpu/media/avf_data_buffer_queue.h"
-#include "content/common/gpu/media/avf_media_decoder.h"
-#include "media/base/data_buffer.h"
-#include "media/base/video_frame.h"
-#include "media/filters/platform_media_pipeline_types.h"
-#include "media/filters/platform_media_pipeline_types_mac.h"
-
-namespace content {
-
-class AVFMediaPipeline::MediaDecoderClient : public AVFMediaDecoderClient {
- public:
-  explicit MediaDecoderClient(AVFMediaPipeline* avf_media_pipeline)
-      : avf_media_pipeline_(avf_media_pipeline) {
-    DCHECK(avf_media_pipeline_ != NULL);
-  }
-
-  void AudioSamplesReady(
-      const scoped_refptr<media::DataBuffer>& buffer) override {
-    HandleNewBuffer(buffer, avf_media_pipeline_->audio_queue_.get());
-  }
-  void VideoFrameReady(
-      const scoped_refptr<media::DataBuffer>& buffer) override {
-    HandleNewBuffer(buffer, avf_media_pipeline_->video_queue_.get());
-  }
-
-  void StreamHasEnded() override {
-    if (avf_media_pipeline_->audio_queue_.get() != NULL)
-      avf_media_pipeline_->audio_queue_->SetEndOfStream();
-
-    if (avf_media_pipeline_->video_queue_.get() != NULL)
-      avf_media_pipeline_->video_queue_->SetEndOfStream();
-  }
-
-  bool HasAvailableCapacity() override {
-    if (IsMemoryLimitReached())
-      return false;
-
-    if (avf_media_pipeline_->audio_queue_.get() != NULL &&
-        avf_media_pipeline_->audio_queue_->HasAvailableCapacity())
-      return true;
-
-    if (avf_media_pipeline_->video_queue_.get() != NULL &&
-        avf_media_pipeline_->video_queue_->HasAvailableCapacity())
-      return true;
-
-    return false;
-  }
-
- private:
-  void HandleNewBuffer(const scoped_refptr<media::DataBuffer>& buffer,
-                       AVFDataBufferQueue* queue) {
-    DCHECK(buffer.get() != NULL);
-    DCHECK(queue != NULL);
-
-    queue->BufferReady(buffer);
-
-    if (IsMemoryLimitReached())
-      avf_media_pipeline_->DataBufferCapacityDepleted();
-  }
-
-  bool IsMemoryLimitReached() {
-    // Maximum memory usage allowed for the whole pipeline.  Choosing the same
-    // value FFmpegDemuxer is using, for lack of a better heuristic.
-    const size_t kPipelineMemoryLimit = 150 * 1024 * 1024;
-
-    size_t memory_left = kPipelineMemoryLimit;
-
-    AVFDataBufferQueue* const queues[] = {
-        avf_media_pipeline_->audio_queue_.get(),
-        avf_media_pipeline_->video_queue_.get(),
-    };
-
-    for (size_t i = 0; i < arraysize(queues); ++i) {
-      if (queues[i] == NULL)
-        continue;
-
-      if (queues[i]->memory_usage() > memory_left) {
-        DVLOG(1) << "Memory limit reached";
-        return true;
-      }
-
-      memory_left -= queues[i]->memory_usage();
-    }
-
-    return false;
-  }
-
-  AVFMediaPipeline* const avf_media_pipeline_;
-};
-
-AVFMediaPipeline::AVFMediaPipeline(IPCDataSource* data_source)
-    : data_source_(data_source), weak_ptr_factory_(this) {
-  DCHECK(data_source_ != NULL);
-}
-
-AVFMediaPipeline::~AVFMediaPipeline() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DVLOG(3) << "~AVFMediaPipeline()";
-}
-
-void AVFMediaPipeline::Initialize(const std::string& mime_type,
-                                  const InitializeCB& initialize_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  TRACE_EVENT_ASYNC_BEGIN0("IPC_MEDIA", "AVFMediaPipeline::Initialize", this);
-  media_decoder_client_.reset(new MediaDecoderClient(this));
-  media_decoder_.reset(new AVFMediaDecoder(media_decoder_client_.get()));
-  media_decoder_->Initialize(
-      data_source_,
-      mime_type,
-      base::Bind(&AVFMediaPipeline::MediaDecoderInitialized,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 initialize_cb));
-}
-
-void AVFMediaPipeline::ReadAudioData(const ReadDataCB& read_audio_data_cb) {
-  DVLOG(5) << "Renderer asking for audio data";
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(audio_queue_.get() != NULL);
-
-  audio_queue_->Read(base::Bind(&AVFMediaPipeline::AudioBufferReady,
-                                weak_ptr_factory_.GetWeakPtr(),
-                                read_audio_data_cb));
-}
-
-void AVFMediaPipeline::ReadVideoData(const ReadDataCB& read_video_data_cb,
-                                     uint32_t /* texture_id */) {
-  DVLOG(5) << "Renderer asking for video data";
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(video_queue_.get() != NULL);
-
-  video_queue_->Read(base::Bind(&AVFMediaPipeline::VideoBufferReady,
-                                weak_ptr_factory_.GetWeakPtr(),
-                                read_video_data_cb));
-}
-
-void AVFMediaPipeline::Seek(base::TimeDelta time, const SeekCB& seek_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  media_decoder_->Seek(time,
-                       base::Bind(&AVFMediaPipeline::SeekDone,
-                                  weak_ptr_factory_.GetWeakPtr(),
-                                  seek_cb));
-}
-
-void AVFMediaPipeline::SeekDone(const SeekCB& seek_cb, bool success) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (audio_queue_.get() != NULL)
-    audio_queue_->Flush();
-  if (video_queue_.get() != NULL)
-    video_queue_->Flush();
-
-  seek_cb.Run(success);
-}
-
-void AVFMediaPipeline::AudioBufferReady(
-    const ReadDataCB& read_audio_data_cb,
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  DVLOG(5) << "Ready to reply to renderer with decoded audio";
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(buffer.get() != NULL);
-
-  read_audio_data_cb.Run(buffer);
-}
-
-void AVFMediaPipeline::VideoBufferReady(
-    const ReadDataCB& read_video_data_cb,
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  DVLOG(5) << "Ready to reply to renderer with decoded video";
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(buffer.get() != NULL);
-
-  read_video_data_cb.Run(buffer);
-}
-
-void AVFMediaPipeline::MediaDecoderInitialized(
-    const InitializeCB& initialize_cb,
-    bool success) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DVLOG(3) << "MediaDecoderInitialized(" << success << ")";
-
-  TRACE_EVENT_ASYNC_END0("IPC_MEDIA", "AVFMediaPipeline::Initialize", this);
-
-  if (!success) {
-    initialize_cb.Run(false,
-                      -1,
-                      media::PlatformMediaTimeInfo(),
-                      media::PlatformAudioConfig(),
-                      media::PlatformVideoConfig());
-    return;
-  }
-
-  const base::Closure capacity_available_cb =
-      base::Bind(&AVFMediaPipeline::DataBufferCapacityAvailable,
-                 weak_ptr_factory_.GetWeakPtr());
-  const base::Closure capacity_depleted_cb =
-      base::Bind(&AVFMediaPipeline::DataBufferCapacityDepleted,
-                 weak_ptr_factory_.GetWeakPtr());
-
-  if (media_decoder_->has_video_track()) {
-    video_queue_.reset(
-        new AVFDataBufferQueue(AVFDataBufferQueue::VIDEO,
-                               // >=3 frames for fps <= 25
-                               base::TimeDelta::FromMilliseconds(120),
-                               capacity_available_cb, capacity_depleted_cb));
-  }
-  if (media_decoder_->has_audio_track()) {
-    audio_queue_.reset(
-        new AVFDataBufferQueue(AVFDataBufferQueue::AUDIO,
-                               // AVFMediaDecoder decodes audio ahead of video.
-                               base::TimeDelta::FromMilliseconds(200),
-                               capacity_available_cb, capacity_depleted_cb));
-  }
-
-  media::PlatformAudioConfig audio_config;
-  if (media_decoder_->has_audio_track()) {
-    audio_config.format = media::kSampleFormatPlanarF32;
-    audio_config.channel_count =
-        media_decoder_->audio_stream_format().mChannelsPerFrame;
-    audio_config.samples_per_second =
-        media_decoder_->audio_stream_format().mSampleRate;
-  }
-
-  media::PlatformVideoConfig video_config;
-  if (media_decoder_->has_video_track()) {
-    video_config = media::GetPlatformVideoConfig(
-        media_decoder_->video_stream_format(),
-        media_decoder_->video_transform());
-  }
-
-  media::PlatformMediaTimeInfo time_info;
-  time_info.duration = media_decoder_->duration();
-  time_info.start_time = media_decoder_->start_time();
-
-  initialize_cb.Run(true, media_decoder_->bitrate(), time_info, audio_config,
-                    video_config);
-}
-
-void AVFMediaPipeline::DataBufferCapacityAvailable() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  media_decoder_->NotifyStreamCapacityAvailable();
-}
-
-void AVFMediaPipeline::DataBufferCapacityDepleted() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  media_decoder_->NotifyStreamCapacityDepleted();
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/avf_media_reader.h b/content/common/gpu/media/avf_media_reader.h
deleted file mode 100644
index acc0f28..0000000
--- a/content/common/gpu/media/avf_media_reader.h
+++ /dev/null
@@ -1,104 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_READER_H_
-#define CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_READER_H_
-
-#import <AVFoundation/AVFoundation.h>
-
-#include <string>
-
-#include "base/mac/scoped_nsobject.h"
-#include "base/time/time.h"
-#include "media/base/data_buffer.h"
-#include "media/filters/platform_media_pipeline_types.h"
-#include "ui/gfx/geometry/size.h"
-
-@class DataSourceLoader;
-
-namespace content {
-
-class IPCDataSource;
-
-// Wraps AVAssetReader and uses it to perform media decoding tasks.
-//
-// AVFMediaReader takes raw media data as input and outputs decoded audio and
-// video data, handling both the demuxing and decoding internally.  Input data
-// is provided via an IPCDataSource.
-class AVFMediaReader {
- public:
-  // Once AVFMediaReader has been constructed, all functions must run on the
-  // |queue| passed to the constructor.
-  explicit AVFMediaReader(dispatch_queue_t queue);
-  ~AVFMediaReader();
-
-  bool Initialize(IPCDataSource* data_source, const std::string& mime_type);
-
-  int bitrate() const;
-  base::TimeDelta duration() const;
-  base::TimeDelta start_time() const;
-
-  bool has_audio_track() const {
-    return GetTrack(media::PLATFORM_MEDIA_AUDIO) != nil;
-  }
-  bool has_video_track() const {
-    return GetTrack(media::PLATFORM_MEDIA_VIDEO) != nil;
-  }
-
-  AudioStreamBasicDescription audio_stream_format() const;
-  CMFormatDescriptionRef video_stream_format() const;
-  CGAffineTransform video_transform() const;
-
-  scoped_refptr<media::DataBuffer> GetNextAudioSample();
-  scoped_refptr<media::DataBuffer> GetNextVideoSample();
-
-  bool Seek(base::TimeDelta time);
-
- private:
-  // A per-track struct wrapping an AVAssetReader, its output, and some state.
-  struct StreamReader {
-    StreamReader();
-    ~StreamReader();
-
-    media::PlatformMediaDataType type;
-    base::scoped_nsobject<AVAssetReader> asset_reader;
-    base::scoped_nsobject<AVAssetReaderTrackOutput> output;
-    base::TimeDelta expected_next_timestamp;
-    bool end_of_stream;
-
-   private:
-    DISALLOW_COPY_AND_ASSIGN(StreamReader);
-  };
-
-  bool CalculateBitrate();
-  bool ResetStreamReaders(base::TimeDelta start_time);
-  bool ResetStreamReader(media::PlatformMediaDataType type,
-                         base::TimeDelta start_time);
-  bool InitializeOutput(media::PlatformMediaDataType type);
-  NSDictionary* GetOutputSettings(media::PlatformMediaDataType type);
-
-  AVAssetTrack* GetTrack(media::PlatformMediaDataType type) const;
-
-  scoped_refptr<media::DataBuffer> ProcessNextSample(
-      media::PlatformMediaDataType type);
-  scoped_refptr<media::DataBuffer> ReadNextSample(
-      media::PlatformMediaDataType type);
-
-  base::scoped_nsobject<AVURLAsset> asset_;
-  base::scoped_nsobject<DataSourceLoader> data_source_loader_;
-  StreamReader stream_readers_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  int bitrate_;
-  gfx::Size video_coded_size_;
-
-  dispatch_queue_t queue_;
-
-  DISALLOW_COPY_AND_ASSIGN(AVFMediaReader);
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_READER_H_
diff --git a/content/common/gpu/media/avf_media_reader.mm b/content/common/gpu/media/avf_media_reader.mm
deleted file mode 100644
index 8d73912..0000000
--- a/content/common/gpu/media/avf_media_reader.mm
+++ /dev/null
@@ -1,517 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/avf_media_reader.h"
-
-#import <AVFoundation/AVFoundation.h>
-
-#include "base/logging.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/scoped_cftyperef.h"
-#include "base/mac/sdk_forward_declarations.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/strings/sys_string_conversions.h"
-#import "content/common/gpu/media/data_source_loader.h"
-#include "media/base/mac/avfoundation_glue.h"
-#include "media/base/mac/framework_type_conversions.h"
-#include "media/filters/platform_media_pipeline_types_mac.h"
-
-@interface AVURLAsset (MavericksSDK)
-@property(nonatomic, readonly) CrAVAssetResourceLoader* resourceLoader;
-@end
-
-namespace content {
-
-namespace {
-
-class ScopedBufferLock {
- public:
-  explicit ScopedBufferLock(CVPixelBufferRef buffer) : buffer_(buffer) {
-    CVPixelBufferLockBaseAddress(buffer_, kCVPixelBufferLock_ReadOnly);
-  }
-  ~ScopedBufferLock() {
-    CVPixelBufferUnlockBaseAddress(buffer_, kCVPixelBufferLock_ReadOnly);
-  }
-
- private:
-  const CVPixelBufferRef buffer_;
-};
-
-AVAssetTrack* AssetTrackForType(AVAsset* asset, NSString* track_type_name) {
-  NSArray* tracks = [asset tracksWithMediaType:track_type_name];
-  return [tracks count] > 0u ? [tracks objectAtIndex:0] : nil;
-}
-
-scoped_refptr<media::DataBuffer> ReadAudioSample(
-    AVAssetReaderOutput* audio_output) {
-  DVLOG(5) << __FUNCTION__;
-
-  base::ScopedCFTypeRef<CoreMediaGlue::CMSampleBufferRef> sample_buffer(
-      reinterpret_cast<CoreMediaGlue::CMSampleBufferRef>(
-          [audio_output copyNextSampleBuffer]));
-  if (!sample_buffer)
-    return nullptr;
-
-  const CMTime timestamp = media::CoreMediaGlueCMTimeToCMTime(
-      CoreMediaGlue::CMSampleBufferGetPresentationTimeStamp(sample_buffer));
-  const CMTime duration = media::CoreMediaGlueCMTimeToCMTime(
-      CoreMediaGlue::CMSampleBufferGetDuration(sample_buffer));
-  if (!CMTIME_IS_VALID(timestamp) || !CMTIME_IS_VALID(duration)) {
-    DVLOG(1) << "Invalid timestamp and/or duration";
-    return nullptr;
-  }
-
-  CMBlockBufferRef block_buffer =
-      CoreMediaGlue::CMSampleBufferGetDataBuffer(sample_buffer);
-  if (!block_buffer)
-    return nullptr;
-
-  const int data_size = base::saturated_cast<int>(
-      CoreMediaGlue::CMBlockBufferGetDataLength(block_buffer));
-  scoped_refptr<media::DataBuffer> audio_data_buffer =
-      new media::DataBuffer(data_size);
-  if (CoreMediaGlue::CMBlockBufferCopyDataBytes(
-          block_buffer, 0, data_size, audio_data_buffer->writable_data()) !=
-      kCMBlockBufferNoErr) {
-    DVLOG(1) << "Failed to copy audio data";
-    return nullptr;
-  }
-
-  audio_data_buffer->set_data_size(data_size);
-  audio_data_buffer->set_timestamp(media::CMTimeToTimeDelta(timestamp));
-  audio_data_buffer->set_duration(media::CMTimeToTimeDelta(duration));
-
-  return audio_data_buffer;
-}
-
-scoped_refptr<media::DataBuffer> ReadVideoSample(
-    AVAssetReaderOutput* video_output,
-    const gfx::Size& coded_size) {
-  DVLOG(5) << __FUNCTION__;
-
-  base::ScopedCFTypeRef<CoreMediaGlue::CMSampleBufferRef> sample_buffer(
-      reinterpret_cast<CoreMediaGlue::CMSampleBufferRef>(
-          [video_output copyNextSampleBuffer]));
-  if (!sample_buffer)
-    return nullptr;
-
-  const CMTime timestamp = media::CoreMediaGlueCMTimeToCMTime(
-      CoreMediaGlue::CMSampleBufferGetPresentationTimeStamp(sample_buffer));
-  if (!CMTIME_IS_VALID(timestamp)) {
-    DVLOG(1) << "Invalid timestamp and/or duration";
-    return nullptr;
-  }
-
-  CVImageBufferRef pixel_buffer =
-      CoreMediaGlue::CMSampleBufferGetImageBuffer(sample_buffer);
-  if (!pixel_buffer)
-    return nullptr;
-
-  ScopedBufferLock auto_lock(pixel_buffer);
-
-  size_t plane_sizes[3] = {0};
-  const int video_frame_planes[] = {
-      media::VideoFrame::kYPlane,
-      media::VideoFrame::kUPlane,
-      media::VideoFrame::kVPlane};
-
-  // The planes in the pixel buffer are YUV, but PassThroughVideoDecoder
-  // assumes YVU, so we switch the order of the last two planes.
-  const int planes[] = {0, 2, 1};
-  for (int i = 0; i < 3; ++i) {
-    const int plane = planes[i];
-
-    const int stride = CVPixelBufferGetBytesPerRowOfPlane(pixel_buffer, plane);
-
-    plane_sizes[plane] =
-        stride *
-        media::VideoFrame::PlaneSize(media::PIXEL_FORMAT_YV12,
-                                     video_frame_planes[plane],
-                                     coded_size).height();
-  }
-
-  // Copy all planes into contiguous memory.
-  const int data_size = plane_sizes[0] + plane_sizes[1] + plane_sizes[2];
-  scoped_refptr<media::DataBuffer> video_data_buffer =
-      new media::DataBuffer(data_size);
-  size_t data_offset = 0;
-  for (int i = 0; i < 3; ++i) {
-    const int plane = planes[i];
-
-    memcpy(video_data_buffer->writable_data() + data_offset,
-           CVPixelBufferGetBaseAddressOfPlane(pixel_buffer, plane),
-           plane_sizes[plane]);
-
-    data_offset += plane_sizes[plane];
-  }
-
-  video_data_buffer->set_data_size(data_size);
-  video_data_buffer->set_timestamp(media::CMTimeToTimeDelta(timestamp));
-
-  return video_data_buffer;
-}
-
-}  // namespace
-
-AVFMediaReader::StreamReader::StreamReader()
-    : type(media::PLATFORM_MEDIA_DATA_TYPE_COUNT),
-      end_of_stream(false) {
-}
-
-AVFMediaReader::StreamReader::~StreamReader() = default;
-
-AVFMediaReader::AVFMediaReader(dispatch_queue_t queue)
-    : bitrate_(-1), queue_(queue) {
-  DVLOG(1) << __FUNCTION__;
-
-  for (int i = 0; i < media::PLATFORM_MEDIA_DATA_TYPE_COUNT; ++i)
-    stream_readers_[i].type = static_cast<media::PlatformMediaDataType>(i);
-}
-
-AVFMediaReader::~AVFMediaReader() {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  [data_source_loader_ stop];
-}
-
-bool AVFMediaReader::Initialize(IPCDataSource* data_source,
-                                const std::string& mime_type) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  // The URL is completely arbitrary.  We use a "custom" URL scheme to force
-  // AVURLAsset to ask our instance of AVAssetResourceLoaderDelegate for data.
-  // This way, we make sure all data is fetched through Chrome's network stack
-  // (via |data_source| rather than by AVURLAsset directly.
-  NSString* url = [NSString stringWithFormat:@"opop:file.mp4"];
-  asset_.reset([[AVFoundationGlue::AVAssetClass()
-      assetWithURL:[NSURL URLWithString:url]] retain]);
-
-  data_source_loader_.reset([[DataSourceLoader alloc]
-      initWithDataSource:data_source
-            withMIMEType:base::SysUTF8ToNSString(mime_type)]);
-  [[asset_ resourceLoader] setDelegate:data_source_loader_
-                                 queue:[data_source_loader_ dispatchQueue]];
-
-  if (![asset_ isPlayable]) {
-    DVLOG(1) << "Asset is not playable";
-    return false;
-  }
-
-  if ([asset_ hasProtectedContent]) {
-    DVLOG(1) << "Asset has protected content";
-    return false;
-  }
-
-  if (!CalculateBitrate())
-    return false;
-
-  if (!has_video_track() && !has_audio_track()) {
-    DVLOG(1) << "No tracks to play";
-    return false;
-  }
-
-  if (has_video_track()) {
-    const CoreMediaGlue::CMVideoDimensions coded_size =
-        CoreMediaGlue::CMVideoFormatDescriptionGetDimensions(
-            video_stream_format());
-    video_coded_size_ = gfx::Size(coded_size.width, coded_size.height);
-  }
-
-  return ResetStreamReaders(base::TimeDelta());
-}
-
-int AVFMediaReader::bitrate() const {
-  DCHECK(queue_ == dispatch_get_current_queue());
-  DCHECK_GE(bitrate_, 0);
-  return bitrate_;
-}
-
-base::TimeDelta AVFMediaReader::duration() const {
-  DCHECK(queue_ == dispatch_get_current_queue());
-  return media::CMTimeToTimeDelta([asset_ duration]);
-}
-
-base::TimeDelta AVFMediaReader::start_time() const {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  return media::GetStartTimeFromTrack(
-      GetTrack(has_audio_track() ? media::PLATFORM_MEDIA_AUDIO
-                                 : media::PLATFORM_MEDIA_VIDEO));
-}
-
-AudioStreamBasicDescription AVFMediaReader::audio_stream_format() const {
-  DCHECK(queue_ == dispatch_get_current_queue());
-  DCHECK(has_audio_track());
-
-  DCHECK_GE([[GetTrack(media::PLATFORM_MEDIA_AUDIO) formatDescriptions] count],
-            1u);
-  const CMAudioFormatDescriptionRef audio_format =
-      reinterpret_cast<CMAudioFormatDescriptionRef>(
-          [[GetTrack(media::PLATFORM_MEDIA_AUDIO) formatDescriptions]
-              objectAtIndex:0]);
-
-  return CoreMediaGlue::CMAudioFormatDescriptionGetRichestDecodableFormat(
-             audio_format)
-      ->mASBD;
-}
-
-CMFormatDescriptionRef AVFMediaReader::video_stream_format() const {
-  DCHECK(queue_ == dispatch_get_current_queue());
-  DCHECK(has_video_track());
-
-  DCHECK_GE([[GetTrack(media::PLATFORM_MEDIA_VIDEO) formatDescriptions] count],
-            1u);
-  return reinterpret_cast<CMFormatDescriptionRef>(
-      [[GetTrack(media::PLATFORM_MEDIA_VIDEO) formatDescriptions]
-          objectAtIndex:0]);
-}
-
-CGAffineTransform AVFMediaReader::video_transform() const {
-  DCHECK(queue_ == dispatch_get_current_queue());
-  DCHECK(has_video_track());
-
-  return [GetTrack(media::PLATFORM_MEDIA_VIDEO) preferredTransform];
-}
-
-scoped_refptr<media::DataBuffer> AVFMediaReader::GetNextAudioSample() {
-  DVLOG(5) << __FUNCTION__;
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  return ProcessNextSample(media::PLATFORM_MEDIA_AUDIO);
-}
-
-scoped_refptr<media::DataBuffer> AVFMediaReader::GetNextVideoSample() {
-  DVLOG(5) << __FUNCTION__;
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  return ProcessNextSample(media::PLATFORM_MEDIA_VIDEO);
-}
-
-bool AVFMediaReader::Seek(base::TimeDelta time) {
-  DVLOG(1) << "Seeking to " << time.InMicroseconds() << " per pipeline request";
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  if (time == duration()) {
-    // AVAssetReader enters an error state if the time range starts where it
-    // ends.
-    for (StreamReader& stream_reader : stream_readers_)
-      stream_reader.end_of_stream = true;
-
-    return true;
-  }
-
-  if (!ResetStreamReaders(time))
-    return false;
-
-  return true;
-}
-
-bool AVFMediaReader::CalculateBitrate() {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  float bitrate = 0;
-  for (const StreamReader& stream_reader : stream_readers_)
-    bitrate += [GetTrack(stream_reader.type) estimatedDataRate];
-  if (!base::IsValueInRangeForNumericType<decltype(bitrate_)>(bitrate))
-    return false;
-
-  bitrate_ = bitrate;
-  DVLOG(1) << "bitrate = " << bitrate_;
-  return true;
-}
-
-bool AVFMediaReader::ResetStreamReaders(base::TimeDelta start_time) {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  for (StreamReader& stream_reader : stream_readers_) {
-    if (GetTrack(stream_reader.type) != nil &&
-        !ResetStreamReader(stream_reader.type, start_time))
-      return false;
-  }
-
-  return true;
-}
-
-bool AVFMediaReader::ResetStreamReader(media::PlatformMediaDataType type,
-                                       base::TimeDelta start_time) {
-  DCHECK(queue_ == dispatch_get_current_queue());
-  DCHECK(GetTrack(type) != nil);
-
-  [stream_readers_[type].asset_reader cancelReading];
-
-  stream_readers_[type].expected_next_timestamp = start_time;
-  stream_readers_[type].end_of_stream = false;
-
-  NSError* reader_error = nil;
-  stream_readers_[type].asset_reader.reset(
-      [[AVFoundationGlue::AVAssetReaderClass()
-          assetReaderWithAsset:asset_
-                         error:&reader_error] retain]);
-  if (reader_error != nil) {
-    DVLOG(1) << base::SysNSStringToUTF8([reader_error localizedDescription]);
-    return false;
-  }
-
-  const CoreMediaGlue::CMTimeRange time_range = CoreMediaGlue::CMTimeRangeMake(
-      media::TimeDeltaToCoreMediaGlueCMTime(start_time),
-      CoreMediaGlue::kCMTimePositiveInfinity);
-  [stream_readers_[type].asset_reader
-      setTimeRange:media::CoreMediaGlueCMTimeRangeToCMTimeRange(time_range)];
-
-  if (!InitializeOutput(type))
-    return false;
-
-  if ([stream_readers_[type].asset_reader startReading] != YES) {
-    DVLOG(1) << "Failed to start reading with AVAssetReader: "
-             << base::SysNSStringToUTF8([[stream_readers_[type].asset_reader
-                                              error] localizedDescription]);
-    return false;
-  }
-
-  return true;
-}
-
-bool AVFMediaReader::InitializeOutput(media::PlatformMediaDataType type) {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  StreamReader& stream_reader = stream_readers_[type];
-
-  stream_reader.output.reset([[AVFoundationGlue::AVAssetReaderTrackOutputClass()
-      assetReaderTrackOutputWithTrack:GetTrack(type)
-                       outputSettings:GetOutputSettings(type)] retain]);
-  [stream_reader.output setAlwaysCopiesSampleData:NO];
-
-  if (![stream_reader.asset_reader canAddOutput:stream_reader.output]) {
-    DVLOG(1) << "Cannot add output (" << type << ")";
-    return false;
-  }
-
-  [stream_reader.asset_reader addOutput:stream_reader.output];
-  return true;
-}
-
-NSDictionary* AVFMediaReader::GetOutputSettings(
-    media::PlatformMediaDataType type) {
-  switch (type) {
-    case media::PLATFORM_MEDIA_AUDIO: {
-      // Here we align the channel layouts on the Chrome and AVF sides in a way
-      // that is intentionally lossy in some cases, for simplicity: First get
-      // the default Chrome layout for a given number of channels, then map
-      // that layout to a Core Audio layout.  This is good enough to avoid
-      // major mixups like playing the center channel through the right speaker
-      // only.  Time will tell if we need anything better than this.
-      const media::ChannelLayout chrome_default_channel_layout =
-          media::GuessChannelLayout(audio_stream_format().mChannelsPerFrame);
-
-      AudioChannelLayout channel_layout = {0};
-      channel_layout.mChannelLayoutTag =
-          media::ChromeChannelLayoutToCoreAudioTag(
-              chrome_default_channel_layout);
-
-      return @{
-        AVFoundationGlue::AVFormatIDKey() : @(kAudioFormatLinearPCM),
-        AVFoundationGlue::AVChannelLayoutKey() :
-            [NSData dataWithBytes:&channel_layout length:sizeof(channel_layout)]
-      };
-    }
-
-    case media::PLATFORM_MEDIA_VIDEO:
-      return @{
-        base::mac::CFToNSCast(kCVPixelBufferPixelFormatTypeKey) :
-            @(kCVPixelFormatType_420YpCbCr8Planar)
-            };
-
-    default:
-      NOTREACHED();
-      return nil;
-  }
-}
-
-AVAssetTrack* AVFMediaReader::GetTrack(
-    media::PlatformMediaDataType type) const {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  switch (type) {
-    case media::PLATFORM_MEDIA_AUDIO:
-      return AssetTrackForType(asset_, AVFoundationGlue::AVMediaTypeAudio());
-
-    case media::PLATFORM_MEDIA_VIDEO:
-      return AssetTrackForType(asset_, AVFoundationGlue::AVMediaTypeVideo());
-
-    default:
-      NOTREACHED();
-      return nil;
-  }
-}
-
-scoped_refptr<media::DataBuffer> AVFMediaReader::ProcessNextSample(
-    media::PlatformMediaDataType type) {
-  DVLOG(5) << __FUNCTION__;
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  const scoped_refptr<media::DataBuffer> buffer = ReadNextSample(type);
-
-  if (buffer && !buffer->end_of_stream()) {
-    stream_readers_[type].expected_next_timestamp =
-        buffer->timestamp() + buffer->duration();
-
-    // If a duration is set on the audio buffer, it confuses the Chromium
-    // pipeline.
-    buffer->set_duration(base::TimeDelta());
-  }
-
-  return buffer;
-}
-
-scoped_refptr<media::DataBuffer> AVFMediaReader::ReadNextSample(
-    media::PlatformMediaDataType type) {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  if (stream_readers_[type].end_of_stream)
-    return media::DataBuffer::CreateEOSBuffer();
-
-  for (;;) {
-    const scoped_refptr<media::DataBuffer> buffer =
-        type == media::PLATFORM_MEDIA_AUDIO
-            ? ReadAudioSample(stream_readers_[type].output)
-            : ReadVideoSample(stream_readers_[type].output, video_coded_size_);
-    if (buffer != nullptr)
-      return buffer;
-
-    AVAssetReader* asset_reader = stream_readers_[type].asset_reader;
-
-    // Failure to get a DataBuffer can mean a number of things: time-out caused
-    // by shortage of raw media data, end of stream, or decoding error.
-
-    if ([asset_reader status] == AVAssetReaderStatusFailed) {
-      const bool timed_out =
-          [[[asset_reader error] domain] isEqualToString:NSURLErrorDomain] &&
-          [[asset_reader error] code] == NSURLErrorTimedOut;
-      if (timed_out) {
-        DVLOG(1) << "I think we've timed out, retrying";
-        if (ResetStreamReader(type,
-                              stream_readers_[type].expected_next_timestamp))
-          continue;
-      }
-
-      DVLOG(1) << "Decode error(" << type
-               << "): " << base::SysNSStringToUTF8(
-                               [[asset_reader error] localizedDescription]);
-      return nullptr;
-    }
-
-    DVLOG(1) << "EOS(" << type << ")";
-    stream_readers_[type].end_of_stream = true;
-    return media::DataBuffer::CreateEOSBuffer();
-  }
-
-  NOTREACHED();
-  return nullptr;
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/avf_media_reader_runner.h b/content/common/gpu/media/avf_media_reader_runner.h
deleted file mode 100644
index d39943c..0000000
--- a/content/common/gpu/media/avf_media_reader_runner.h
+++ /dev/null
@@ -1,71 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_READER_RUNNER_H_
-#define CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_READER_RUNNER_H_
-
-#include <string>
-
-#include "base/memory/weak_ptr.h"
-#include "base/threading/thread_checker.h"
-#include "content/common/gpu/media/platform_media_pipeline.h"
-#include "media/filters/platform_media_pipeline_types.h"
-
-namespace content {
-
-class AVFMediaReader;
-
-// The preferred PlatformMediaPipeline implementation for OS X.  Not available
-// on all OS X versions, see |IsAvailable()|.
-//
-// AVFMediaReaderRunner, which lives on the main thread, performs the actual
-// media decoding tasks through the synchronous API of AVFMediaRunner.  Thus,
-// the main purpose of AVFMediaReaderRunner is to maintain a dedicated thread
-// where blocking AVFMediaReader tasks are run and to dispatch requests and
-// responses between the main thread and the AVFMediaReader thread.
-class AVFMediaReaderRunner : public PlatformMediaPipeline {
- public:
-  explicit AVFMediaReaderRunner(IPCDataSource* data_source);
-  ~AVFMediaReaderRunner() override;
-
-  // A run-time check is required to determine usability of
-  // AVFMediaReaderRunner.
-  static bool IsAvailable();
-
-  // PlatformMediaPipeline implementation.
-  void Initialize(const std::string& mime_type,
-                  const InitializeCB& initialize_cb) override;
-  void ReadAudioData(const ReadDataCB& read_audio_data_cb) override;
-  void ReadVideoData(const ReadDataCB& read_video_data_cb,
-                     uint32_t /* texture_id */) override;
-  void WillSeek() override;
-  void Seek(base::TimeDelta time, const SeekCB& seek_cb) override;
-
- private:
-  void DataReady(media::PlatformMediaDataType type,
-                 const ReadDataCB& read_data_cb,
-                 const scoped_refptr<media::DataBuffer>& data);
-
-  IPCDataSource* const data_source_;
-
-  dispatch_queue_t reader_queue_;
-  scoped_ptr<AVFMediaReader> reader_;
-
-  bool will_seek_;
-
-  scoped_refptr<media::DataBuffer>
-      last_data_buffer_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  base::ThreadChecker thread_checker_;
-
-  base::WeakPtrFactory<AVFMediaReaderRunner> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(AVFMediaReaderRunner);
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_AVF_MEDIA_READER_RUNNER_H_
diff --git a/content/common/gpu/media/avf_media_reader_runner.mm b/content/common/gpu/media/avf_media_reader_runner.mm
deleted file mode 100644
index 1a03838..0000000
--- a/content/common/gpu/media/avf_media_reader_runner.mm
+++ /dev/null
@@ -1,179 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/avf_media_reader_runner.h"
-
-#include "base/mac/mac_util.h"
-#include "content/common/gpu/media/avf_media_reader.h"
-#include "content/common/gpu/media/ipc_data_source.h"
-#include "media/base/bind_to_current_loop.h"
-#include "media/filters/platform_media_pipeline_types.h"
-#include "media/filters/platform_media_pipeline_types_mac.h"
-
-namespace content {
-
-namespace {
-
-void InitializeReader(AVFMediaReader* reader,
-                      IPCDataSource* data_source,
-                      const std::string& mime_type,
-                      const AVFMediaReaderRunner::InitializeCB& initialize_cb) {
-  const bool success = reader->Initialize(data_source, mime_type);
-
-  int bitrate = -1;
-  base::TimeDelta duration;
-  media::PlatformMediaTimeInfo time_info;
-  media::PlatformAudioConfig audio_config;
-  media::PlatformVideoConfig video_config;
-
-  if (success) {
-    bitrate = reader->bitrate();
-    time_info.duration = reader->duration();
-    time_info.start_time = reader->start_time();
-
-    if (reader->has_audio_track()) {
-      audio_config.format = media::kSampleFormatF32;
-      audio_config.channel_count =
-          reader->audio_stream_format().mChannelsPerFrame;
-      audio_config.samples_per_second =
-          reader->audio_stream_format().mSampleRate;
-    }
-
-    if (reader->has_video_track()) {
-      video_config = media::GetPlatformVideoConfig(
-          reader->video_stream_format(), reader->video_transform());
-    }
-  }
-
-  initialize_cb.Run(success, bitrate, time_info, audio_config, video_config);
-}
-
-}  // namespace
-
-AVFMediaReaderRunner::AVFMediaReaderRunner(IPCDataSource* data_source)
-    : data_source_(data_source),
-      reader_queue_(nullptr),
-      will_seek_(false),
-      weak_ptr_factory_(this) {
-  DVLOG(1) << __FUNCTION__;
-}
-
-AVFMediaReaderRunner::~AVFMediaReaderRunner() {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  // Unblock any ongoing data read operations.
-  data_source_->Stop();
-
-  if (reader_queue_) {
-    // Because |reader_queue_| is a FIFO queue, this effectively "joins" with
-    // the queue: Any |reader_| tasks currently in flight will run on
-    // |reader_queue_|, and then the following block will run.
-    dispatch_sync(reader_queue_, ^{
-      reader_.reset();
-    });
-
-    dispatch_release(reader_queue_);
-  }
-}
-
-// static
-bool AVFMediaReaderRunner::IsAvailable() {
-  return base::mac::IsOSYosemiteOrLater();
-}
-
-void AVFMediaReaderRunner::Initialize(const std::string& mime_type,
-                                      const InitializeCB& initialize_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  reader_queue_ = dispatch_queue_create("com.operasoftware.MediaReader",
-                                        DISPATCH_QUEUE_SERIAL);
-  if (!reader_queue_) {
-    initialize_cb.Run(false,
-                      -1,
-                      media::PlatformMediaTimeInfo(),
-                      media::PlatformAudioConfig(),
-                      media::PlatformVideoConfig());
-    return;
-  }
-
-  reader_.reset(new AVFMediaReader(reader_queue_));
-
-  const auto cb = media::BindToCurrentLoop(initialize_cb);
-  const std::string mt = mime_type;
-  dispatch_async(reader_queue_, ^{
-    InitializeReader(reader_.get(), data_source_, mt, cb);
-  });
-}
-
-void AVFMediaReaderRunner::ReadAudioData(const ReadDataCB& read_audio_data_cb) {
-  DVLOG(5) << "Renderer asking for audio data";
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  const auto cb = media::BindToCurrentLoop(base::Bind(
-      &AVFMediaReaderRunner::DataReady, weak_ptr_factory_.GetWeakPtr(),
-      media::PLATFORM_MEDIA_AUDIO, read_audio_data_cb));
-  dispatch_async(reader_queue_, ^{
-    cb.Run(reader_->GetNextAudioSample());
-  });
-}
-
-void AVFMediaReaderRunner::ReadVideoData(const ReadDataCB& read_video_data_cb,
-                                         uint32_t /* texture_id */) {
-  DVLOG(5) << "Renderer asking for video data";
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  const auto cb = media::BindToCurrentLoop(base::Bind(
-      &AVFMediaReaderRunner::DataReady, weak_ptr_factory_.GetWeakPtr(),
-      media::PLATFORM_MEDIA_VIDEO, read_video_data_cb));
-  dispatch_async(reader_queue_, ^{
-    cb.Run(reader_->GetNextVideoSample());
-  });
-}
-
-void AVFMediaReaderRunner::WillSeek() {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  will_seek_ = true;
-  data_source_->Suspend();
-}
-
-void AVFMediaReaderRunner::Seek(base::TimeDelta time, const SeekCB& seek_cb) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  will_seek_ = false;
-
-  const auto cb = media::BindToCurrentLoop(seek_cb);
-  dispatch_async(reader_queue_, ^{
-    data_source_->Resume();
-    cb.Run(reader_->Seek(time));
-  });
-}
-
-void AVFMediaReaderRunner::DataReady(
-    media::PlatformMediaDataType type,
-    const ReadDataCB& read_data_cb,
-    const scoped_refptr<media::DataBuffer>& data) {
-  DVLOG(5) << __FUNCTION__ << "(type = " << type
-           << ", will seek = " << will_seek_ << ")";
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (will_seek_ && last_data_buffer_[type]) {
-    // In |WillSeek()| we interrupt the IPCDataSource, which can easily cause
-    // decode errors.  But we do that because of the approaching seek request,
-    // so it's fine to ignore any output buffers that have arrived between the
-    // |WillSeek()| and |Seek()| calls.
-    read_data_cb.Run(last_data_buffer_[type]);
-    return;
-  }
-
-  last_data_buffer_[type] = data;
-  read_data_cb.Run(data);
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/data_request_handler.h b/content/common/gpu/media/data_request_handler.h
deleted file mode 100644
index 77830cb7..0000000
--- a/content/common/gpu/media/data_request_handler.h
+++ /dev/null
@@ -1,115 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_DATA_REQUEST_HANDLER_H_
-#define CONTENT_COMMON_GPU_MEDIA_DATA_REQUEST_HANDLER_H_
-
-#include <algorithm>
-
-#include "base/callback.h"
-#include "base/mac/scoped_nsobject.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/synchronization/waitable_event.h"
-#include "content/common/content_export.h"
-#include "media/base/mac/avfoundation_glue.h"
-
-namespace content {
-
-class IPCDataSource;
-
-// Roughly maps to AVAssetResourceLoadingDataRequest, only it's mutable.
-struct ResourceLoadingDataRequest {
-  ResourceLoadingDataRequest() : offset(0), length(0) {}
-
-  explicit ResourceLoadingDataRequest(
-      // Casting to NSUInteger is required in case 32 bit builds and
-      // data_request.length value exceeds (2^32)/2. chunk_size will return
-      // negative value, and AVFMediaPipeline will not be able to decode media.
-      CrAVAssetResourceLoadingDataRequest* dataRequest)
-      : offset([dataRequest requestedOffset]),
-        length(static_cast<NSUInteger>([dataRequest requestedLength])) {}
-
-  int64_t offset;
-  int64_t length;
-};
-
-// Handles requests to fetch specified amounts of data from an IPCDataSource.
-// It is able to handle one request at a time, and it can respond with smaller
-// chunks of data until the full request is fulfilled.
-//
-// All reads and responses are serialized on one dispatch queue.
-class CONTENT_EXPORT DataRequestHandler
-    : public base::RefCountedThreadSafe<DataRequestHandler> {
- public:
-  enum Status {
-    SUCCESS,
-    ERROR,
-    CANCELED,
-  };
-
-  using RespondWithDataCB =
-      base::Callback<void(id request_handle, uint8_t* data, int size)>;
-  using FinishLoadingCB =
-      base::Callback<void(id request_handle, Status status)>;
-
-  enum { kBufferSize = 64 * 1024 };
-
-  DataRequestHandler(IPCDataSource* data_source,
-                     const RespondWithDataCB& respond_with_data_cb,
-                     const FinishLoadingCB& finish_loading_cb,
-                     dispatch_queue_t queue);
-
-  void HandleDataRequest(id request_handle,
-                         const ResourceLoadingDataRequest& data_request);
-
-  // Cancels a data request being handled.  As this must be called on the
-  // serial dispatch queue, it only affects the chunks of the original data
-  // request that haven't been processed yet.
-  void CancelDataRequest(id request_handle);
-
-  // Forces all pending data requests to finish with an error.
-  void AbortAllDataRequests();
-
-  bool IsHandlingDataRequests() const;
-
- private:
-  friend class base::RefCountedThreadSafe<DataRequestHandler>;
-
-  struct Request;
-  class OrderedRequests;
-
-  static int chunk_size(const ResourceLoadingDataRequest& data_request) {
-    return std::min(static_cast<int64_t>(kBufferSize), data_request.length);
-  }
-
-  ~DataRequestHandler();
-
-  void DispatchBlockingRead();
-  void ReadNextChunk();
-  void DidReadNextChunk(int size);
-  void ProcessChunk();
-  void FinishLoading(id request_handle, Status status);
-
-  IPCDataSource* const data_source_;
-  const dispatch_queue_t queue_;
-
-  scoped_ptr<OrderedRequests> requests_;
-
-  uint8_t buffer_[kBufferSize];
-  int last_size_read_;
-
-  RespondWithDataCB respond_with_data_cb_;
-  FinishLoadingCB finish_loading_cb_;
-
-  base::WaitableEvent read_complete_;
-
-  DISALLOW_COPY_AND_ASSIGN(DataRequestHandler);
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_DATA_REQUEST_HANDLER_H_
diff --git a/content/common/gpu/media/data_request_handler.mm b/content/common/gpu/media/data_request_handler.mm
deleted file mode 100644
index 5ec49fe..0000000
--- a/content/common/gpu/media/data_request_handler.mm
+++ /dev/null
@@ -1,243 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "content/common/gpu/media/data_request_handler.h"
-
-#include <vector>
-
-#include "base/bind.h"
-#include "base/logging.h"
-#include "base/trace_event/trace_event.h"
-#include "content/common/gpu/media/ipc_data_source.h"
-
-namespace content {
-
-struct DataRequestHandler::Request {
-  explicit Request(id handle, const ResourceLoadingDataRequest& data_request);
-  ~Request();
-
-  base::scoped_nsobject<id> handle;
-  ResourceLoadingDataRequest data_request;
-};
-
-DataRequestHandler::Request::Request(
-    id handle,
-    const ResourceLoadingDataRequest& data_request)
-    : handle([handle retain]), data_request(data_request) {
-}
-
-DataRequestHandler::Request::~Request() = default;
-
-// A container for Requests uniquely identified by handles, but ordered by
-// requested offset.
-class DataRequestHandler::OrderedRequests {
- public:
-  void Add(const Request& request);
-  void Remove(id handle);
-  void RemoveAll();
-  const Request& Top() const;
-  void Pop();
-
-  bool is_empty() const { return requests_.empty(); }
-
- private:
-  using Container = std::vector<Request>;
-
-  Container::iterator Find(id handle);
-
-  Container requests_;
-};
-
-void DataRequestHandler::OrderedRequests::Add(const Request& request) {
-  DCHECK(Find(request.handle) == requests_.end());
-
-  const auto offset = request.data_request.offset;
-  const auto it = std::find_if(requests_.begin(), requests_.end(),
-                               [offset](const Request& request) {
-    return request.data_request.offset <= offset;
-  });
-  requests_.insert(it, request);
-
-  DVLOG(7) << "Ongoing requests:";
-  for (const auto& r : requests_)
-    DVLOG(7) << "  " << r.handle << ": " << r.data_request.offset;
-}
-
-void DataRequestHandler::OrderedRequests::Remove(id handle) {
-  const auto it = Find(handle);
-  DCHECK(it != requests_.end());
-  requests_.erase(it);
-}
-
-void DataRequestHandler::OrderedRequests::RemoveAll() {
-  requests_.clear();
-}
-
-const DataRequestHandler::Request& DataRequestHandler::OrderedRequests::Top()
-    const {
-  DCHECK(!requests_.empty());
-  return requests_.back();
-}
-
-void DataRequestHandler::OrderedRequests::Pop() {
-  DCHECK(!requests_.empty());
-  requests_.pop_back();
-}
-
-DataRequestHandler::OrderedRequests::Container::iterator
-DataRequestHandler::OrderedRequests::Find(id handle) {
-  return std::find_if(
-      requests_.begin(), requests_.end(),
-      [handle](const Request& request) { return request.handle == handle; });
-}
-
-DataRequestHandler::DataRequestHandler(
-    IPCDataSource* data_source,
-    const RespondWithDataCB& respond_with_data_cb,
-    const FinishLoadingCB& finish_loading_cb,
-    dispatch_queue_t queue)
-    : data_source_(data_source),
-      queue_(queue),
-      requests_(new OrderedRequests),
-      last_size_read_(IPCDataSource::kReadError),
-      respond_with_data_cb_(respond_with_data_cb),
-      finish_loading_cb_(finish_loading_cb),
-      read_complete_(false, false) {
-  DCHECK(data_source_ != NULL);
-  DCHECK(!respond_with_data_cb_.is_null());
-  DCHECK(!finish_loading_cb_.is_null());
-}
-
-DataRequestHandler::~DataRequestHandler() {
-  DVLOG(5) << __FUNCTION__;
-}
-
-void DataRequestHandler::HandleDataRequest(
-    id request_handle,
-    const ResourceLoadingDataRequest& data_request) {
-  DVLOG(5) << "New data request " << request_handle << ": "
-           << data_request.length << " bytes @" << data_request.offset << "...";
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  requests_->Add(Request(request_handle, data_request));
-
-  DispatchBlockingRead();
-}
-
-void DataRequestHandler::CancelDataRequest(id request_handle) {
-  DVLOG(5) << __FUNCTION__;
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  requests_->Remove(request_handle);
-
-  FinishLoading(request_handle, CANCELED);
-}
-
-void DataRequestHandler::AbortAllDataRequests() {
-  DVLOG(5) << __FUNCTION__;
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  while (!requests_->is_empty()) {
-    FinishLoading(requests_->Top().handle, ERROR);
-    requests_->Pop();
-  }
-}
-
-bool DataRequestHandler::IsHandlingDataRequests() const {
-  DCHECK(queue_ == dispatch_get_current_queue());
-  return !requests_->is_empty();
-}
-
-void DataRequestHandler::DispatchBlockingRead() {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  // Let the block below capture |this| by copying the scoped_refptr.  This
-  // creates an additional reference that can then be safely used within the
-  // block even if all other references are gone.
-  scoped_refptr<DataRequestHandler> handler(this);
-
-  dispatch_async(queue_, ^{
-    if (!handler->requests_->is_empty())
-      handler->ReadNextChunk();
-    else
-      DVLOG(1) << "All requests have been canceled";
-  });
-}
-
-void DataRequestHandler::ReadNextChunk() {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  const ResourceLoadingDataRequest& data_request =
-      requests_->Top().data_request;
-
-  DCHECK_GT(data_request.length, 0);
-  DVLOG(5) << "Blocking to read @" << data_request.offset;
-
-  // We're performing a blocking read to enforce proper serialization of reads
-  // on the dispatch queue.  AVAssetResourceLoader sometimes makes overlapping
-  // read requests, but an IPCDataSource cannot handle overlapping reads.
-
-  TRACE_EVENT0("IPC_MEDIA", __FUNCTION__);
-  data_source_->Read(data_request.offset,
-                     chunk_size(data_request),
-                     buffer_,
-                     base::Bind(&DataRequestHandler::DidReadNextChunk, this));
-  read_complete_.Wait();
-
-  DVLOG(5) << "...chunk complete";
-  ProcessChunk();
-}
-
-void DataRequestHandler::DidReadNextChunk(int size) {
-  // We don't control which thread or dispatch queue this is called on.  All
-  // we're doing here must be thread-safe.
-
-  last_size_read_ = size;
-  read_complete_.Signal();
-}
-
-void DataRequestHandler::ProcessChunk() {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  Request request = requests_->Top();
-  requests_->Pop();
-
-  DVLOG(5) << "Processing chunk: " << last_size_read_ << " @"
-           << request.data_request.offset;
-
-  if (last_size_read_ <= 0) {
-    DVLOG_IF(1, last_size_read_ == 0) << "DataSource reports EOS";
-    FinishLoading(request.handle, ERROR);
-    AbortAllDataRequests();
-    return;
-  }
-
-  respond_with_data_cb_.Run(request.handle, buffer_, last_size_read_);
-
-  DCHECK_LE(last_size_read_, request.data_request.length);
-  // We're done if we read all the data that was requested or the source has
-  // less data than was requested.
-  if (request.data_request.length == last_size_read_ ||
-      last_size_read_ < chunk_size(request.data_request)) {
-    FinishLoading(request.handle, SUCCESS);
-  } else {
-    request.data_request.length -= last_size_read_;
-    request.data_request.offset += last_size_read_;
-    requests_->Add(request);
-  }
-
-  if (!requests_->is_empty())
-    DispatchBlockingRead();
-}
-
-void DataRequestHandler::FinishLoading(id request_handle, Status status) {
-  DVLOG(5) << "Finishing " << request_handle << ": " << status;
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  finish_loading_cb_.Run(request_handle, status);
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/data_request_handler_unittest.mm b/content/common/gpu/media/data_request_handler_unittest.mm
deleted file mode 100644
index 000007e..0000000
--- a/content/common/gpu/media/data_request_handler_unittest.mm
+++ /dev/null
@@ -1,427 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "content/common/gpu/media/data_request_handler.h"
-
-#include <algorithm>
-#include <map>
-#include <vector>
-
-#include "base/bind.h"
-#include "base/single_thread_task_runner.h"
-#include "base/stl_util.h"
-#include "base/threading/thread.h"
-#include "content/common/gpu/media/ipc_data_source.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace content {
-namespace {
-
-class TestDataSource : public IPCDataSource {
- public:
-  TestDataSource()
-      : eos_(false),
-        error_(false),
-        suspended_(false),
-        unblock_event_(nullptr) {}
-
-  void set_task_runner(
-      const scoped_refptr<base::SingleThreadTaskRunner>& task_runner) {
-    task_runner_ = task_runner;
-  }
-
-  void set_data(const std::vector<uint8_t>& data) { data_ = data; }
-  void set_eos(bool eos) { eos_ = eos; }
-  void set_error(bool error) { error_ = error; }
-  void set_blocked_on(base::WaitableEvent* event) {
-    unblock_event_ = event;
-  }
-
-  void Suspend() override { suspended_ = true; }
-  void Resume() override { suspended_ = false; }
-
-  void Read(int64_t position,
-            int size,
-            uint8_t* data,
-            const ReadCB& read_cb) override {
-    if (unblock_event_ != nullptr)
-      unblock_event_->Wait();
-
-    ASSERT_GE(position, 0);
-    ASSERT_GE(size, 0);
-    ASSERT_LE(size, DataRequestHandler::kBufferSize);
-
-    if (suspended_) {
-      size = kReadInterrupted;
-    } else if (eos_) {
-      size = 0;
-    } else if (error_) {
-      size = kReadError;
-    } else {
-      size = std::max(0, std::min(size, int(data_.size() - position)));
-      std::copy(
-          data_.begin() + position, data_.begin() + position + size, data);
-    }
-
-    task_runner_->PostTask(FROM_HERE, base::Bind(read_cb, size));
-  }
-
-  void Stop() override {}
-  bool GetSize(int64_t* size_out) override { return false; }
-  bool IsStreaming() override { return false; }
-  void SetBitrate(int bitrate) override {}
-
- private:
-  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-  std::vector<uint8_t> data_;
-  bool eos_;
-  bool error_;
-  bool suspended_;
-  base::WaitableEvent* unblock_event_;
-};
-
-dispatch_queue_t GetTestQueue() {
-  static dispatch_queue_t the_queue;
-  static dispatch_once_t once_token;
-  dispatch_once(&once_token, ^{
-      the_queue = dispatch_queue_create("com.operasoftware.TestQueue",
-                                        DISPATCH_QUEUE_SERIAL);
-  });
-  return the_queue;
-}
-
-// The data members describing the state of the request are accessed from two
-// different dispatch queues.  The tests must take care (e.g., by calling
-// WaitUntilFinished()) to avoid races.
-class DataRequestHandlerTest : public testing::Test {
- public:
-  DataRequestHandlerTest()
-      : data_source_thread_("DataRequestHandlerTest"),
-        handler_(new DataRequestHandler(
-            &data_source_,
-            base::Bind(&DataRequestHandlerTest::DataAvailable,
-                       base::Unretained(this)),
-            base::Bind(&DataRequestHandlerTest::LoadingFinished,
-                       base::Unretained(this)),
-            GetTestQueue())) {
-    data_source_thread_.Start();
-    data_source_.set_task_runner(data_source_thread_.task_runner());
-  }
-
-  ~DataRequestHandlerTest() override {
-    STLDeleteContainerPairSecondPointers(requests_.begin(), requests_.end());
-  }
-
- protected:
-  struct Generator {
-    Generator() : i(0) {}
-    int operator()() { return i++; }
-    int i;
-  };
-
-  void CallHandleDataRequest(id request_handle,
-                             ResourceLoadingDataRequest data_request) {
-    CHECK_EQ(requests_.count(request_handle), 0u);
-    requests_[request_handle] = new Request;
-
-    dispatch_async(GetTestQueue(), ^{
-      handler_->HandleDataRequest(request_handle, data_request);
-    });
-  }
-
-  void WaitUntilDataAvailable(id request_handle) {
-    CHECK_EQ(requests_.count(request_handle), 1u);
-    ASSERT_TRUE(requests_[request_handle]->data_available_event.TimedWait(
-        base::TimeDelta::FromSeconds(3)));
-  }
-
-  void WaitUntilFinished(id request_handle) {
-    CHECK_EQ(requests_.count(request_handle), 1u);
-    ASSERT_TRUE(requests_[request_handle]->finished_event.TimedWait(
-        base::TimeDelta::FromSeconds(3)));
-  }
-
-  bool is_finished(id request_handle) {
-    CHECK_EQ(requests_.count(request_handle), 1u);
-    return requests_[request_handle]->finished_event.IsSignaled();
-  }
-  DataRequestHandler::Status status(id request_handle) {
-    CHECK_EQ(requests_.count(request_handle), 1u);
-    CHECK(requests_[request_handle]->finished_event.IsSignaled());
-    return requests_[request_handle]->status;
-  }
-  const std::vector<uint8_t>& loaded_data() const { return loaded_data_; }
-
-  base::Thread data_source_thread_;
-  TestDataSource data_source_;
-  scoped_refptr<DataRequestHandler> handler_;
-
- private:
-  struct Request {
-    Request()
-        : data_available_event(false, false),
-          finished_event(true, false),
-          status(DataRequestHandler::SUCCESS) {}
-
-    base::WaitableEvent data_available_event;
-    base::WaitableEvent finished_event;
-    DataRequestHandler::Status status;
-  };
-
-  void DataAvailable(id request_handle, uint8_t* data, int size) {
-    CHECK_EQ(requests_.count(request_handle), 1u);
-    ASSERT_EQ(GetTestQueue(), dispatch_get_current_queue());
-
-    loaded_data_.insert(loaded_data_.end(), data, data + size);
-
-    Request* request = requests_[request_handle];
-    ASSERT_FALSE(request->finished_event.IsSignaled());
-    request->data_available_event.Signal();
-  }
-
-  void LoadingFinished(id request_handle,
-                       DataRequestHandler::Status status) {
-    CHECK_EQ(requests_.count(request_handle), 1u);
-    ASSERT_EQ(GetTestQueue(), dispatch_get_current_queue());
-
-    Request* request = requests_[request_handle];
-    ASSERT_FALSE(request->finished_event.IsSignaled());
-    request->status = status;
-    request->finished_event.Signal();
-  }
-
-  std::map<id, Request*> requests_;
-  std::vector<uint8_t> loaded_data_;
-};
-
-
-TEST_F(DataRequestHandlerTest, FinishesWithErrorOnDataSourceError) {
-  data_source_.set_error(true);
-
-  ResourceLoadingDataRequest request;
-  request.length = 1500;
-
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(nil, request));
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(nil));
-
-  EXPECT_EQ(DataRequestHandler::ERROR, status(nil));
-}
-
-TEST_F(DataRequestHandlerTest, FinishesWithErrorOnDataSourceEOS) {
-  data_source_.set_eos(true);
-
-  ResourceLoadingDataRequest request;
-  request.length = 1500;
-
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(nil, request));
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(nil));
-
-  EXPECT_EQ(DataRequestHandler::ERROR, status(nil));
-}
-
-TEST_F(DataRequestHandlerTest, DataSourceSizeSmallerThanRequested) {
-  std::vector<uint8_t> data(5);
-  std::generate(data.begin(), data.end(), Generator());
-  data_source_.set_data(data);
-
-  ResourceLoadingDataRequest request;
-  request.length = 10;
-
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(nil, request));
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(nil));
-
-  EXPECT_EQ(DataRequestHandler::SUCCESS, status(nil));
-  EXPECT_EQ(data, loaded_data());
-}
-
-TEST_F(DataRequestHandlerTest, DataSourceSizeEqualToRequested) {
-  std::vector<uint8_t> data(5);
-  std::generate(data.begin(), data.end(), Generator());
-  data_source_.set_data(data);
-
-  ResourceLoadingDataRequest request;
-  request.length = 5;
-
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(nil, request));
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(nil));
-
-  EXPECT_EQ(DataRequestHandler::SUCCESS, status(nil));
-  EXPECT_EQ(data, loaded_data());
-}
-
-TEST_F(DataRequestHandlerTest, RequestedLengthGreaterThanBufferSize) {
-  std::vector<uint8_t> data(DataRequestHandler::kBufferSize * 2 + 1);
-  std::generate(data.begin(), data.end(), Generator());
-  data_source_.set_data(data);
-
-  ResourceLoadingDataRequest request;
-  request.length = data.size();
-
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(nil, request));
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(nil));
-
-  EXPECT_EQ(DataRequestHandler::SUCCESS, status(nil));
-  EXPECT_EQ(data, loaded_data());
-}
-
-TEST_F(DataRequestHandlerTest, LoadRangeOfDataSource) {
-  std::vector<uint8_t> data(DataRequestHandler::kBufferSize * 2 + 15);
-  std::generate(data.begin(), data.end(), Generator());
-  data_source_.set_data(data);
-
-  ResourceLoadingDataRequest request;
-  request.offset = 5;
-  request.length = data.size() - 10;
-
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(nil, request));
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(nil));
-
-  EXPECT_EQ(DataRequestHandler::SUCCESS, status(nil));
-
-  data.erase(data.begin(), data.begin() + 5);
-  data.erase(data.end() - 5, data.end());
-  EXPECT_EQ(data, loaded_data());
-}
-
-TEST_F(DataRequestHandlerTest, CanBeCanceled) {
-  // Pick IPCDataSource and data request sizes so that the IPCDataSource can't
-  // satisfy the request in one go.
-  std::vector<uint8_t> data(DataRequestHandler::kBufferSize * 2 + 15);
-  std::generate(data.begin(), data.end(), Generator());
-  data_source_.set_data(data);
-
-  ResourceLoadingDataRequest request;
-  request.length = data.size();
-
-  // Make sure our IPCDataSource will not respond with the first piece of data
-  // until we tell it to.
-  base::WaitableEvent unblock_data_source(true, false);
-  data_source_.set_blocked_on(&unblock_data_source);
-
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(nil, request));
-
-  dispatch_async(GetTestQueue(), ^{
-    handler_->CancelDataRequest(nil);
-  });
-
-  unblock_data_source.Signal();
-
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(nil));
-
-  EXPECT_EQ(DataRequestHandler::CANCELED, status(nil));
-}
-
-TEST_F(DataRequestHandlerTest, ConcurrentRequests) {
-  // Pick IPCDataSource and data request sizes so that the DataSource can't
-  // satisfy the request in one go.
-  ResourceLoadingDataRequest request;
-  request.length = DataRequestHandler::kBufferSize + 15;
-
-  std::vector<uint8_t> data(request.length * 2);
-  for (int i = 0; i < 2; ++i) {
-    std::fill(data.begin() + request.length * i,
-              data.begin() + request.length * (i + 1), i);
-  }
-  data_source_.set_data(data);
-
-  // Make sure our IPCDataSource will not respond with the first piece of data
-  // until we tell it to.  Set |manual_reset| to false so that our
-  // IPCDataSource blocks again after handling one Read().
-  base::WaitableEvent unblock_data_source(false, false);
-  data_source_.set_blocked_on(&unblock_data_source);
-
-  request.offset = 0;
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(@0, request));
-
-  // Tell IPCDataSource to handle exactly one Read().
-  unblock_data_source.Signal();
-  ASSERT_NO_FATAL_FAILURE(WaitUntilDataAvailable(@0));
-
-  ASSERT_FALSE(is_finished(@0));
-
-  request.offset = request.length;
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(@1, request));
-
-  // At this point, we should have 2 "concurrent" requests.
-
-  data_source_.set_blocked_on(nullptr);
-  unblock_data_source.Signal();
-
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(@1));
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(@0));
-
-  EXPECT_EQ(DataRequestHandler::SUCCESS, status(@0));
-  EXPECT_EQ(DataRequestHandler::SUCCESS, status(@1));
-
-  // This makes sure data is loaded from lowest offest to highest even when
-  // there are concurrent requests.
-  EXPECT_EQ(data, loaded_data());
-}
-
-TEST_F(DataRequestHandlerTest, ConcurrentRequestsError) {
-  data_source_.set_error(true);
-
-  ResourceLoadingDataRequest request;
-  request.length = DataRequestHandler::kBufferSize + 15;
-
-  // Make sure our IPCDataSource will not respond until we tell it to.
-  base::WaitableEvent unblock_data_source(true, false);
-  data_source_.set_blocked_on(&unblock_data_source);
-
-  request.offset = 0;
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(@0, request));
-  request.offset = request.length;
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(@1, request));
-
-  // At this point, we should have 2 "concurrent" requests.
-
-  unblock_data_source.Signal();
-
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(@0));
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(@1));
-
-  EXPECT_EQ(DataRequestHandler::ERROR, status(@0));
-  EXPECT_EQ(DataRequestHandler::ERROR, status(@1));
-}
-
-TEST_F(DataRequestHandlerTest, SuspendResume) {
-  std::vector<uint8_t> data(12);
-  std::generate(data.begin(), data.end(), Generator());
-  data_source_.set_data(data);
-
-  ResourceLoadingDataRequest request;
-  request.length = data.size();
-
-  // Make sure our IPCDataSource will not respond with the first piece of data
-  // until we tell it to.  Set |manual_reset| to false so that our
-  // IPCDataSource blocks again after handling one Read().
-  base::WaitableEvent unblock_data_source(false, false);
-  data_source_.set_blocked_on(&unblock_data_source);
-
-  data_source_.Suspend();
-
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(@0, request));
-
-  unblock_data_source.Signal();
-
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(@0));
-  EXPECT_EQ(DataRequestHandler::ERROR, status(@0));
-  EXPECT_TRUE(loaded_data().empty());
-
-  data_source_.Resume();
-
-  data_source_.set_blocked_on(nullptr);
-  unblock_data_source.Signal();
-
-  ASSERT_NO_FATAL_FAILURE(CallHandleDataRequest(@1, request));
-  ASSERT_NO_FATAL_FAILURE(WaitUntilFinished(@1));
-
-  EXPECT_EQ(DataRequestHandler::SUCCESS, status(@1));
-  EXPECT_EQ(data, loaded_data());
-}
-
-}  // namespace
-}  // namespace content
diff --git a/content/common/gpu/media/data_source_loader.h b/content/common/gpu/media/data_source_loader.h
deleted file mode 100644
index f931f81..0000000
--- a/content/common/gpu/media/data_source_loader.h
+++ /dev/null
@@ -1,44 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_DATA_SOURCE_LOADER_H_
-#define CONTENT_COMMON_GPU_MEDIA_DATA_SOURCE_LOADER_H_
-
-#import <AVFoundation/AVFoundation.h>
-
-#include "base/containers/scoped_ptr_hash_map.h"
-#include "base/mac/scoped_nsobject.h"
-#include "base/memory/ref_counted.h"
-#include "media/base/mac/avfoundation_glue.h"
-
-namespace content {
-class DataRequestHandler;
-class IPCDataSource;
-}  // namespace content
-
-@interface DataSourceLoader : NSObject<CrAVAssetResourceLoaderDelegate> {
- @private
-  base::scoped_nsobject<NSString> contentType_;
-  content::IPCDataSource* dataSource_;
-  dispatch_queue_t queue_;
-  scoped_refptr<content::DataRequestHandler> handler_;
-  base::scoped_nsobject<CrAVAssetResourceLoadingRequest> lastRequest_;
-}
-- (id)initWithDataSource:(content::IPCDataSource*)dataSource
-            withMIMEType:(NSString*)mimeType;
-
-- (void)stop;
-
-- (BOOL)resourceLoader:(CrAVAssetResourceLoader*)resourceLoader
-    shouldWaitForLoadingOfRequestedResource:
-        (CrAVAssetResourceLoadingRequest*)loadingRequest;
-- (void)resourceLoader:(CrAVAssetResourceLoader*)resourceLoader
-    didCancelLoadingRequest:(CrAVAssetResourceLoadingRequest*)loadingRequest;
-- (dispatch_queue_t)dispatchQueue;
-
-@end
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_DATA_SOURCE_LOADER_H_
diff --git a/content/common/gpu/media/data_source_loader.mm b/content/common/gpu/media/data_source_loader.mm
deleted file mode 100644
index 53bf153..0000000
--- a/content/common/gpu/media/data_source_loader.mm
+++ /dev/null
@@ -1,249 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "content/common/gpu/media/data_source_loader.h"
-
-#include <string>
-
-#include "base/bind.h"
-#include "base/callback.h"
-#include "base/logging.h"
-#include "base/mac/foundation_util.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/sys_string_conversions.h"
-#include "content/common/gpu/media/data_request_handler.h"
-#include "content/common/gpu/media/ipc_data_source.h"
-
-namespace content {
-namespace {
-
-void DataAvailable(id request_handle, uint8_t* data, int size) {
-  DVLOG(3) << "Responding to " << request_handle << " with " << size
-           << " bytes of data";
-
-  auto loading_request =
-      reinterpret_cast<CrAVAssetResourceLoadingRequest*>(request_handle);
-  NSData* ns_data =
-      [NSData dataWithBytesNoCopy:data length:size freeWhenDone:NO];
-  [[loading_request dataRequest] respondWithData:ns_data];
-}
-
-void LoadingFinished(id request_handle, DataRequestHandler::Status status) {
-  DVLOG(3) << "Signalling loading finished of " << request_handle << ": "
-           << status;
-
-  auto loading_request =
-      reinterpret_cast<CrAVAssetResourceLoadingRequest*>(request_handle);
-  DCHECK(![loading_request isFinished]);
-
-  switch (status) {
-    case DataRequestHandler::SUCCESS:
-      [loading_request finishLoading];
-      break;
-
-    case DataRequestHandler::ERROR:
-      [loading_request
-          finishLoadingWithError:[NSError errorWithDomain:NSPOSIXErrorDomain
-                                                     code:EIO
-                                                 userInfo:nil]];
-      break;
-
-    case DataRequestHandler::CANCELED:
-      // Nothing to do.
-      break;
-
-    default:
-      NOTREACHED();
-  }
-}
-
-}  // namespace
-}  // namespace content
-
-namespace {
-
-std::string ToHumanReadableString(
-    CrAVAssetResourceLoadingRequest* loadingRequest) {
-  CrAVAssetResourceLoadingDataRequest* dataRequest =
-      [loadingRequest dataRequest];
-  return base::StringPrintf(
-      "requested offset: %lld, requested length: %lld, current offset: %lld",
-      [dataRequest requestedOffset],
-      base::checked_cast<int64_t>([dataRequest requestedLength]),
-      [dataRequest currentOffset]);
-}
-
-}  // namespace
-
-
-@interface DataSourceLoader()
-
-- (int64_t)lastOffset;
-
-@end
-
-@implementation DataSourceLoader
-
-- (id)initWithDataSource:(content::IPCDataSource*)dataSource
-            withMIMEType:(NSString*)mimeType {
-  if ((self = [super init])) {
-    contentType_.reset(
-        base::mac::CFToNSCast(UTTypeCreatePreferredIdentifierForTag(
-            kUTTagClassMIMEType, base::mac::NSToCFCast(mimeType), nullptr)));
-    // From Apple documentation, "If no result is found, this function creates
-    // a dynamic type beginning with the dyn prefix".
-    if ([contentType_ hasPrefix:@"dyn"]) {
-      // If MIME type was not recognized, fall back to something that we know
-      // works well for most of the media that DataSourceLoader needs to work
-      // with.
-      contentType_.reset(@"public.mpeg-4");
-    }
-    DVLOG(1) << "Resolved '" << base::SysNSStringToUTF8(mimeType) << "' as '"
-             << base::SysNSStringToUTF8(contentType_) << "'";
-
-    dataSource_ = dataSource;
-
-    queue_ = dispatch_queue_create("com.operasoftware.DataSourceLoader",
-                                   DISPATCH_QUEUE_SERIAL);
-
-    handler_ = new content::DataRequestHandler(
-        dataSource_, base::Bind(&content::DataAvailable),
-        base::Bind(&content::LoadingFinished), queue_);
-  }
-  return self;
-}
-
-- (void)stop {
-  DCHECK(queue_ != dispatch_get_current_queue());
-
-  // Stop the data source while not on the dispatch queue to unblock any
-  // pending DataRequestHandlers.
-  dataSource_->Stop();
-
-  dispatch_sync(queue_, ^{
-      // We will not accept further data requests.
-      dataSource_ = nullptr;
-
-      handler_->AbortAllDataRequests();
-  });
-}
-
-- (bool)isStopped {
-  return dataSource_ == nullptr;
-}
-
-- (void)dealloc {
-  DVLOG(1) << "~DataSourceLoader()";
-  DCHECK([self isStopped]);
-
-  dispatch_release(queue_);
-  [super dealloc];
-}
-
-- (void)fillContentInformation:
-            (CrAVAssetResourceLoadingContentInformationRequest*)
-        contentInformationRequest {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  [contentInformationRequest setByteRangeAccessSupported:YES];
-  [contentInformationRequest setContentType:contentType_];
-
-  int64_t length = -1;
-  if (!dataSource_->GetSize(&length)) {
-    // DataSource size is unknown, but we have to set _some_ content length or
-    // the resource loader will not ask for more data.  On the one hand, we
-    // want the greatest value possible here.  On the other hand, the resource
-    // loader also bails out if the value is too big.
-    length = 4ll * 1024 * 1024 * 1024 * 1024;
-  }
-
-  [contentInformationRequest setContentLength:length];
-}
-
-- (void)handleRequest:(CrAVAssetResourceLoadingRequest*)loadingRequest {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  if ([loadingRequest contentInformationRequest])
-    [self fillContentInformation:[loadingRequest contentInformationRequest]];
-
-  if (![loadingRequest dataRequest]) {
-    DVLOG(1) << "No data request.";
-    [loadingRequest finishLoading];
-    return;
-  }
-
-  if (dataSource_->IsStreaming()) {
-    // We are streaming, so no concurrent requests and no reading in future.
-    // The only exception is the special request for bytes 0-1 the resource
-    // loader always makes.
-    const bool requesting_future_data =
-        [[loadingRequest dataRequest] requestedOffset] > [self lastOffset] + 1;
-    if (handler_->IsHandlingDataRequests() ||
-        ([self lastOffset] > 2 && requesting_future_data)) {
-      DVLOG(1) << "Request rejected due to streaming restrictions";
-      [loadingRequest
-          finishLoadingWithError:[NSError errorWithDomain:NSPOSIXErrorDomain
-                                                     code:EIO
-                                                 userInfo:nil]];
-      return;
-    }
-  }
-
-  DVLOG(1) << "New request from resource loader: "
-           << ToHumanReadableString(loadingRequest);
-  lastRequest_.reset([loadingRequest retain]);
-  handler_->HandleDataRequest(
-      loadingRequest,
-      content::ResourceLoadingDataRequest([loadingRequest dataRequest]));
-}
-
-- (BOOL)resourceLoader:(CrAVAssetResourceLoader*)resourceLoader
-    shouldWaitForLoadingOfRequestedResource:
-        (CrAVAssetResourceLoadingRequest*)loadingRequest {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  if ([self isStopped])
-    return NO;
-
-  DVLOG(1) << [[[[loadingRequest request] URL] absoluteString] UTF8String];
-  [[[loadingRequest request] allHTTPHeaderFields]
-      enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL* stop) {
-          DVLOG(1) << [base::mac::ObjCCast<NSString>(key) UTF8String] << ": "
-                   << [base::mac::ObjCCast<NSString>(value) UTF8String];
-      }];
-
-  [self handleRequest:loadingRequest];
-
-  return YES;
-}
-
-- (void)resourceLoader:(CrAVAssetResourceLoader*)resourceLoader
-    didCancelLoadingRequest:(CrAVAssetResourceLoadingRequest*)loadingRequest {
-  DCHECK(queue_ == dispatch_get_current_queue());
-
-  if ([self isStopped])
-    return;
-
-  // Sometimes, the resource loader cancels requests that have finished (and
-  // then we may have pruned them.)
-  if (![loadingRequest isFinished]) {
-    DVLOG(1) << "Resource loader is canceling request: "
-             << ToHumanReadableString(loadingRequest);
-    handler_->CancelDataRequest(loadingRequest);
-  }
-}
-
-- (dispatch_queue_t)dispatchQueue {
-  DCHECK(queue_);
-  return queue_;
-}
-
-- (int64_t)lastOffset {
-  return lastRequest_ ? [[lastRequest_ dataRequest] currentOffset] - 1 : -1;
-}
-
-@end
diff --git a/content/common/gpu/media/ipc_audio_decoder_unittest.cc b/content/common/gpu/media/ipc_audio_decoder_unittest.cc
deleted file mode 100644
index 115472d..0000000
--- a/content/common/gpu/media/ipc_audio_decoder_unittest.cc
+++ /dev/null
@@ -1,148 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is based on
-// chromium\src\media\filters\audio_file_reader_unittest.cc.
-
-#include "base/bind.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/threading/thread.h"
-#include "content/common/gpu/media/test_pipeline_host.h"
-#include "media/base/audio_bus.h"
-#include "media/base/audio_hash.h"
-#include "media/base/decoder_buffer.h"
-#include "media/base/test_data_util.h"
-#include "media/filters/in_memory_url_protocol.h"
-#include "media/filters/ipc_audio_decoder.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace content {
-
-namespace {
-scoped_ptr<media::IPCMediaPipelineHost> CreateIPCMediaPipelineHost(
-    const scoped_refptr<base::SequencedTaskRunner>& decode_task_runner,
-    media::DataSource* data_source) {
-  return make_scoped_ptr(new TestPipelineHost(data_source));
-}
-}  // namespace
-
-class IPCAudioDecoderTest : public testing::Test {
- public:
-  IPCAudioDecoderTest() : decode_thread_(__FUNCTION__) {
-    if (!media::IPCAudioDecoder::IsAvailable())
-      return;
-
-    CHECK(decode_thread_.Start());
-
-    media::IPCAudioDecoder::Preinitialize(
-        base::Bind(&CreateIPCMediaPipelineHost), decode_thread_.task_runner(),
-        decode_thread_.task_runner());
-  }
-
-  bool Initialize(const std::string& filename) {
-    if (!media::IPCAudioDecoder::IsAvailable()) {
-      LOG(INFO)
-          << "IPCAudioDecoder not available on this platform, skipping test";
-      return false;
-    }
-
-    data_ = media::ReadTestDataFile(filename);
-    protocol_.reset(new media::InMemoryUrlProtocol(data_->data(),
-                                                   data_->data_size(), false));
-    decoder_.reset(new media::IPCAudioDecoder(protocol_.get()));
-    return true;
-  }
-
-  // Reads the entire file provided to Initialize().
-  void ReadAndVerify(const std::string& expected_audio_hash,
-                     int expected_frames) {
-    scoped_ptr<media::AudioBus> decoded_audio_data = media::AudioBus::Create(
-        decoder_->channels(), decoder_->number_of_frames());
-    const int actual_frames = decoder_->Read(decoded_audio_data.get());
-
-    ASSERT_LE(actual_frames, decoded_audio_data->frames());
-    ASSERT_EQ(expected_frames, actual_frames);
-
-    media::AudioHash audio_hash;
-    audio_hash.Update(decoded_audio_data.get(), actual_frames);
-    EXPECT_EQ(expected_audio_hash, audio_hash.ToString());
-  }
-
-  void RunTest(const std::string& filename,
-               const std::string& hash,
-               int channels,
-               int sample_rate,
-               base::TimeDelta duration,
-               int frames,
-               int trimmed_frames) {
-    if (!Initialize(filename))
-      return;
-
-    ASSERT_TRUE(decoder_->Initialize());
-
-    EXPECT_EQ(channels, decoder_->channels());
-    EXPECT_EQ(sample_rate, decoder_->sample_rate());
-    EXPECT_EQ(duration.InMicroseconds(), decoder_->duration().InMicroseconds());
-    EXPECT_EQ(frames, decoder_->number_of_frames());
-    ReadAndVerify(hash, trimmed_frames);
-  }
-
-  void RunTestFailingInitialization(const std::string& filename) {
-    if (!Initialize(filename))
-      return;
-
-    Initialize(filename);
-    EXPECT_FALSE(decoder_->Initialize());
-  }
-
- private:
-  base::Thread decode_thread_;
-  scoped_refptr<media::DecoderBuffer> data_;
-  scoped_ptr<media::InMemoryUrlProtocol> protocol_;
-  scoped_ptr<media::IPCAudioDecoder> decoder_;
-
-  DISALLOW_COPY_AND_ASSIGN(IPCAudioDecoderTest);
-};
-
-// Note: The expected results are partly decoder-dependent.  The same
-// differences in duration, etc., occur when decoding via IPCDemuxer.
-
-TEST_F(IPCAudioDecoderTest, MP3) {
-  RunTest("sfx.mp3",
-#if defined(OS_MACOSX)
-          "0.83,1.07,2.28,3.57,3.98,3.20,", 1, 44100,
-          base::TimeDelta::FromMicroseconds(287346), 12672, 12672);
-#elif defined(OS_WIN)
-          "0.35,1.24,2.97,4.28,4.18,2.75,", 1, 44100,
-          base::TimeDelta::FromMicroseconds(313469), 13824, 13824);
-#endif
-}
-
-TEST_F(IPCAudioDecoderTest, CorruptMP3) {
-  RunTest("corrupt.mp3",
-#if defined(OS_MACOSX)
-          "-2.44,-0.74,1.48,2.49,1.45,-1.47,", 1, 44100,
-          base::TimeDelta::FromMicroseconds(1018775), 44928, 44928);
-#elif defined(OS_WIN)
-          "-5.04,-3.03,-0.53,1.08,0.23,-2.29,", 1, 44100,
-          base::TimeDelta::FromMicroseconds(1018800), 44930, 44928);
-#endif
-}
-
-TEST_F(IPCAudioDecoderTest, AAC) {
-  RunTest("sfx.m4a",
-#if defined(OS_MACOSX)
-          "-5.29,-5.47,-5.05,-4.33,-2.99,-3.79,", 1, 44100,
-          base::TimeDelta::FromMicroseconds(312000), 13760, 11200);
-#elif defined(OS_WIN)
-          "2.62,3.23,2.38,2.56,2.75,2.73,", 1, 44100,
-          base::TimeDelta::FromMicroseconds(312000), 13760, 13760);
-#endif
-}
-
-TEST_F(IPCAudioDecoderTest, InvalidFile) {
-  RunTestFailingInitialization("ten_byte_file");
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/ipc_data_source.h b/content/common/gpu/media/ipc_data_source.h
deleted file mode 100644
index 0bd8e3b..0000000
--- a/content/common/gpu/media/ipc_data_source.h
+++ /dev/null
@@ -1,27 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_IPC_DATA_SOURCE_H_
-#define CONTENT_COMMON_GPU_MEDIA_IPC_DATA_SOURCE_H_
-
-#include "media/base/data_source.h"
-
-namespace content {
-
-// A DataSource that can be suspended and resumed.
-class IPCDataSource : public media::DataSource {
- public:
-  enum { kReadInterrupted = -2 };
-
-  // Suspend and resume the data source.  While an IPCDataSource is suspended,
-  // all reads return |kReadInterrupted|.
-  virtual void Suspend() = 0;
-  virtual void Resume() = 0;
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_IPC_DATA_SOURCE_H_
diff --git a/content/common/gpu/media/ipc_data_source_impl.cc b/content/common/gpu/media/ipc_data_source_impl.cc
deleted file mode 100644
index 1e55494..0000000
--- a/content/common/gpu/media/ipc_data_source_impl.cc
+++ /dev/null
@@ -1,198 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/ipc_data_source_impl.h"
-
-#include <algorithm>
-
-#include "base/memory/scoped_ptr.h"
-#include "base/numerics/safe_conversions.h"
-#include "content/common/media/media_pipeline_messages.h"
-#include "ipc/ipc_sender.h"
-
-namespace content {
-
-class IPCDataSourceImpl::ReadOperation {
- public:
-  ReadOperation(int64_t position,
-                int size,
-                uint8_t* data,
-                const ReadCB& callback)
-      : position_(position), size_(size), data_(data), callback_(callback) {}
-
-  // Fills |data_| with |size_read| bytes from |data_read| and runs
-  // |callback_|, deleting the operation afterwards.
-  static void Finish(scoped_ptr<ReadOperation> operation,
-                     const uint8_t* data_read,
-                     int size_read) {
-    if (size_read > 0) {
-      DCHECK_LE(size_read, operation->size_);
-      std::copy(data_read, data_read + size_read, operation->data_);
-    }
-
-    operation->callback_.Run(size_read);
-  }
-
-  int64_t position() const { return position_; }
-  int size() const { return size_; }
-
- private:
-  int64_t position_;
-  int size_;
-  uint8_t* data_;
-  ReadCB callback_;
-};
-
-IPCDataSourceImpl::IPCDataSourceImpl(IPC::Sender* channel,
-                                     int32_t routing_id,
-                                     int64_t size,
-                                     bool streaming)
-    : channel_(channel),
-      routing_id_(routing_id),
-      size_(size),
-      streaming_(streaming),
-      stopped_(false),
-      suspended_(false),
-      should_discard_next_buffer_(false) {
-  DCHECK(channel_);
-}
-
-IPCDataSourceImpl::~IPCDataSourceImpl() = default;
-
-void IPCDataSourceImpl::Suspend() {
-  DVLOG(1) << __FUNCTION__;
-
-  base::AutoLock auto_lock(lock_);
-  suspended_ = true;
-  should_discard_next_buffer_ = read_operation_.get() != NULL;
-}
-
-void IPCDataSourceImpl::Resume() {
-  DVLOG(1) << __FUNCTION__;
-
-  base::AutoLock auto_lock(lock_);
-  suspended_ = false;
-}
-
-void IPCDataSourceImpl::Read(int64_t position,
-                             int size,
-                             uint8_t* data,
-                             const ReadCB& read_cb) {
-  DCHECK_GE(size, 0);
-  {
-    base::AutoLock auto_lock(lock_);
-
-    if (stopped_ || suspended_) {
-      read_cb.Run(stopped_ ? kReadError : kReadInterrupted);
-      return;
-    }
-
-    DCHECK(read_operation_.get() == NULL);
-    read_operation_.reset(new ReadOperation(position, size, data, read_cb));
-  }
-
-  if (shared_data_ &&
-      shared_data_->mapped_size() >= base::saturated_cast<size_t>(size)) {
-    channel_->Send(
-        new MediaPipelineMsg_ReadRawData(routing_id_, position, size));
-  } else {
-    channel_->Send(
-        new MediaPipelineMsg_RequestBufferForRawData(routing_id_, size));
-  }
-}
-
-void IPCDataSourceImpl::Stop() {
-  {
-    base::AutoLock auto_lock(lock_);
-
-    if (stopped_)
-      return;
-
-    if (read_operation_.get() != NULL)
-      ReadOperation::Finish(std::move(read_operation_), NULL, kReadError);
-
-    stopped_ = true;
-  }
-}
-
-bool IPCDataSourceImpl::GetSize(int64_t* size) {
-  *size = size_;
-  return size_ >= 0;
-}
-
-bool IPCDataSourceImpl::IsStreaming() {
-  return streaming_;
-}
-
-void IPCDataSourceImpl::SetBitrate(int bitrate) {
-  NOTREACHED();
-}
-
-void IPCDataSourceImpl::OnBufferForRawDataReady(
-    size_t buffer_size,
-    base::SharedMemoryHandle handle) {
-  if (read_operation_.get() == NULL) {
-    DLOG(ERROR) << "Received buffer while no read operation is in progress.";
-    return;
-  }
-
-  if (!base::SharedMemory::IsHandleValid(handle)) {
-    ReadOperation::Finish(std::move(read_operation_), NULL, kReadError);
-    return;
-  }
-
-  if (base::saturated_cast<int>(buffer_size) < read_operation_->size()) {
-    DLOG(ERROR) << "Received buffer is too small.";
-    ReadOperation::Finish(std::move(read_operation_), NULL, kReadError);
-    return;
-  }
-
-  shared_data_.reset(new base::SharedMemory(handle, true));
-  if (!shared_data_->Map(buffer_size)) {
-    ReadOperation::Finish(std::move(read_operation_), NULL, kReadError);
-    return;
-  }
-
-  channel_->Send(new MediaPipelineMsg_ReadRawData(
-      routing_id_, read_operation_->position(), read_operation_->size()));
-}
-
-void IPCDataSourceImpl::OnRawDataReady(int size) {
-  {
-    base::AutoLock auto_lock(lock_);
-
-    if (stopped_)
-      return;
-
-    if (should_discard_next_buffer_) {
-      DCHECK(read_operation_);
-      should_discard_next_buffer_ = false;
-      ReadOperation::Finish(std::move(read_operation_), NULL, kReadInterrupted);
-      return;
-    }
-
-    if (read_operation_.get() == NULL) {
-      DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-      return;
-    }
-
-    if (size > 0) {
-      if (shared_data_.get() != NULL &&
-          base::saturated_cast<int>(shared_data_->mapped_size()) >= size) {
-        ReadOperation::Finish(std::move(read_operation_),
-                              static_cast<uint8_t*>(shared_data_->memory()),
-                              size);
-        return;
-      }
-
-      size = kReadError;
-    }
-
-    ReadOperation::Finish(std::move(read_operation_), NULL, size);
-  }
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/ipc_data_source_impl.h b/content/common/gpu/media/ipc_data_source_impl.h
deleted file mode 100644
index 3908093..0000000
--- a/content/common/gpu/media/ipc_data_source_impl.h
+++ /dev/null
@@ -1,78 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_IPC_DATA_SOURCE_IMPL_H_
-#define CONTENT_COMMON_GPU_MEDIA_IPC_DATA_SOURCE_IMPL_H_
-
-#include "base/memory/scoped_ptr.h"
-#include "base/memory/shared_memory.h"
-#include "base/synchronization/lock.h"
-#include "content/common/gpu/media/ipc_data_source.h"
-
-namespace IPC {
-class Sender;
-}
-
-namespace content {
-
-// An IPCDataSource that satisfies read requests with data obtained via IPC
-// from the render process.
-class IPCDataSourceImpl : public IPCDataSource {
- public:
-  // Passing a value <0 for |size| indicates the size is unknown (|GetSize()|
-  // will return false).
-  IPCDataSourceImpl(IPC::Sender* channel,
-                    int32_t routing_id,
-                    int64_t size,
-                    bool streaming);
-  ~IPCDataSourceImpl() override;
-
-  // IPCDataSource implementation.
-  void Suspend() override;
-  void Resume() override;
-
-  // media::DataSource implementation.
-  void Read(int64_t position,
-            int size,
-            uint8_t* data,
-            const ReadCB& read_cb) override;
-  void Stop() override;
-  bool GetSize(int64_t* size_out) override;
-  bool IsStreaming() override;
-  void SetBitrate(int bitrate) override;
-
-  void OnBufferForRawDataReady(size_t buffer_size,
-                               base::SharedMemoryHandle handle);
-  void OnRawDataReady(int size);
-
- private:
-  IPC::Sender* const channel_;
-  const int32_t routing_id_;
-
-  const int64_t size_;
-  const bool streaming_;
-
-  class ReadOperation;
-  scoped_ptr<ReadOperation> read_operation_;
-
-  bool stopped_;
-  bool suspended_;
-  bool should_discard_next_buffer_;
-
-  // Used to protect access to |read_operation_|, |stopped_|, |suspended_|, and
-  // |should_discard_next_buffer_|.
-  base::Lock lock_;
-
-  // A buffer for raw media data, shared with the render process.  Filled in the
-  // render process, consumed in the GPU process.
-  scoped_ptr<base::SharedMemory> shared_data_;
-
-  DISALLOW_COPY_AND_ASSIGN(IPCDataSourceImpl);
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_IPC_DATA_SOURCE_IMPL_H_
diff --git a/content/common/gpu/media/ipc_media_pipeline.cc b/content/common/gpu/media/ipc_media_pipeline.cc
deleted file mode 100644
index 25d72e4..0000000
--- a/content/common/gpu/media/ipc_media_pipeline.cc
+++ /dev/null
@@ -1,400 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/ipc_media_pipeline.h"
-
-#include <algorithm>
-
-#include "base/command_line.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/trace_event/trace_event.h"
-#include "gpu/ipc/service/gpu_command_buffer_stub.h"
-#include "content/common/gpu/media/ipc_data_source_impl.h"
-#include "content/common/gpu/media/platform_media_pipeline.h"
-#include "content/common/media/media_pipeline_messages.h"
-#include "gpu/command_buffer/service/texture_manager.h"
-#include "ipc/ipc_sender.h"
-#include "media/base/data_buffer.h"
-#include "media/filters/platform_media_pipeline_constants.h"
-#include "media/filters/platform_media_pipeline_types.h"
-#include "ui/gl/gl_surface_egl.h"
-
-namespace {
-
-const char* const kDecodedDataReadTraceEventNames[] = {"GPU ReadAudioData",
-                                                       "GPU ReadVideoData"};
-static_assert(arraysize(kDecodedDataReadTraceEventNames) ==
-                  static_cast<size_t>(media::PlatformMediaDecodingMode::COUNT),
-              "Incorrect number of defined tracing event names.");
-
-bool MakeDecoderContextCurrent(
-    const base::WeakPtr<gpu::GpuCommandBufferStub>& command_buffer) {
-  if (!command_buffer) {
-    DLOG(ERROR) << "Command buffer missing, can't make GL context current.";
-    return false;
-  }
-
-  if (!command_buffer->decoder()->MakeCurrent()) {
-    DLOG(ERROR) << "Failed to make GL context current.";
-    return false;
-  }
-
-  return true;
-}
-
-}  // namespace
-
-namespace content {
-
-IPCMediaPipeline::IPCMediaPipeline(IPC::Sender* channel,
-                                   int32_t routing_id,
-                                   gpu::GpuCommandBufferStub* command_buffer)
-    : state_(CONSTRUCTED),
-      channel_(channel),
-      routing_id_(routing_id),
-      command_buffer_(command_buffer),
-      weak_ptr_factory_(this) {
-  DCHECK(channel_);
-
-  std::fill(has_media_type_,
-            has_media_type_ +
-                static_cast<size_t>(media::PlatformMediaDecodingMode::COUNT),
-            false);
-}
-
-IPCMediaPipeline::~IPCMediaPipeline() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-}
-
-void IPCMediaPipeline::OnInitialize(int64_t data_source_size,
-                                    bool is_data_source_streaming,
-                                    const std::string& mime_type) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (state_ != CONSTRUCTED) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    return;
-  }
-  state_ = BUSY;
-
-  data_source_.reset(new IPCDataSourceImpl(
-      channel_, routing_id_, data_source_size, is_data_source_streaming));
-
-  media::PlatformMediaDecodingMode preferred_video_decoding_mode =
-      media::PlatformMediaDecodingMode::SOFTWARE;
-  PlatformMediaPipeline::MakeGLContextCurrentCB make_gl_context_current_cb;
-  if (command_buffer_) {
-    preferred_video_decoding_mode = media::PlatformMediaDecodingMode::HARDWARE;
-    make_gl_context_current_cb =
-        base::Bind(&MakeDecoderContextCurrent, command_buffer_->AsWeakPtr());
-  }
-
-  media_pipeline_.reset(PlatformMediaPipeline::Create(
-      data_source_.get(), base::Bind(&IPCMediaPipeline::OnAudioConfigChanged,
-                                     weak_ptr_factory_.GetWeakPtr()),
-      base::Bind(&IPCMediaPipeline::OnVideoConfigChanged,
-                 weak_ptr_factory_.GetWeakPtr()),
-      preferred_video_decoding_mode, make_gl_context_current_cb));
-
-  media_pipeline_->Initialize(mime_type,
-                              base::Bind(&IPCMediaPipeline::Initialized,
-                                         weak_ptr_factory_.GetWeakPtr()));
-}
-
-void IPCMediaPipeline::Initialized(
-    bool success,
-    int bitrate,
-    const media::PlatformMediaTimeInfo& time_info,
-    const media::PlatformAudioConfig& audio_config,
-    const media::PlatformVideoConfig& video_config) {
-  DVLOG(1) << __FUNCTION__ << "(" << success << ")";
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK_EQ(state_, BUSY);
-
-  has_media_type_[media::PLATFORM_MEDIA_AUDIO] = audio_config.is_valid();
-  has_media_type_[media::PLATFORM_MEDIA_VIDEO] = video_config.is_valid();
-  if (has_media_type_[media::PLATFORM_MEDIA_VIDEO])
-    video_config_ = video_config;
-
-  channel_->Send(new MediaPipelineMsg_Initialized(
-      routing_id_, success, bitrate, time_info, audio_config, video_config));
-
-  state_ = success ? DECODING : STOPPED;
-}
-
-void IPCMediaPipeline::OnBufferForDecodedDataReady(
-    media::PlatformMediaDataType type,
-    size_t buffer_size,
-    base::SharedMemoryHandle handle) {
-  if (!pending_output_buffers_[type]) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    DecodedDataReady(type, nullptr);
-    return;
-  }
-
-  DCHECK(!pending_output_buffers_[type]->end_of_stream());
-
-  if (base::SharedMemory::IsHandleValid(handle)) {
-    shared_decoded_data_[type].reset(new base::SharedMemory(handle, false));
-    if (!shared_decoded_data_[type]->Map(buffer_size) ||
-        shared_decoded_data_[type]->mapped_size() <
-            base::saturated_cast<size_t>(
-                pending_output_buffers_[type]->data_size())) {
-      shared_decoded_data_[type].reset(nullptr);
-    }
-  } else {
-    shared_decoded_data_[type].reset(nullptr);
-  }
-
-  scoped_refptr<media::DataBuffer> buffer;
-  if (shared_decoded_data_[type])
-    buffer = pending_output_buffers_[type];
-  pending_output_buffers_[type] = nullptr;
-
-  DecodedDataReady(type, buffer);
-}
-
-void IPCMediaPipeline::DecodedDataReady(
-    media::PlatformMediaDataType type,
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(!is_handling_accelerated_video_decode(type));
-
-  const uint32_t dummy_client_texture_id = 0;
-  DecodedDataReadyImpl(type, dummy_client_texture_id, buffer);
-}
-
-void IPCMediaPipeline::DecodedTextureReady(
-    uint32_t client_texture_id,
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(is_handling_accelerated_video_decode(media::PLATFORM_MEDIA_VIDEO));
-
-  DecodedDataReadyImpl(media::PLATFORM_MEDIA_VIDEO, client_texture_id, buffer);
-}
-
-void IPCMediaPipeline::DecodedDataReadyImpl(
-    media::PlatformMediaDataType type,
-    uint32_t client_texture_id,
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK_EQ(state_, DECODING);
-  DCHECK(!pending_output_buffers_[type]);
-
-  MediaPipelineMsg_DecodedDataReady_Params reply_params;
-  reply_params.type = type;
-
-  if (buffer.get() == NULL) {
-    reply_params.status = media::kError;
-  } else if (buffer->end_of_stream()) {
-    reply_params.status = media::kEOS;
-  } else {
-    if (is_handling_accelerated_video_decode(type)) {
-      reply_params.client_texture_id = client_texture_id;
-    } else {
-      if (!shared_decoded_data_[type] ||
-          base::saturated_cast<int>(shared_decoded_data_[type]->mapped_size()) <
-              buffer->data_size()) {
-        pending_output_buffers_[type] = buffer;
-        channel_->Send(new MediaPipelineMsg_RequestBufferForDecodedData(
-            routing_id_, type, buffer->data_size()));
-        return;
-      }
-
-      memcpy(shared_decoded_data_[type]->memory(), buffer->data(),
-             buffer->data_size());
-    }
-
-    reply_params.size = buffer->data_size();
-    reply_params.status = media::kOk;
-    reply_params.timestamp = buffer->timestamp();
-    reply_params.duration = buffer->duration();
-  }
-
-  channel_->Send(
-      new MediaPipelineMsg_DecodedDataReady(routing_id_, reply_params));
-
-  TRACE_EVENT_ASYNC_END0(
-      "IPC_MEDIA", kDecodedDataReadTraceEventNames[type], this);
-}
-
-void IPCMediaPipeline::OnAudioConfigChanged(
-    const media::PlatformAudioConfig& audio_config) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK_EQ(state_, DECODING);
-  DCHECK(audio_config.is_valid());
-
-  channel_->Send(
-      new MediaPipelineMsg_AudioConfigChanged(routing_id_, audio_config));
-}
-
-void IPCMediaPipeline::OnVideoConfigChanged(
-    const media::PlatformVideoConfig& video_config) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK_EQ(state_, DECODING);
-  DCHECK(video_config.is_valid());
-
-  video_config_ = video_config;
-
-  channel_->Send(
-      new MediaPipelineMsg_VideoConfigChanged(routing_id_, video_config));
-}
-
-void IPCMediaPipeline::OnWillSeek() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  media_pipeline_->WillSeek();
-}
-
-void IPCMediaPipeline::OnSeek(base::TimeDelta time) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (state_ != DECODING) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    return;
-  }
-  state_ = BUSY;
-
-  media_pipeline_->Seek(
-      time,
-      base::Bind(&IPCMediaPipeline::SeekDone, weak_ptr_factory_.GetWeakPtr()));
-}
-
-void IPCMediaPipeline::SeekDone(bool success) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK_EQ(state_, BUSY);
-
-  channel_->Send(new MediaPipelineMsg_Sought(routing_id_, success));
-
-  state_ = DECODING;
-}
-
-void IPCMediaPipeline::OnStop() {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  media_pipeline_.reset();
-
-  // We must not accept any reply callbacks once we are in the STOPPED state.
-  weak_ptr_factory_.InvalidateWeakPtrs();
-
-  state_ = STOPPED;
-}
-
-bool IPCMediaPipeline::OnMessageReceived(const IPC::Message& msg) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  bool handled = true;
-  TRACE_EVENT0("IPC_MEDIA", "IPCMediaPipeline::OnMessageReceived");
-  IPC_BEGIN_MESSAGE_MAP(IPCMediaPipeline, msg)
-    IPC_MESSAGE_FORWARD(MediaPipelineMsg_BufferForRawDataReady,
-                        data_source_.get(),
-                        IPCDataSourceImpl::OnBufferForRawDataReady)
-    IPC_MESSAGE_FORWARD(MediaPipelineMsg_RawDataReady,
-                        data_source_.get(),
-                        IPCDataSourceImpl::OnRawDataReady)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_BufferForDecodedDataReady,
-                        OnBufferForDecodedDataReady)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_ReadDecodedData, OnReadDecodedData)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_Initialize, OnInitialize)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_WillSeek, OnWillSeek)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_Seek, OnSeek)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_Stop, OnStop)
-    IPC_MESSAGE_UNHANDLED(handled = false)
-  IPC_END_MESSAGE_MAP()
-  DCHECK(handled) << msg.type();
-  return handled;
-}
-
-void IPCMediaPipeline::OnReadDecodedData(media::PlatformMediaDataType type,
-                                         uint32_t client_texture_id) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  TRACE_EVENT0("IPC_MEDIA", "IPCMediaPipeline::OnReadDecodedData");
-
-  if (state_ != DECODING) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    return;
-  }
-  if (!has_media_type(type)) {
-    DLOG(ERROR) << "No data of given media type (" << type << ") to decode";
-    return;
-  }
-
-  TRACE_EVENT_ASYNC_BEGIN0(
-      "IPC_MEDIA", kDecodedDataReadTraceEventNames[type], this);
-
-  if (is_handling_accelerated_video_decode(type)) {
-    uint32_t service_texture_id = 0;
-    if (!ClientToServiceTextureId(client_texture_id, &service_texture_id)) {
-      DLOG(ERROR) << "Error while translating texture ID=" << client_texture_id;
-      DecodedTextureReady(client_texture_id, nullptr);
-      return;
-    }
-    media_pipeline_->ReadVideoData(
-        base::Bind(&IPCMediaPipeline::DecodedTextureReady,
-                   weak_ptr_factory_.GetWeakPtr(), client_texture_id),
-        service_texture_id);
-    return;
-  }
-
-  const auto read_cb = base::Bind(&IPCMediaPipeline::DecodedDataReady,
-                                  weak_ptr_factory_.GetWeakPtr(), type);
-  if (type == media::PLATFORM_MEDIA_AUDIO) {
-    media_pipeline_->ReadAudioData(read_cb);
-  } else {
-    const uint32_t dummy_service_texture_id = 0;
-    media_pipeline_->ReadVideoData(read_cb, dummy_service_texture_id);
-  }
-}
-
-bool IPCMediaPipeline::ClientToServiceTextureId(uint32_t client_texture_id,
-                                                uint32_t* service_texture_id) {
-  auto it = known_picture_buffers_.find(client_texture_id);
-  if (it != known_picture_buffers_.end()) {
-    *service_texture_id = it->second;
-    return true;
-  }
-
-  if (!MakeDecoderContextCurrent(command_buffer_->AsWeakPtr()))
-    return false;
-
-  gpu::gles2::GLES2Decoder* command_decoder = command_buffer_->decoder();
-  gpu::gles2::TextureManager* texture_manager =
-      command_decoder->GetContextGroup()->texture_manager();
-
-  gpu::gles2::TextureRef* texture_ref =
-      texture_manager->GetTexture(client_texture_id);
-  if (!texture_ref) {
-    DLOG(ERROR) << "Failed to find texture ID";
-    return false;
-  }
-
-  gpu::gles2::Texture* info = texture_ref->texture();
-  if (info->target() != media::kPlatformMediaPipelineTextureTarget) {
-    DLOG(ERROR) << "Texture target mismatch";
-    return false;
-  }
-
-  texture_manager->SetLevelInfo(
-      texture_ref, media::kPlatformMediaPipelineTextureTarget, 0,
-      media::kPlatformMediaPipelineTextureFormat,
-      video_config_.coded_size.width(), video_config_.coded_size.height(), 1, 0,
-      media::kPlatformMediaPipelineTextureFormat, 0, gfx::Rect());
-
-  if (!command_decoder->GetServiceTextureId(client_texture_id,
-                                            service_texture_id)) {
-    DLOG(ERROR) << "Failed to translate texture ID";
-    return false;
-  }
-
-  known_picture_buffers_[client_texture_id] = *service_texture_id;
-  return true;
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/ipc_media_pipeline.h b/content/common/gpu/media/ipc_media_pipeline.h
deleted file mode 100644
index ee868b5..0000000
--- a/content/common/gpu/media/ipc_media_pipeline.h
+++ /dev/null
@@ -1,150 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_IPC_MEDIA_PIPELINE_H_
-#define CONTENT_COMMON_GPU_MEDIA_IPC_MEDIA_PIPELINE_H_
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "base/memory/shared_memory.h"
-#include "base/memory/weak_ptr.h"
-#include "base/threading/thread_checker.h"
-#include "content/common/gpu/media/platform_media_pipeline.h"
-#include "gpu/ipc/service/gpu_command_buffer_stub.h"
-#include "ipc/ipc_listener.h"
-#include "media/filters/platform_media_pipeline_types.h"
-
-struct MediaPipelineMsg_DecodedDataReady_Params;
-
-namespace IPC {
-class Sender;
-}
-
-namespace media {
-class DataBuffer;
-}
-
-namespace content {
-
-class GpuCommandBufferStub;
-class IPCDataSourceImpl;
-class PlatformMediaPipeline;
-
-// The IPC-facing participant of the media decoding implementation in the GPU
-// process.  It owns a PlatformMediaPipeline and uses it to handle media
-// decoding requests.  It owns an IPCDataSource object that provides the
-// PlatformMediaPipeline with raw media data by requesting it from a DataSource
-// living in the render process.
-class IPCMediaPipeline : public IPC::Listener {
- public:
-  IPCMediaPipeline(IPC::Sender* channel,
-                   int32_t routing_id,
-                   gpu::GpuCommandBufferStub* command_buffer);
-  ~IPCMediaPipeline() override;
-
-  // IPC::Listener implementation.
-  bool OnMessageReceived(const IPC::Message& msg) override;
-
- private:
-  // See the state diagram below.  Decoding is only allowed in the DECODING
-  // state.
-  //
-  //   CONSTRUCTED
-  //       | OnInitialize()
-  //       v
-  //     BUSY ----------------------------------------> STOPPED
-  //    |     ^               init failure / OnStop()      ^
-  //    v     | OnSeek()                                   | OnStop()
-  //   DECODING -------------------------------------------
-  enum State { CONSTRUCTED, BUSY, DECODING, STOPPED };
-
-  void OnInitialize(int64_t data_source_size,
-                    bool is_data_source_streaming,
-                    const std::string& mime_type);
-  void Initialized(bool success,
-                   int bitrate,
-                   const media::PlatformMediaTimeInfo& time_info,
-                   const media::PlatformAudioConfig& audio_config,
-                   const media::PlatformVideoConfig& video_config);
-
-  void OnBufferForDecodedDataReady(media::PlatformMediaDataType type,
-                                   size_t buffer_size,
-                                   base::SharedMemoryHandle handle);
-  void DecodedDataReady(media::PlatformMediaDataType type,
-                        const scoped_refptr<media::DataBuffer>& buffer);
-  void DecodedTextureReady(uint32_t client_texture_id,
-                           const scoped_refptr<media::DataBuffer>& buffer);
-  void DecodedDataReadyImpl(media::PlatformMediaDataType type,
-                            uint32_t client_texture_id,
-                            const scoped_refptr<media::DataBuffer>& buffer);
-  void OnAudioConfigChanged(const media::PlatformAudioConfig& audio_config);
-  void OnVideoConfigChanged(const media::PlatformVideoConfig& video_config);
-
-  void OnWillSeek();
-  void OnSeek(base::TimeDelta time);
-  void SeekDone(bool success);
-
-  void OnStop();
-
-  void OnReadDecodedData(media::PlatformMediaDataType type,
-                         uint32_t client_texture_id);
-
-  void SendAudioData(media::MediaDataStatus status,
-                     base::TimeDelta timestamp,
-                     base::TimeDelta duration);
-
-  bool has_media_type(media::PlatformMediaDataType type) const {
-    DCHECK_LT(type, media::PLATFORM_MEDIA_DATA_TYPE_COUNT);
-    return has_media_type_[type];
-  }
-
-  bool is_handling_accelerated_video_decode(
-      media::PlatformMediaDataType type) const {
-    return type == media::PLATFORM_MEDIA_VIDEO &&
-           video_config_.decoding_mode ==
-               media::PlatformMediaDecodingMode::HARDWARE;
-  }
-
-  bool ClientToServiceTextureId(uint32_t client_texture_id,
-                                uint32_t* service_texture_id);
-
-  State state_;
-
-  bool has_media_type_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  IPC::Sender* const channel_;
-  const int32_t routing_id_;
-
-  scoped_ptr<IPCDataSourceImpl> data_source_;
-  scoped_ptr<PlatformMediaPipeline> media_pipeline_;
-
-  base::ThreadChecker thread_checker_;
-
-  media::PlatformVideoConfig video_config_;
-  gpu::GpuCommandBufferStub* command_buffer_;
-  // Maps texture ID used in renderer process to one used in GPU process.
-  std::map<uint32_t, uint32_t> known_picture_buffers_;
-
-  // A buffer for decoded media data, shared with the render process.  Filled in
-  // the GPU process, consumed in the renderer process.
-  scoped_ptr<base::SharedMemory>
-      shared_decoded_data_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  // Holding place for decoded media data when it didn't fit into shared buffer
-  // or such buffer is not ready.
-  scoped_refptr<media::DataBuffer>
-      pending_output_buffers_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  base::WeakPtrFactory<IPCMediaPipeline> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(IPCMediaPipeline);
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_IPC_MEDIA_PIPELINE_H_
diff --git a/content/common/gpu/media/platform_media_pipeline.h b/content/common/gpu/media/platform_media_pipeline.h
deleted file mode 100644
index 801a2b3..0000000
--- a/content/common/gpu/media/platform_media_pipeline.h
+++ /dev/null
@@ -1,89 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_PLATFORM_MEDIA_PIPELINE_H_
-#define CONTENT_COMMON_GPU_MEDIA_PLATFORM_MEDIA_PIPELINE_H_
-
-#include <string>
-
-#include "base/callback.h"
-#include "base/memory/ref_counted.h"
-#include "base/time/time.h"
-#include "content/common/content_export.h"
-#include "media/filters/platform_media_pipeline_types.h"
-
-namespace media {
-class DataBuffer;
-struct PlatformAudioConfig;
-struct PlatformVideoConfig;
-}
-
-namespace content {
-class IPCDataSource;
-
-// An interface for the media pipeline using decoder infrastructure available
-// on specific platforms.  It represents a full decoding pipeline - it reads
-// raw input data from a DataSource and outputs decoded and properly formatted
-// audio and/or video samples.
-class CONTENT_EXPORT PlatformMediaPipeline {
- public:
-  using AudioConfigChangedCB =
-      base::Callback<void(const media::PlatformAudioConfig& audio_config)>;
-  using VideoConfigChangedCB =
-      base::Callback<void(const media::PlatformVideoConfig& video_config)>;
-
-  using InitializeCB =
-      base::Callback<void(bool success,
-                          int bitrate,
-                          const media::PlatformMediaTimeInfo& time_info,
-                          const media::PlatformAudioConfig& audio_config,
-                          const media::PlatformVideoConfig& video_config)>;
-  // A type of a callback ensuring that valid GL context is present. Relevant
-  // for methods which use OpenGL API (e.g. dealing with hardware accelerated
-  // video decoding). Return value indicates if GL context is available to use.
-  using MakeGLContextCurrentCB = base::Callback<bool(void)>;
-  // Passing a NULL |buffer| indicates a read/decoding error.
-  using ReadDataCB =
-      base::Callback<void(const scoped_refptr<media::DataBuffer>& buffer)>;
-  using SeekCB = base::Callback<void(bool success)>;
-
-  virtual ~PlatformMediaPipeline() {}
-
-  // Instantiates a concrete implementation of this interface.  Each platform
-  // is expected to define its version of this method.  When hardware
-  // accelerated video decoding mode is preferred but not available media
-  // pipeline should attempt to fall back to software decoding.
-  static PlatformMediaPipeline* Create(
-      IPCDataSource* data_source,
-      const AudioConfigChangedCB& audio_config_changed_cb,
-      const VideoConfigChangedCB& video_config_changed_cb,
-      media::PlatformMediaDecodingMode preferred_video_decoding_mode,
-      const MakeGLContextCurrentCB& make_gl_context_current_cb);
-
-  // Whether a PlatformMediaPipeline instance on the current platform combats
-  // the stuttering effects of underflow by enlarging its internal buffers.
-  static bool EnlargesBuffersOnUnderflow();
-
-  // Returns the target capacity of the raw media data buffer, in the backward
-  // and forward directions.
-  static base::TimeDelta GetTargetBufferDurationBehind();
-  static base::TimeDelta GetTargetBufferDurationAhead();
-
-  virtual void Initialize(const std::string& mime_type,
-                          const InitializeCB& initialize_cb) = 0;
-
-  virtual void ReadAudioData(const ReadDataCB& read_audio_data_cb) = 0;
-  // |texture_id| is meaningful only when hardware accelerated decoding is used.
-  virtual void ReadVideoData(const ReadDataCB& read_video_data_cb,
-                             uint32_t texture_id) = 0;
-
-  virtual void WillSeek() = 0;
-  virtual void Seek(base::TimeDelta time, const SeekCB& seek_cb) = 0;
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_PLATFORM_MEDIA_PIPELINE_H_
diff --git a/content/common/gpu/media/platform_media_pipeline_integration_test.cc b/content/common/gpu/media/platform_media_pipeline_integration_test.cc
deleted file mode 100644
index 0216a22..0000000
--- a/content/common/gpu/media/platform_media_pipeline_integration_test.cc
+++ /dev/null
@@ -1,412 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/test/pipeline_integration_test_base.h"
-
-#include "base/command_line.h"
-#include "content/common/gpu/media/test_pipeline_host.h"
-#include "media/base/audio_decoder_config.h"
-#include "media/base/media_log.h"
-#include "media/base/media_switches.h"
-#include "media/base/test_data_util.h"
-#include "media/base/video_decoder_config.h"
-#include "media/filters/ipc_demuxer.h"
-
-#if defined(OS_MACOSX)
-#include "base/mac/mac_util.h"
-#endif
-
-#if defined(OS_WIN)
-#include "base/win/windows_version.h"
-#endif
-
-namespace content {
-
-class PlatformMediaPipelineIntegrationTest
-    : public testing::Test,
-      public media::PipelineIntegrationTestBase {
- public:
-  static bool IsEnabled() {
-#if defined(OS_MACOSX)
-    if (base::mac::IsOSMavericksOrLater())
-      return true;
-#elif defined(OS_WIN)
-    if (base::win::GetVersion() >= base::win::VERSION_WIN7)
-      return true;
-#endif
-    LOG(WARNING) << "Unsupported OS, skipping test";
-    return false;
-  }
-
- protected:
-  void CreateDemuxer(scoped_ptr<media::DataSource> data_source) override {
-    PipelineIntegrationTestBase::CreateDemuxer(std::move(data_source));
-
-    const std::string content_type;
-    const GURL url("file://" +
-                   media::GetTestDataFilePath(filename_).AsUTF8Unsafe());
-    if (media::IPCDemuxer::CanPlayType(content_type, url)) {
-      scoped_ptr<media::IPCMediaPipelineHost> pipeline_host(
-          new TestPipelineHost(data_source_.get()));
-      demuxer_.reset(new media::IPCDemuxer(
-          message_loop_.task_runner(), data_source_.get(),
-          std::move(pipeline_host), content_type, url,
-          new media::MediaLog()));
-    }
-  }
-};
-
-#if defined(OS_MACOSX) || defined(OS_WIN)
-TEST_F(PlatformMediaPipelineIntegrationTest, BasicPlayback) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear.mp4", kHashed));
-
-  Play();
-
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-#if defined(OS_MACOSX)
-  if (base::mac::IsOSYosemiteOrLater()) {
-    EXPECT_EQ("e7832270a91e8de7945b5724eec2cbcb", GetVideoHash());
-    EXPECT_EQ("-1.29,-0.84,-0.56,1.16,0.82,0.32,", GetAudioHash());
-  } else {
-    // On OS X 10.9, the expected hashes can be different, because our solution
-    // doesn't necessarily process frames one by one, see AVFMediaDecoder.
-    EXPECT_EQ("-1.38,-0.99,0.56,1.71,1.48,0.23,", GetAudioHash());
-  }
-#elif defined(OS_WIN)
-  EXPECT_EQ("eb228dfe6882747111161156164dcab0", GetVideoHash());
-  EXPECT_EQ("-1.83,-1.16,-0.44,0.88,0.92,0.62,", GetAudioHash());
-#endif
-  EXPECT_TRUE(demuxer_->GetTimelineOffset().is_null());
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, BasicPlayback_16x9_Aspect) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear-320x240-16x9-aspect.mp4", kHashed));
-
-  Play();
-
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-#if defined(OS_MACOSX)
-  if (base::mac::IsOSYosemiteOrLater()) {
-    EXPECT_EQ("e9a2e53ef2c16757962cc58d37de69e7", GetVideoHash());
-    EXPECT_EQ("-3.66,-2.08,0.22,2.09,0.64,-0.90,", GetAudioHash());
-  } else {
-    // On OS X, the expected hashes can be different, because our solution
-    // doesn't necessarily process frames one by one, see AVFMediaDecoder.
-    EXPECT_EQ("-1.81,-0.36,-0.20,0.84,-0.52,-1.11,", GetAudioHash());
-  }
-#elif defined(OS_WIN)
-  EXPECT_EQ("e9a2e53ef2c16757962cc58d37de69e7", GetVideoHash());
-  EXPECT_EQ("-3.60,-1.82,0.28,1.90,0.34,-1.09,", GetAudioHash());
-#endif
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, BasicPlayback_VideoOnly) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear_silent.mp4", kHashed));
-
-  Play();
-
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-#if defined(OS_MACOSX)
-  if (base::mac::IsOSYosemiteOrLater()) {
-    EXPECT_EQ("e7832270a91e8de7945b5724eec2cbcb", GetVideoHash());
-  }
-  // On OS X, the expected hashes can be different, because our solution
-  // doesn't necessarily process frames one by one, see AVFMediaDecoder.
-#elif defined(OS_WIN)
-  EXPECT_EQ("eb228dfe6882747111161156164dcab0", GetVideoHash());
-#endif
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, BasicPlayback_MP3) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("sfx.mp3", kHashed));
-
-  Play();
-
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-#if defined(OS_MACOSX)
-  if (base::mac::IsOSYosemiteOrLater()) {
-    // TODO(wdzierzanowski): Sanitize this.
-    // The current state of affairs on 10.10 is that these are the two hashes
-    // that we ever get for this file, and which one we get in a particular run
-    // is pretty much random.  The difference between the decoded audio signals
-    // is that one of them has a small amount of silence added at the end.
-    // When this test is run on 10.9 -- with a forced usage of AVFMediaReader
-    // -- the hash is always the same.
-    EXPECT_TRUE(GetAudioHash() == "0.35,1.24,2.98,4.28,4.17,2.74," ||
-                GetAudioHash() == "2.41,1.48,1.98,2.78,3.28,3.12,");
-  } else {
-    // On OS X, the expected hashes can be different, because our solution
-    // doesn't necessarily process frames one by one, see AVFMediaDecoder.
-    EXPECT_EQ("2.08,3.25,3.79,3.28,2.11,1.14,", GetAudioHash());
-  }
-#elif defined(OS_WIN)
-  EXPECT_EQ("0.35,1.24,2.97,4.28,4.18,2.75,", GetAudioHash());
-#endif
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, BasicPlayback_M4A) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("sfx.m4a", kHashed));
-
-  Play();
-
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-#if defined(OS_MACOSX)
-  if (base::mac::IsOSYosemiteOrLater()) {
-    EXPECT_EQ("-5.29,-5.47,-5.05,-4.33,-2.99,-3.79,", GetAudioHash());
-  } else {
-    // On OS X, the expected hashes can be different, because our solution
-    // doesn't necessarily process frames one by one, see AVFMediaDecoder.
-    EXPECT_EQ("-4.97,-3.80,-3.26,-3.75,-4.90,-5.83,", GetAudioHash());
-  }
-#elif defined(OS_WIN)
-  EXPECT_EQ("0.46,1.72,4.26,4.57,3.39,1.54,", GetAudioHash());
-#endif
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, SeekWhilePaused) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear.mp4"));
-
-  base::TimeDelta duration(pipeline_->GetMediaDuration());
-  base::TimeDelta start_seek_time(duration / 4);
-  base::TimeDelta seek_time(duration * 3 / 4);
-
-  Play();
-  ASSERT_TRUE(WaitUntilCurrentTimeIsAfter(start_seek_time));
-  Pause();
-  ASSERT_TRUE(Seek(seek_time));
-  EXPECT_EQ(pipeline_->GetMediaTime(), seek_time);
-  Play();
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-  // Make sure seeking after reaching the end works as expected.
-  Pause();
-  ASSERT_TRUE(Seek(seek_time));
-  EXPECT_EQ(pipeline_->GetMediaTime(), seek_time);
-  Play();
-  ASSERT_TRUE(WaitUntilOnEnded());
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, SeekWhilePlaying) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear.mp4"));
-
-  base::TimeDelta duration(pipeline_->GetMediaDuration());
-  base::TimeDelta start_seek_time(duration / 4);
-  base::TimeDelta seek_time(duration * 3 / 4);
-
-  Play();
-  ASSERT_TRUE(WaitUntilCurrentTimeIsAfter(start_seek_time));
-  ASSERT_TRUE(Seek(seek_time));
-  EXPECT_GE(pipeline_->GetMediaTime(), seek_time);
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-  // Make sure seeking after reaching the end works as expected.
-  ASSERT_TRUE(Seek(seek_time));
-  EXPECT_GE(pipeline_->GetMediaTime(), seek_time);
-  ASSERT_TRUE(WaitUntilOnEnded());
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, Seek_VideoOnly) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear_silent.mp4", kHashed));
-
-  Play();
-  ASSERT_TRUE(Seek(pipeline_->GetMediaDuration() / 2));
-
-  ASSERT_TRUE(WaitUntilOnEnded());
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, PlayInLoop) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear.mp4"));
-
-  const base::TimeDelta duration = pipeline_->GetMediaDuration();
-  const base::TimeDelta play_time = duration / 4;
-
-  Play();
-  ASSERT_TRUE(WaitUntilCurrentTimeIsAfter(play_time));
-  ASSERT_TRUE(Seek(duration));
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-  ASSERT_TRUE(Seek(base::TimeDelta()));
-  ASSERT_LT(pipeline_->GetMediaTime(), play_time);
-  ASSERT_TRUE(WaitUntilCurrentTimeIsAfter(play_time));
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, TruncatedMedia) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear_truncated.mp4"));
-
-  Play();
-  WaitUntilCurrentTimeIsAfter(base::TimeDelta::FromMicroseconds(1066666));
-  ASSERT_TRUE(ended_ || pipeline_status_ != media::PIPELINE_OK);
-}
-
-// TODO(wdzierzanowski): Fix and enable again (DNA-30573).
-TEST_F(PlatformMediaPipelineIntegrationTest, DISABLED_DecodingError) {
-  if (!IsEnabled())
-    return;
-
-#if defined(OS_MACOSX)
-  // AVPlayer hides the error.
-  if (base::mac::IsOSMavericksOrEarlier())
-    return;
-#endif
-
-  // TODO(wdzierzanowski): WMFMediaPipeline (Windows) doesn't detect the error?
-  // (DNA-30324).
-#if !defined(OS_WIN)
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear_corrupt.mp4"));
-  Play();
-  EXPECT_EQ(media::PIPELINE_ERROR_DECODE, WaitUntilEndedOrError());
-#endif
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, Rotated_Metadata_0) {
-  if (!IsEnabled())
-    return;
-
-  // This is known not to work on Windows systems older than 8.
-#if defined(OS_WIN)
-  if (base::win::GetVersion() < base::win::VERSION_WIN8)
-    return;
-#endif
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear_rotate_0.mp4"));
-  ASSERT_EQ(media::VIDEO_ROTATION_0, metadata_.video_rotation);
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, Rotated_Metadata_90) {
-  if (!IsEnabled())
-    return;
-
-  // This is known not to work on Windows systems older than 8.
-#if defined(OS_WIN)
-  if (base::win::GetVersion() < base::win::VERSION_WIN8)
-    return;
-#endif
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear_rotate_90.mp4"));
-  ASSERT_EQ(media::VIDEO_ROTATION_90, metadata_.video_rotation);
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, Rotated_Metadata_180) {
-  if (!IsEnabled())
-    return;
-
-  // This is known not to work on Windows systems older than 8.
-#if defined(OS_WIN)
-  if (base::win::GetVersion() < base::win::VERSION_WIN8)
-    return;
-#endif
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear_rotate_180.mp4"));
-  ASSERT_EQ(media::VIDEO_ROTATION_180, metadata_.video_rotation);
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, Rotated_Metadata_270) {
-  if (!IsEnabled())
-    return;
-
-  // This is known not to work on Windows systems older than 8.
-#if defined(OS_WIN)
-  if (base::win::GetVersion() < base::win::VERSION_WIN8)
-    return;
-#endif
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("bear_rotate_270.mp4"));
-  ASSERT_EQ(media::VIDEO_ROTATION_270, metadata_.video_rotation);
-}
-
-// Configuration change happens only on Windows.
-#if defined(OS_WIN)
-TEST_F(PlatformMediaPipelineIntegrationTest, AudioConfigChange) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("config_change_audio.mp4"));
-
-  Play();
-
-  media::AudioDecoderConfig audio_config =
-      demuxer_->GetStream(media::DemuxerStream::AUDIO)->audio_decoder_config();
-  EXPECT_EQ(audio_config.samples_per_second(), 24000);
-
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-  audio_config =
-      demuxer_->GetStream(media::DemuxerStream::AUDIO)->audio_decoder_config();
-  EXPECT_EQ(audio_config.samples_per_second(), 48000);
-}
-
-TEST_F(PlatformMediaPipelineIntegrationTest, VideoConfigChange) {
-  if (!IsEnabled())
-    return;
-
-  ASSERT_EQ(media::PIPELINE_OK, Start("config_change_video.mp4"));
-
-  Play();
-
-  media::VideoDecoderConfig video_config =
-      demuxer_->GetStream(media::DemuxerStream::VIDEO)->video_decoder_config();
-  EXPECT_EQ(video_config.coded_size().height(), 270);
-
-  ASSERT_TRUE(WaitUntilOnEnded());
-
-  video_config =
-      demuxer_->GetStream(media::DemuxerStream::VIDEO)->video_decoder_config();
-  EXPECT_EQ(video_config.coded_size().height(), 272);
-}
-#endif  // defined(OS_WIN)
-
-// TODO(wdzierzanowski): Fix and enable on Windows (DNA-35224).
-#if defined(OS_WIN)
-TEST_F(PlatformMediaPipelineIntegrationTest,
-       DISABLED_BasicPlaybackPositiveStartTime) {
-#else
-TEST_F(PlatformMediaPipelineIntegrationTest, BasicPlaybackPositiveStartTime) {
-#endif
-  ASSERT_EQ(media::PIPELINE_OK, Start("nonzero-start-time.mp4"));
-  Play();
-  ASSERT_TRUE(WaitUntilOnEnded());
-  ASSERT_EQ(base::TimeDelta::FromMicroseconds(390000),
-            demuxer_->GetStartTime());
-}
-
-#endif  // defined(OS_MACOSX) || defined(OS_WIN)
-
-}  // namespace content
diff --git a/content/common/gpu/media/platform_media_pipeline_mac.cc b/content/common/gpu/media/platform_media_pipeline_mac.cc
deleted file mode 100644
index 92f2388..0000000
--- a/content/common/gpu/media/platform_media_pipeline_mac.cc
+++ /dev/null
@@ -1,44 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/platform_media_pipeline.h"
-
-#include "content/common/gpu/media/avf_media_pipeline.h"
-#include "content/common/gpu/media/avf_media_reader_runner.h"
-
-namespace content {
-
-// static
-PlatformMediaPipeline* PlatformMediaPipeline::Create(
-    IPCDataSource* data_source,
-    const AudioConfigChangedCB& /* audio_config_changed_cb */,
-    const VideoConfigChangedCB& /* video_config_changed_cb */,
-    media::PlatformMediaDecodingMode /* preferred_video_decoding_mode */,
-    const MakeGLContextCurrentCB& /* make_gl_context_current_cb */) {
-  if (AVFMediaReaderRunner::IsAvailable())
-    return new AVFMediaReaderRunner(data_source);
-
-  return new AVFMediaPipeline(data_source);
-}
-
-// static
-bool PlatformMediaPipeline::EnlargesBuffersOnUnderflow() {
-  return !AVFMediaReaderRunner::IsAvailable();
-}
-
-// static
-base::TimeDelta PlatformMediaPipeline::GetTargetBufferDurationBehind() {
-  // AV Foundation is known to make requests for "past" data quite often.  We
-  // use a large "behind buffer" to prevent cache misses.
-  return base::TimeDelta::FromSeconds(20);
-}
-
-// static
-base::TimeDelta PlatformMediaPipeline::GetTargetBufferDurationAhead() {
-  return base::TimeDelta();
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/platform_media_pipeline_win.cc b/content/common/gpu/media/platform_media_pipeline_win.cc
deleted file mode 100644
index fec844a..0000000
--- a/content/common/gpu/media/platform_media_pipeline_win.cc
+++ /dev/null
@@ -1,41 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/platform_media_pipeline.h"
-
-#include "content/common/gpu/media/ipc_data_source.h"
-#include "content/common/gpu/media/wmf_media_pipeline.h"
-
-namespace content {
-
-// static
-PlatformMediaPipeline* PlatformMediaPipeline::Create(
-    IPCDataSource* data_source,
-    const AudioConfigChangedCB& audio_config_changed_cb,
-    const VideoConfigChangedCB& video_config_changed_cb,
-    media::PlatformMediaDecodingMode preferred_video_decoding_mode,
-    const MakeGLContextCurrentCB& make_gl_context_current_cb) {
-  return new WMFMediaPipeline(
-      data_source, audio_config_changed_cb, video_config_changed_cb,
-      preferred_video_decoding_mode, make_gl_context_current_cb);
-}
-
-// static
-bool PlatformMediaPipeline::EnlargesBuffersOnUnderflow() {
-  return false;
-}
-
-// static
-base::TimeDelta PlatformMediaPipeline::GetTargetBufferDurationBehind() {
-  return base::TimeDelta();
-}
-
-// static
-base::TimeDelta PlatformMediaPipeline::GetTargetBufferDurationAhead() {
-  return base::TimeDelta();
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/propmedia_gpu_channel.cc b/content/common/gpu/media/propmedia_gpu_channel.cc
deleted file mode 100644
index 4bfa4c8..0000000
--- a/content/common/gpu/media/propmedia_gpu_channel.cc
+++ /dev/null
@@ -1,106 +0,0 @@
-// Copyright (c) 2016 Vivaldi Technologies AS. All rights reserved.
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "content/common/gpu/media/propmedia_gpu_channel.h"
-
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
-#include "base/command_line.h"
-#include "build/build_config.h"
-
-#include "content/common/gpu/media/ipc_media_pipeline.h"
-#include "content/common/media/media_pipeline_messages.h"
-#include "content/public/common/content_switches.h"
-#include "gpu/config/gpu_switches.h"
-#include "gpu/ipc/common/gpu_messages.h"
-#include "ipc/ipc_channel.h"
-#include "ipc/message_filter.h"
-
-#if defined(OS_POSIX)
-#include "ipc/ipc_channel_posix.h"
-#endif
-
-namespace gpu {
-
-ProprietaryMediaGpuChannel::ProprietaryMediaGpuChannel(
-             GpuChannelManager* gpu_channel_manager,
-             SyncPointManager* sync_point_manager,
-             GpuWatchdog* watchdog,
-             gfx::GLShareGroup* share_group,
-             gles2::MailboxManager* mailbox_manager,
-             PreemptionFlag* preempting_flag,
-             PreemptionFlag* preempted_flag,
-             base::SingleThreadTaskRunner* task_runner,
-             base::SingleThreadTaskRunner* io_task_runner,
-             int32_t client_id,
-             uint64_t client_tracing_id,
-             bool allow_view_command_buffers,
-             bool allow_real_time_streams)
-  : GpuChannel(
-             gpu_channel_manager,
-             sync_point_manager,
-             watchdog,
-             share_group,
-             mailbox_manager,
-             preempting_flag,
-             preempted_flag,
-             task_runner,
-             io_task_runner,
-             client_id,
-             client_tracing_id,
-             allow_view_command_buffers,
-             allow_real_time_streams) {}
-
-ProprietaryMediaGpuChannel::~ProprietaryMediaGpuChannel() {}
-
-bool ProprietaryMediaGpuChannel::OnControlMessageReceived(
-      const IPC::Message& msg
-    ) {
-  bool handled = true;
-  IPC_BEGIN_MESSAGE_MAP(ProprietaryMediaGpuChannel, msg)
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_New, OnNewMediaPipeline)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_Destroy, OnDestroyMediaPipeline)
-#endif
-    IPC_MESSAGE_UNHANDLED(handled = GpuChannel::OnControlMessageReceived(msg))
-  IPC_END_MESSAGE_MAP()
-  return handled;
-}
-
-void ProprietaryMediaGpuChannel::OnNewMediaPipeline(
-    int32_t route_id,
-    int32_t gpu_video_accelerator_factories_route_id) {
-  GpuCommandBufferStub* command_buffer = nullptr;
-
-  const base::CommandLine* cmd_line = base::CommandLine::ForCurrentProcess();
-  if (!cmd_line->HasSwitch(switches::kDisableAcceleratedVideoDecode) &&
-      cmd_line->HasSwitch(switches::kEnablePlatformAcceleratedVideoDecoding)) {
-    command_buffer =
-        LookupCommandBuffer(gpu_video_accelerator_factories_route_id);
-  }
-
-  scoped_refptr<GpuChannelMessageQueue> queue = LookupStream(
-        gpu_video_accelerator_factories_route_id);
-  if (!queue)
-    queue = CreateStream(gpu_video_accelerator_factories_route_id,
-                         GpuStreamPriority::HIGH);
-
-
-  content::IPCMediaPipeline* ipc_media_pipeline =
-      new content::IPCMediaPipeline(this, route_id, command_buffer);
-  AddRoute(route_id, gpu_video_accelerator_factories_route_id,
-           ipc_media_pipeline);
-  media_pipelines_.AddWithID(ipc_media_pipeline, route_id);
-}
-
-void ProprietaryMediaGpuChannel::OnDestroyMediaPipeline(int32_t route_id) {
-  RemoveRoute(route_id);
-  media_pipelines_.Remove(route_id);
-}
-
-}  // namespace gpu
-
-#endif
diff --git a/content/common/gpu/media/propmedia_gpu_channel.h b/content/common/gpu/media/propmedia_gpu_channel.h
deleted file mode 100644
index f875cf5..0000000
--- a/content/common/gpu/media/propmedia_gpu_channel.h
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright (c) 2016 Vivaldi Technologies AS. All rights reserved.
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_PROPMEDIA_GPU_CHANNEL_H_
-#define CONTENT_COMMON_GPU_MEDIA_PROPMEDIA_GPU_CHANNEL_H_
-
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
-#include "content/common/gpu/media/ipc_media_pipeline.h"
-#include "gpu/ipc/service/gpu_channel.h"
-
-namespace gpu {
-
-
-class ProprietaryMediaGpuChannel : public GpuChannel
-{
- public:
-  // Takes ownership of the renderer process handle.
-  ProprietaryMediaGpuChannel(GpuChannelManager* gpu_channel_manager,
-             SyncPointManager* sync_point_manager,
-             GpuWatchdog* watchdog,
-             gfx::GLShareGroup* share_group,
-             gles2::MailboxManager* mailbox_manager,
-             PreemptionFlag* preempting_flag,
-             PreemptionFlag* preempted_flag,
-             base::SingleThreadTaskRunner* task_runner,
-             base::SingleThreadTaskRunner* io_task_runner,
-             int32_t client_id,
-             uint64_t client_tracing_id,
-             bool allow_view_command_buffers,
-             bool allow_real_time_streams);
-
-   ~ProprietaryMediaGpuChannel() override;
-
- private:
-  bool OnControlMessageReceived(const IPC::Message& msg) override;
-  void OnNewMediaPipeline(int32_t route_id,
-                          int32_t gpu_video_accelerator_factories_route_id);
-  void OnDestroyMediaPipeline(int32_t route_id);
-
- private:
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  typedef IDMap<content::IPCMediaPipeline, IDMapOwnPointer> MediaPipelineMap;
-  MediaPipelineMap media_pipelines_;
-#endif
-
-  DISALLOW_COPY_AND_ASSIGN(ProprietaryMediaGpuChannel);
-};
-
-}  // namespace gpu
-
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_PROPMEDIA_GPU_CHANNEL_H_
-
diff --git a/content/common/gpu/media/propmedia_gpu_channel_manager.cc b/content/common/gpu/media/propmedia_gpu_channel_manager.cc
deleted file mode 100644
index 87c5e84..0000000
--- a/content/common/gpu/media/propmedia_gpu_channel_manager.cc
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright (c) 2016 Vivaldi Technologies AS. All rights reserved.
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "content/common/gpu/media/propmedia_gpu_channel_manager.h"
-
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
-#include "content/common/gpu/media/propmedia_gpu_channel.h"
-
-namespace gpu {
-
-ProprietaryMediaGpuChannelManager::ProprietaryMediaGpuChannelManager(
-                    const GpuPreferences& gpu_preferences,
-                    GpuChannelManagerDelegate* delegate,
-                    GpuWatchdog* watchdog,
-                    base::SingleThreadTaskRunner* task_runner,
-                    base::SingleThreadTaskRunner* io_task_runner,
-                    base::WaitableEvent* shutdown_event,
-                    SyncPointManager* sync_point_manager,
-                    GpuMemoryBufferFactory* gpu_memory_buffer_factory)
-   : GpuChannelManager(
-                    gpu_preferences,
-                    delegate,
-                    watchdog,
-                    task_runner,
-                    io_task_runner,
-                    shutdown_event,
-                    sync_point_manager,
-                    gpu_memory_buffer_factory) {}
-
-ProprietaryMediaGpuChannelManager::~ProprietaryMediaGpuChannelManager() {}
-
-scoped_ptr<GpuChannel> ProprietaryMediaGpuChannelManager::CreateGpuChannel(
-    int client_id,
-    uint64_t client_tracing_id,
-    bool preempts,
-    bool allow_view_command_buffers,
-    bool allow_real_time_streams) {
-  return make_scoped_ptr(
-      new ProprietaryMediaGpuChannel(
-                     this, sync_point_manager(), watchdog(), share_group(),
-                     mailbox_manager(), preempts ? preemption_flag() : nullptr,
-                     preempts ? nullptr : preemption_flag(), task_runner_.get(),
-                     io_task_runner_.get(), client_id, client_tracing_id,
-                     allow_view_command_buffers, allow_real_time_streams));
-}
-
-}  // namespace gpu
-
-#endif // defined(USE_SYSTEM_PROPRIETARY_CODECS)
\ No newline at end of file
diff --git a/content/common/gpu/media/propmedia_gpu_channel_manager.h b/content/common/gpu/media/propmedia_gpu_channel_manager.h
deleted file mode 100644
index 3d11021..0000000
--- a/content/common/gpu/media/propmedia_gpu_channel_manager.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright (c) 2016 Vivaldi Technologies AS. All rights reserved.
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_PROPMEDIA_GPU_CHANNEL_MANAGER_H_
-#define CONTENT_COMMON_GPU_MEDIA_PROPMEDIA_GPU_CHANNEL_MANAGER_H_
-
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
-#include "gpu/ipc/service/gpu_channel_manager.h"
-
-namespace gpu {
-
-class ProprietaryMediaGpuChannelManager : public GpuChannelManager {
- public:
-  ProprietaryMediaGpuChannelManager(const GpuPreferences& gpu_preferences,
-                    GpuChannelManagerDelegate* delegate,
-                    GpuWatchdog* watchdog,
-                    base::SingleThreadTaskRunner* task_runner,
-                    base::SingleThreadTaskRunner* io_task_runner,
-                    base::WaitableEvent* shutdown_event,
-                    SyncPointManager* sync_point_manager,
-                    GpuMemoryBufferFactory* gpu_memory_buffer_factory);
-
-  ~ProprietaryMediaGpuChannelManager() override;
-
- protected:
-  scoped_ptr<GpuChannel> CreateGpuChannel(
-      int client_id,
-      uint64_t client_tracing_id,
-      bool preempts,
-      bool allow_view_command_buffers,
-      bool allow_real_time_streams) override;
-
-  DISALLOW_COPY_AND_ASSIGN(ProprietaryMediaGpuChannelManager);
-};
-
-}  // namespace gpu
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_PROPMEDIA_GPU_CHANNEL_MANAGER_H_
diff --git a/content/common/gpu/media/test_pipeline_host.cc b/content/common/gpu/media/test_pipeline_host.cc
deleted file mode 100644
index 5b33691..0000000
--- a/content/common/gpu/media/test_pipeline_host.cc
+++ /dev/null
@@ -1,191 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/test_pipeline_host.h"
-
-#include "base/bind.h"
-#include "base/callback_helpers.h"
-#include "content/common/gpu/media/platform_media_pipeline.h"
-#include "media/base/data_buffer.h"
-#include "media/base/decoder_buffer.h"
-#include "media/filters/ipc_demuxer.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace content {
-
-TestPipelineHost::DataSourceAdapter::~DataSourceAdapter() = default;
-
-void TestPipelineHost::DataSourceAdapter::Read(int64_t position,
-                                               int size,
-                                               uint8_t* data,
-                                               const ReadCB& read_cb) {
-  data_source_->Read(position, size, data, read_cb);
-}
-
-void TestPipelineHost::DataSourceAdapter::Stop() {
-  data_source_->Stop();
-}
-
-bool TestPipelineHost::DataSourceAdapter::GetSize(int64_t* size_out) {
-  return data_source_->GetSize(size_out);
-}
-
-bool TestPipelineHost::DataSourceAdapter::IsStreaming() {
-  return data_source_->IsStreaming();
-}
-
-void TestPipelineHost::DataSourceAdapter::SetBitrate(int bitrate) {
-  data_source_->SetBitrate(bitrate);
-}
-
-TestPipelineHost::TestPipelineHost(media::DataSource* data_source)
-    : data_source_adapter_(data_source),
-      platform_pipeline_(content::PlatformMediaPipeline::Create(
-          &data_source_adapter_,
-          base::Bind(&TestPipelineHost::OnAudioConfigChanged,
-                     base::Unretained(this)),
-          base::Bind(&TestPipelineHost::OnVideoConfigChanged,
-                     base::Unretained(this)),
-          media::PlatformMediaDecodingMode::SOFTWARE,
-          base::Callback<bool(void)>())) {}
-
-TestPipelineHost::~TestPipelineHost() = default;
-
-void TestPipelineHost::Initialize(const std::string& mimetype,
-                                  const InitializeCB& callback) {
-  CHECK(init_cb_.is_null());
-  init_cb_ = callback;
-
-  platform_pipeline_->Initialize(
-      mimetype,
-      base::Bind(&TestPipelineHost::Initialized, base::Unretained(this)));
-}
-
-void TestPipelineHost::StartWaitingForSeek() {
-}
-
-void TestPipelineHost::Seek(base::TimeDelta time,
-                            const media::PipelineStatusCB& status_cb) {
-  platform_pipeline_->Seek(time,
-                           base::Bind(&TestPipelineHost::SeekDone, status_cb));
-}
-
-void TestPipelineHost::Stop() {
-  platform_pipeline_.reset();
-}
-
-void TestPipelineHost::ReadDecodedData(
-    media::PlatformMediaDataType type,
-    const media::DemuxerStream::ReadCB& read_cb) {
-  CHECK(read_cb_[type].is_null()) << "Overlapping reads are not supported";
-
-  read_cb_[type] = read_cb;
-
-  switch (type) {
-    case media::PLATFORM_MEDIA_AUDIO:
-      platform_pipeline_->ReadAudioData(base::Bind(
-          &TestPipelineHost::DataReady, base::Unretained(this), type));
-      break;
-
-    case media::PLATFORM_MEDIA_VIDEO: {
-      const uint32_t dummy_texture_id = 0;
-      platform_pipeline_->ReadVideoData(
-          base::Bind(&TestPipelineHost::DataReady, base::Unretained(this),
-                     type),
-          dummy_texture_id);
-      break;
-    }
-
-    default:
-      FAIL();
-      break;
-  }
-}
-
-bool TestPipelineHost::PlatformEnlargesBuffersOnUnderflow() const {
-  return PlatformMediaPipeline::EnlargesBuffersOnUnderflow();
-}
-
-base::TimeDelta TestPipelineHost::GetTargetBufferDurationBehind() const {
-  return PlatformMediaPipeline::GetTargetBufferDurationBehind();
-}
-base::TimeDelta TestPipelineHost::GetTargetBufferDurationAhead() const {
-  return PlatformMediaPipeline::GetTargetBufferDurationAhead();
-}
-
-media::PlatformAudioConfig TestPipelineHost::audio_config() const {
-  return audio_config_;
-}
-media::PlatformVideoConfig TestPipelineHost::video_config() const {
-  return video_config_;
-}
-
-void TestPipelineHost::SeekDone(const media::PipelineStatusCB& status_cb,
-                                bool success) {
-  status_cb.Run(success ? media::PIPELINE_OK : media::PIPELINE_ERROR_ABORT);
-}
-
-void TestPipelineHost::Initialized(
-    bool success,
-    int bitrate,
-    const media::PlatformMediaTimeInfo& time_info,
-    const media::PlatformAudioConfig& audio_config,
-    const media::PlatformVideoConfig& video_config) {
-  CHECK(!init_cb_.is_null());
-
-  if (audio_config.is_valid()) {
-    audio_config_ = audio_config;
-  }
-
-  if (video_config.is_valid()) {
-    video_config_ = video_config;
-  }
-
-  success = success && bitrate >= 0;
-
-  base::ResetAndReturn(&init_cb_)
-      .Run(success, bitrate, time_info, audio_config, video_config);
-}
-
-void TestPipelineHost::DataReady(
-    media::PlatformMediaDataType type,
-    const scoped_refptr<media::DataBuffer>& buffer) {
-  CHECK(!read_cb_[type].is_null());
-
-  scoped_refptr<media::DecoderBuffer> decoder_buffer =
-      new media::DecoderBuffer(0);
-  if (buffer) {
-    if (buffer->end_of_stream()) {
-      decoder_buffer = media::DecoderBuffer::CreateEOSBuffer();
-    } else {
-      decoder_buffer =
-          media::DecoderBuffer::CopyFrom(buffer->data(), buffer->data_size());
-      decoder_buffer->set_timestamp(buffer->timestamp());
-      decoder_buffer->set_duration(buffer->duration());
-    }
-  }
-
-  base::ResetAndReturn(&read_cb_[type])
-      .Run(media::DemuxerStream::kOk, decoder_buffer);
-}
-
-void TestPipelineHost::OnAudioConfigChanged(
-    const media::PlatformAudioConfig& audio_config) {
-  CHECK(!read_cb_[media::PLATFORM_MEDIA_AUDIO].is_null());
-  audio_config_ = audio_config;
-  base::ResetAndReturn(&read_cb_[media::PLATFORM_MEDIA_AUDIO])
-      .Run(media::DemuxerStream::kConfigChanged, nullptr);
-}
-
-void TestPipelineHost::OnVideoConfigChanged(
-    const media::PlatformVideoConfig& video_config) {
-  CHECK(!read_cb_[media::PLATFORM_MEDIA_VIDEO].is_null());
-  video_config_ = video_config;
-  base::ResetAndReturn(&read_cb_[media::PLATFORM_MEDIA_VIDEO])
-      .Run(media::DemuxerStream::kConfigChanged, nullptr);
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/test_pipeline_host.h b/content/common/gpu/media/test_pipeline_host.h
deleted file mode 100644
index 6a7fe45..0000000
--- a/content/common/gpu/media/test_pipeline_host.h
+++ /dev/null
@@ -1,100 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_TEST_PIPELINE_HOST_H_
-#define CONTENT_COMMON_GPU_MEDIA_TEST_PIPELINE_HOST_H_
-
-#include <string>
-
-#include "content/common/gpu/media/ipc_data_source.h"
-#include "media/filters/ipc_media_pipeline_host.h"
-
-namespace media {
-class DataBuffer;
-}
-
-namespace content {
-
-class PlatformMediaPipeline;
-
-// A trivial implementation of IPCMediaPipelineHost that just delegates to
-// PlatformMediaPipeline directly, no IPC involved.
-class TestPipelineHost : public media::IPCMediaPipelineHost {
- public:
-  explicit TestPipelineHost(media::DataSource* data_source);
-  ~TestPipelineHost() override;
-
-  void Initialize(const std::string& mimetype,
-                  const InitializeCB& callback) override;
-
-  void StartWaitingForSeek() override;
-
-  void Seek(base::TimeDelta time,
-            const media::PipelineStatusCB& status_cb) override;
-
-  void Stop() override;
-
-  void ReadDecodedData(media::PlatformMediaDataType type,
-                       const media::DemuxerStream::ReadCB& read_cb) override;
-
-  bool PlatformEnlargesBuffersOnUnderflow() const override;
-
-  base::TimeDelta GetTargetBufferDurationBehind() const override;
-  base::TimeDelta GetTargetBufferDurationAhead() const override;
-
-  media::PlatformAudioConfig audio_config() const override;
-  media::PlatformVideoConfig video_config() const override;
-
- private:
-  class DataSourceAdapter : public IPCDataSource {
-   public:
-    explicit DataSourceAdapter(media::DataSource* data_source)
-        : data_source_(data_source) {}
-    ~DataSourceAdapter() override;
-
-    void Suspend() override {}
-    void Resume() override {}
-    void Read(int64_t position,
-              int size,
-              uint8_t* data,
-              const ReadCB& read_cb) override;
-    void Stop() override;
-    bool GetSize(int64_t* size_out) override;
-    bool IsStreaming() override;
-    void SetBitrate(int bitrate) override;
-
-   private:
-    media::DataSource* const data_source_;
-  };
-
-  static void SeekDone(const media::PipelineStatusCB& status_cb, bool success);
-
-  void Initialized(bool success,
-                   int bitrate,
-                   const media::PlatformMediaTimeInfo& time_info,
-                   const media::PlatformAudioConfig& audio_config,
-                   const media::PlatformVideoConfig& video_config);
-
-  void DataReady(media::PlatformMediaDataType type,
-                 const scoped_refptr<media::DataBuffer>& buffer);
-
-  void OnAudioConfigChanged(const media::PlatformAudioConfig& audio_config);
-
-  void OnVideoConfigChanged(const media::PlatformVideoConfig& video_config);
-
-  DataSourceAdapter data_source_adapter_;
-  scoped_ptr<content::PlatformMediaPipeline> platform_pipeline_;
-
-  InitializeCB init_cb_;
-  media::DemuxerStream::ReadCB read_cb_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  media::PlatformAudioConfig audio_config_;
-  media::PlatformVideoConfig video_config_;
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_TEST_PIPELINE_HOST_H_
diff --git a/content/common/gpu/media/wmf_byte_stream.cc b/content/common/gpu/media/wmf_byte_stream.cc
deleted file mode 100644
index 907dab2..0000000
--- a/content/common/gpu/media/wmf_byte_stream.cc
+++ /dev/null
@@ -1,592 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2013 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/wmf_byte_stream.h"
-
-#include <algorithm>
-
-#include "base/bind.h"
-#include "base/synchronization/waitable_event.h"
-#include "content/common/gpu/media/wmf_media_pipeline.h"
-#include "media/base/bind_to_current_loop.h"
-
-namespace content {
-
-namespace {
-
-class WMFReadRequest : public base::win::IUnknownImpl {
- public:
-  WMFReadRequest(BYTE* buff, ULONG len) : buffer(buff), length(len), read(0) {
-  }
-
-  ~WMFReadRequest() override {}
-
-  BYTE* buffer;
-  ULONG length;
-  ULONG read;
-};
-
-void BlockingReadDone(int* bytes_read_out,
-                      base::WaitableEvent* read_done,
-                      int bytes_read) {
-  *bytes_read_out = bytes_read;
-  read_done->Signal();
-}
-
-}  // namespace
-
-const int64_t WMFByteStream::kUnknownSize = -1;
-
-WMFByteStream::WMFByteStream(media::DataSource* data_source)
-    : data_source_(data_source),
-      async_result_(NULL),
-      read_position_(0),
-      stopped_(false) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(data_source_);
-}
-
-WMFByteStream::~WMFByteStream() {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(stopped_);
-}
-
-HRESULT WMFByteStream::Initialize(LPCWSTR mime_type) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  HRESULT hresult = MFCreateAttributes(attributes_.Receive(), 1);
-  if (SUCCEEDED(hresult)) {
-    attributes_->SetString(MF_BYTESTREAM_CONTENT_TYPE, mime_type);
-    read_cb_ =
-        media::BindToCurrentLoop(base::Bind(&WMFByteStream::OnReadData, this));
-    return S_OK;
-  }
-
-  return E_ABORT;
-}
-
-void WMFByteStream::Stop() {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  stopped_ = true;
-
-  if (async_result_) {
-    // Set async_result_ to NULL before calling MFInvokeCallback. Doing
-    // it after that call creates race condition because BeginRead may
-    // be called before this function returns. Callback will pass result
-    // to EndProc where it will be released.
-    IMFAsyncResult* result = async_result_;
-    async_result_ = NULL;
-    result->SetStatus(E_INVALIDARG);
-    MFInvokeCallback(result);
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::QueryInterface(REFIID riid, void** object) {
-  if (riid == IID_IMFByteStream) {
-    *object = static_cast<IMFByteStream*>(this);
-    AddRef();
-    return S_OK;
-  } else if (riid == IID_IMFAttributes) {
-    *object = static_cast<IMFAttributes*>(this);
-    AddRef();
-    return S_OK;
-  }
-
-  return IUnknownImpl::QueryInterface(riid, object);
-}
-
-ULONG STDMETHODCALLTYPE WMFByteStream::AddRef() {
-  return IUnknownImpl::AddRef();
-}
-
-ULONG STDMETHODCALLTYPE WMFByteStream::Release() {
-  return IUnknownImpl::Release();
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetCapabilities(DWORD* capabilities) {
-  *capabilities =
-      MFBYTESTREAM_IS_READABLE | MFBYTESTREAM_IS_SEEKABLE |
-      (data_source_->IsStreaming()
-           ? (MFBYTESTREAM_HAS_SLOW_SEEK | MFBYTESTREAM_IS_PARTIALLY_DOWNLOADED)
-           : 0);
-
-  return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::GetLength(QWORD* length) {
-  int64_t size = -1;
-  // The Media Framework expects -1 when the size is unknown.
-  *length = data_source_->GetSize(&size) ? size : kUnknownSize;
-  return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::SetLength(QWORD length) {
-  // The stream is not writable, so do nothing here.
-  return E_NOTIMPL;
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetCurrentPosition(QWORD* position) {
-  *position = read_position_;
-  return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::SetCurrentPosition(QWORD position) {
-  if (static_cast<int64_t>(position) < 0) {
-    return E_INVALIDARG;  // might happen if the stream is not seekable or
-                          // if the position overflows the stream
-  }
-
-  read_position_ = position;
-  return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::IsEndOfStream(BOOL* end_of_stream) {
-  int64_t size = -1;
-  if (!data_source_->GetSize(&size))
-    size = kUnknownSize;
-  *end_of_stream = size > 0 && read_position_ >= size;
-  return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::Read(BYTE* buff, ULONG len, ULONG* read) {
-  DCHECK(!thread_checker_.CalledOnValidThread())
-      << "Trying to make a blocking read on the main thread";
-
-  if (stopped_) {
-    // NOTE(pettern@vivaldi.com): Do not try to read when we've stopped
-    // as it might cause freezes with the read_done event never firing.
-    return E_FAIL;
-  }
-
-  base::WaitableEvent read_done(false, false);
-  int bytes_read = 0;
-  data_source_->Read(read_position_, len, buff,
-                     base::Bind(&BlockingReadDone, &bytes_read, &read_done));
-  read_done.Wait();
-  if (bytes_read == media::DataSource::kReadError)
-    return E_FAIL;
-
-  read_position_ += bytes_read;
-  *read = bytes_read;
-
-  return S_OK;
-}
-
-void WMFByteStream::OnReadData(int size) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (stopped_)
-    return;
-
-  base::win::ScopedComPtr<IUnknown> unknown;
-  HRESULT hr = async_result_->GetObjectW(unknown.Receive());
-  WMFReadRequest* read_request = static_cast<WMFReadRequest*>(unknown.get());
-
-  HRESULT status;
-  if (FAILED(hr) || !unknown || size == media::DataSource::kReadError) {
-    status = E_FAIL;
-  } else {
-    DCHECK(static_cast<ULONG>(size) <= read_request->length);
-    read_request->read = size;
-    status = S_OK;
-  }
-
-  // Setting async_result_ to NULL here to avoid second invoke of the callback
-  // from Stop function. When doing so we also have to use local variable and
-  // reset async_result_ before calling MFInvokeCallback, otherwise there would
-  // be a race condition, because BeginRead may be called before this function
-  // returns. Callback will pass result to EndRead where it will be released.
-  IMFAsyncResult* result = async_result_;
-  async_result_ = NULL;
-  result->SetStatus(status);
-  MFInvokeCallback(result);
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::BeginRead(BYTE* buff,
-                                                   ULONG len,
-                                                   IMFAsyncCallback* callback,
-                                                   IUnknown* state) {
-  DCHECK(!read_cb_.is_null());
-
-  if (stopped_) {
-    return E_INVALIDARG;
-  }
-
-  if (async_result_) {
-    return E_ABORT;
-  }
-
-  base::win::ScopedComPtr<IUnknown> read_request(new WMFReadRequest(buff, len));
-  HRESULT hresult =
-      MFCreateAsyncResult(read_request.get(), callback, state, &async_result_);
-  if (FAILED(hresult))
-    return E_ABORT;
-
-  data_source_->Read(read_position_, len, buff, read_cb_);
-  read_position_ += len;
-  return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::EndRead(IMFAsyncResult* result, ULONG* read) {
-  HRESULT hresult;
-  base::win::ScopedComPtr<IUnknown> unknown;
-  if (FAILED(result->GetObjectW(unknown.Receive())) || !unknown) {
-    hresult = E_INVALIDARG;
-  } else {
-    WMFReadRequest* read_request = static_cast<WMFReadRequest*>(unknown.get());
-    *read = read_request->read;
-    hresult = result->GetStatus();
-  }
-
-  // was acquired by a call to MFCreateAsyncResult in BeginRead
-  result->Release();
-  return hresult;
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::Write(const BYTE* buff, ULONG len, ULONG* written) {
-  // The stream is not writable, so do nothing here.
-  return E_NOTIMPL;
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::BeginWrite(const BYTE* buff,
-                                                    ULONG len,
-                                                    IMFAsyncCallback* callback,
-                                                    IUnknown* punk_state) {
-  // The stream is not writable, so do nothing here.
-  return E_NOTIMPL;
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::EndWrite(IMFAsyncResult* result, ULONG* written) {
-  // The stream is not writable, so do nothing here.
-  return E_NOTIMPL;
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::Seek(MFBYTESTREAM_SEEK_ORIGIN seek_origin,
-                    LONGLONG seek_offset,
-                    DWORD seek_flags,
-                    QWORD* current_position) {
-  int64_t size = -1;
-  if (!data_source_->GetSize(&size))
-    size = kUnknownSize;
-  switch (seek_origin) {
-    case msoBegin:
-      if ((size > 0 && seek_offset > size) || seek_offset < 0) {
-        return E_INVALIDARG;  // might happen if the stream is not seekable or
-                              // if the llSeekOffset overflows the stream
-      }
-      read_position_ = seek_offset;
-      break;
-
-    case msoCurrent:
-      if ((size > 0 && (read_position_ + seek_offset) > size) ||
-          (read_position_ + seek_offset) < 0) {
-        return E_INVALIDARG;  // might happen if the stream is not seekable or
-                              // if the llSeekOffset overflows the stream
-      }
-      read_position_ += seek_offset;
-      break;
-  }
-
-  *current_position = read_position_;
-  return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::Flush() {
-  // The stream is not writable, so do nothing here.
-  return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::Close() {
-  return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetItem(REFGUID guid_key, PROPVARIANT* value) {
-  if (attributes_.get()) {
-    return attributes_->GetItem(guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetItemType(REFGUID guid_key, MF_ATTRIBUTE_TYPE* type) {
-  if (attributes_.get()) {
-    return attributes_->GetItemType(guid_key, type);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::CompareItem(REFGUID guid_key,
-                                                     REFPROPVARIANT value,
-                                                     BOOL* result) {
-  if (attributes_.get()) {
-    return attributes_->CompareItem(guid_key, value, result);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::Compare(IMFAttributes* theirs,
-                       MF_ATTRIBUTES_MATCH_TYPE match_type,
-                       BOOL* result) {
-  if (attributes_.get()) {
-    return attributes_->Compare(theirs, match_type, result);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetUINT32(REFGUID guid_key, UINT32* value) {
-  if (attributes_.get()) {
-    return attributes_->GetUINT32(guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetUINT64(REFGUID guid_key, UINT64* value) {
-  if (attributes_.get()) {
-    return attributes_->GetUINT64(guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetDouble(REFGUID guid_key, double* value) {
-  if (attributes_.get()) {
-    return attributes_->GetDouble(guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetGUID(REFGUID guid_key, GUID* guid_value) {
-  if (attributes_.get()) {
-    return attributes_->GetGUID(guid_key, guid_value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetStringLength(REFGUID guid_key, UINT32* length) {
-  if (attributes_.get()) {
-    return attributes_->GetStringLength(guid_key, length);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::GetString(REFGUID guid_key,
-                                                   LPWSTR value,
-                                                   UINT32 buf_size,
-                                                   UINT32* length) {
-  if (attributes_.get()) {
-    return attributes_->GetString(guid_key, value, buf_size, length);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetAllocatedString(REFGUID guid_key,
-                                  LPWSTR* value,
-                                  UINT32* length) {
-  if (attributes_.get()) {
-    return attributes_->GetAllocatedString(guid_key, value, length);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetBlobSize(REFGUID guid_key, UINT32* blob_size) {
-  if (attributes_.get()) {
-    return attributes_->GetBlobSize(guid_key, blob_size);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::GetBlob(REFGUID guid_key,
-                                                 UINT8* buf,
-                                                 UINT32 buf_size,
-                                                 UINT32* blob_size) {
-  if (attributes_.get()) {
-    return attributes_->GetBlob(guid_key, buf, buf_size, blob_size);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::GetAllocatedBlob(REFGUID guid_key,
-                                                          UINT8** buf,
-                                                          UINT32* size) {
-  if (attributes_.get()) {
-    return attributes_->GetAllocatedBlob(guid_key, buf, size);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::GetUnknown(REFGUID guid_key, REFIID riid, LPVOID* ppv) {
-  if (attributes_.get()) {
-    return attributes_->GetUnknown(guid_key, riid, ppv);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::SetItem(REFGUID guid_key, REFPROPVARIANT value) {
-  if (attributes_.get()) {
-    return attributes_->SetItem(guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::DeleteItem(REFGUID guid_key) {
-  if (attributes_.get()) {
-    return attributes_->DeleteItem(guid_key);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::DeleteAllItems() {
-  if (attributes_.get()) {
-    return attributes_->DeleteAllItems();
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::SetUINT32(REFGUID guid_key, UINT32 value) {
-  if (attributes_.get()) {
-    return attributes_->SetUINT32(guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::SetUINT64(REFGUID guid_key, UINT64 value) {
-  if (attributes_.get()) {
-    return attributes_->SetUINT64(guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::SetDouble(REFGUID guid_key, double value) {
-  if (attributes_.get()) {
-    return attributes_->SetDouble(guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::SetGUID(REFGUID guid_key, REFGUID guid_value) {
-  if (attributes_.get()) {
-    return attributes_->SetGUID(guid_key, guid_value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::SetString(REFGUID guid_key, LPCWSTR value) {
-  if (attributes_.get()) {
-    return attributes_->SetString(guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::SetBlob(REFGUID guid_key, const UINT8* buf, UINT32 buf_size) {
-  if (attributes_.get()) {
-    return attributes_->SetBlob(guid_key, buf, buf_size);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE
-WMFByteStream::SetUnknown(REFGUID guid_key, IUnknown* unknown) {
-  if (attributes_.get()) {
-    return attributes_->SetUnknown(guid_key, unknown);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::LockStore() {
-  if (attributes_.get()) {
-    return attributes_->LockStore();
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::UnlockStore() {
-  if (attributes_.get()) {
-    return attributes_->UnlockStore();
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::GetCount(UINT32* items) {
-  if (attributes_.get()) {
-    return attributes_->GetCount(items);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::GetItemByIndex(UINT32 index,
-                                                        GUID* guid_key,
-                                                        PROPVARIANT* value) {
-  if (attributes_.get()) {
-    return attributes_->GetItemByIndex(index, guid_key, value);
-  } else {
-    return E_FAIL;
-  }
-}
-
-HRESULT STDMETHODCALLTYPE WMFByteStream::CopyAllItems(IMFAttributes* dest) {
-  if (attributes_.get()) {
-    return attributes_->CopyAllItems(dest);
-  } else {
-    return E_FAIL;
-  }
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/wmf_byte_stream.h b/content/common/gpu/media/wmf_byte_stream.h
deleted file mode 100644
index 81c083f..0000000
--- a/content/common/gpu/media/wmf_byte_stream.h
+++ /dev/null
@@ -1,139 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2013 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_WMF_BYTE_STREAM_H_
-#define CONTENT_COMMON_GPU_MEDIA_WMF_BYTE_STREAM_H_
-
-// Windows Media Foundation headers
-#include <mfapi.h>
-#include <mfidl.h>
-
-#include <vector>
-
-#include "base/threading/thread_checker.h"
-#include "base/win/iunknown_impl.h"
-#include "base/win/scoped_comptr.h"
-#include "media/base/data_source.h"
-
-namespace content {
-
-class WMFByteStream : public IMFByteStream,
-                      public base::win::IUnknownImpl,
-                      public IMFAttributes {
- public:
-  explicit WMFByteStream(media::DataSource* data_source);
-  ~WMFByteStream() override;
-
-  HRESULT Initialize(LPCWSTR mime_type);
-  void Stop();
-
-  // Overrides from IUnknown
-  HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** object) override;
-  ULONG STDMETHODCALLTYPE AddRef() override;
-  ULONG STDMETHODCALLTYPE Release() override;
-
-  // Overrides from IMFByteStream
-  HRESULT STDMETHODCALLTYPE GetCapabilities(DWORD* capabilities) override;
-  HRESULT STDMETHODCALLTYPE GetLength(QWORD* length) override;
-  HRESULT STDMETHODCALLTYPE SetLength(QWORD length) override;
-  HRESULT STDMETHODCALLTYPE GetCurrentPosition(QWORD* position) override;
-  HRESULT STDMETHODCALLTYPE SetCurrentPosition(QWORD position) override;
-  HRESULT STDMETHODCALLTYPE IsEndOfStream(BOOL* end_of_stream) override;
-  HRESULT STDMETHODCALLTYPE Read(BYTE* buff, ULONG len, ULONG* read) override;
-  HRESULT STDMETHODCALLTYPE BeginRead(BYTE* buff, ULONG len,
-                                      IMFAsyncCallback* callback,
-                                      IUnknown* punk_State) override;
-  HRESULT STDMETHODCALLTYPE EndRead(IMFAsyncResult* result,
-                                    ULONG* read) override;
-  HRESULT STDMETHODCALLTYPE Write(const BYTE* buff, ULONG len,
-                                  ULONG* written) override;
-  HRESULT STDMETHODCALLTYPE BeginWrite(const BYTE* buff, ULONG len,
-                                       IMFAsyncCallback* callback,
-                                       IUnknown* punk_state) override;
-  HRESULT STDMETHODCALLTYPE EndWrite(IMFAsyncResult* result,
-                                     ULONG* written) override;
-  HRESULT STDMETHODCALLTYPE Seek(MFBYTESTREAM_SEEK_ORIGIN seek_origin,
-                                 LONGLONG seek_offset, DWORD seek_flags,
-                                 QWORD* current_position) override;
-  HRESULT STDMETHODCALLTYPE Flush() override;
-  HRESULT STDMETHODCALLTYPE Close() override;
-
-  // IMFAttributes methods
-  HRESULT STDMETHODCALLTYPE GetItem(REFGUID guid_key,
-                                    PROPVARIANT* value) override;
-  HRESULT STDMETHODCALLTYPE GetItemType(REFGUID guid_key,
-                                        MF_ATTRIBUTE_TYPE* type) override;
-  HRESULT STDMETHODCALLTYPE CompareItem(REFGUID guid_key, REFPROPVARIANT value,
-                                        BOOL* result) override;
-  HRESULT STDMETHODCALLTYPE Compare(IMFAttributes* theirs,
-                                    MF_ATTRIBUTES_MATCH_TYPE match_type,
-                                    BOOL* result) override;
-  HRESULT STDMETHODCALLTYPE GetUINT32(REFGUID guid_key, UINT32* value) override;
-  HRESULT STDMETHODCALLTYPE GetUINT64(REFGUID guid_vey, UINT64* value) override;
-  HRESULT STDMETHODCALLTYPE GetDouble(REFGUID guid_key, double* value) override;
-  HRESULT STDMETHODCALLTYPE GetGUID(REFGUID guid_key,
-                                    GUID* guid_value) override;
-  HRESULT STDMETHODCALLTYPE GetStringLength(REFGUID guid_key,
-                                            UINT32* length) override;
-  HRESULT STDMETHODCALLTYPE GetString(REFGUID guid_key, LPWSTR value,
-                                      UINT32 buf_size, UINT32* length) override;
-  HRESULT STDMETHODCALLTYPE GetAllocatedString(REFGUID guid_key, LPWSTR* value,
-                                               UINT32* length) override;
-  HRESULT STDMETHODCALLTYPE GetBlobSize(REFGUID guid_key,
-                                        UINT32* blob_size) override;
-  HRESULT STDMETHODCALLTYPE GetBlob(REFGUID guid_key, UINT8* buf,
-                                    UINT32 buf_size,
-                                    UINT32* blob_size) override;
-  HRESULT STDMETHODCALLTYPE GetAllocatedBlob(REFGUID guid_key, UINT8** buf,
-                                             UINT32* size) override;
-  HRESULT STDMETHODCALLTYPE GetUnknown(REFGUID guid_key, REFIID riid,
-                                       LPVOID* ppv) override;
-  HRESULT STDMETHODCALLTYPE SetItem(REFGUID guid_key,
-                                    REFPROPVARIANT value) override;
-  HRESULT STDMETHODCALLTYPE DeleteItem(REFGUID guid_key) override;
-  HRESULT STDMETHODCALLTYPE DeleteAllItems() override;
-  HRESULT STDMETHODCALLTYPE SetUINT32(REFGUID guid_key, UINT32 value) override;
-  HRESULT STDMETHODCALLTYPE SetUINT64(REFGUID guid_key, UINT64 value) override;
-  HRESULT STDMETHODCALLTYPE SetDouble(REFGUID guid_key, double value) override;
-  HRESULT STDMETHODCALLTYPE SetGUID(REFGUID guid_key,
-                                    REFGUID guid_value) override;
-  HRESULT STDMETHODCALLTYPE SetString(REFGUID guid_key, LPCWSTR value) override;
-  HRESULT STDMETHODCALLTYPE SetBlob(REFGUID guid_key, const UINT8* buf,
-                                    UINT32 buf_size) override;
-  HRESULT STDMETHODCALLTYPE SetUnknown(REFGUID guid_key,
-                                       IUnknown* unknown) override;
-  HRESULT STDMETHODCALLTYPE LockStore() override;
-  HRESULT STDMETHODCALLTYPE UnlockStore() override;
-  HRESULT STDMETHODCALLTYPE GetCount(UINT32* items) override;
-  HRESULT STDMETHODCALLTYPE GetItemByIndex(UINT32 index, GUID* guid_key,
-                                           PROPVARIANT* value) override;
-  HRESULT STDMETHODCALLTYPE CopyAllItems(IMFAttributes* dest) override;
-
- private:
-  static const int64_t kUnknownSize;
-
-  void OnReadData(int size);
-
-  media::DataSource* data_source_;
-  media::DataSource::ReadCB read_cb_;
-
-  IMFAsyncResult* async_result_;
-
-  // We implement IMFAttributes by forwarding all calls to an instance of the
-  // standard IMFAttributes class, which we store a reference to here.
-  base::win::ScopedComPtr<IMFAttributes> attributes_;
-
-  // Cached position within the data source.
-  int64_t read_position_;
-
-  bool stopped_;
-
-  base::ThreadChecker thread_checker_;
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_WMF_BYTE_STREAM_H_
diff --git a/content/common/gpu/media/wmf_media_pipeline.cc b/content/common/gpu/media/wmf_media_pipeline.cc
deleted file mode 100644
index d594bf3..0000000
--- a/content/common/gpu/media/wmf_media_pipeline.cc
+++ /dev/null
@@ -1,1562 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/common/gpu/media/wmf_media_pipeline.h"
-
-#include <Mferror.h>
-
-#include <algorithm>
-#include <string>
-
-#include "base/callback_helpers.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/task_runner_util.h"
-#include "base/time/time.h"
-#include "base/trace_event/trace_event.h"
-#include "media/base/bind_to_current_loop.h"
-#include "media/base/data_buffer.h"
-#include "media/base/platform_mime_util.h"
-#include "media/base/timestamp_constants.h"
-#include "media/base/win/mf_initializer.h"
-#include "media/base/win/mf_util.h"
-#include "media/filters/platform_media_pipeline_constants.h"
-#include "ui/gl/gl_context.h"
-#include "ui/gl/gl_surface_egl.h"
-
-namespace content {
-
-namespace {
-
-const int kMicrosecondsPerSecond = 1000000;
-const int kHundredsOfNanosecondsPerSecond = 10000000;
-
-class AutoPropVariant {
- public:
-  AutoPropVariant();
-  ~AutoPropVariant();
-
-  PROPVARIANT* get() { return &var; }
-  PROPVARIANT& get_ref() { return var; }
-
-  HRESULT ToInt64(LONGLONG* ret);
-  HRESULT ToInt32(int* ret);
-
- private:
-  PROPVARIANT var;
-};  // class AutoPropVariant
-
-class SourceReaderCallback : public IMFSourceReaderCallback {
- public:
-  using OnReadSampleCB =
-      base::Callback<void(media::MediaDataStatus status,
-                          DWORD stream_index,
-                          const base::win::ScopedComPtr<IMFSample>& sample)>;
-
-  explicit SourceReaderCallback(const OnReadSampleCB& on_read_sample_cb);
-
-  // IUnknown methods
-  STDMETHODIMP QueryInterface(REFIID iid, void** ppv) override;
-  STDMETHODIMP_(ULONG) AddRef() override;
-  STDMETHODIMP_(ULONG) Release() override;
-
-  // IMFSourceReaderCallback methods
-  STDMETHODIMP OnReadSample(HRESULT status,
-                            DWORD stream_index,
-                            DWORD stream_flags,
-                            LONGLONG timestamp_hns,
-                            IMFSample* unwrapped_sample) override;
-  STDMETHODIMP OnEvent(DWORD, IMFMediaEvent*) override;
-  STDMETHODIMP OnFlush(DWORD) override;
-
- private:
-  // Destructor is private. Caller should call Release.
-  virtual ~SourceReaderCallback() {}
-
-  OnReadSampleCB on_read_sample_cb_;
-  LONG reference_count_;
-
-  DISALLOW_COPY_AND_ASSIGN(SourceReaderCallback);
-};  // class SourceReaderCallback
-
-AutoPropVariant::AutoPropVariant() {
-  PropVariantInit(&var);
-}
-
-AutoPropVariant::~AutoPropVariant() {
-  PropVariantClear(&var);
-}
-
-HRESULT AutoPropVariant::ToInt64(LONGLONG* ret) {
-  return PropVariantToInt64(var, ret);
-}
-
-HRESULT AutoPropVariant::ToInt32(int* ret) {
-  return PropVariantToInt32(var, ret);
-}
-
-SourceReaderCallback::SourceReaderCallback(
-    const OnReadSampleCB& on_read_sample_cb)
-    : on_read_sample_cb_(on_read_sample_cb), reference_count_(1) {
-  DCHECK(!on_read_sample_cb.is_null());
-}
-
-STDMETHODIMP SourceReaderCallback::QueryInterface(REFIID iid, void** ppv) {
-  static const QITAB qit[] = {
-      QITABENT(SourceReaderCallback, IMFSourceReaderCallback), {0},
-  };
-  return QISearch(this, qit, iid, ppv);
-}
-
-STDMETHODIMP_(ULONG) SourceReaderCallback::AddRef() {
-  return InterlockedIncrement(&reference_count_);
-}
-
-STDMETHODIMP_(ULONG) SourceReaderCallback::Release() {
-  ULONG uCount = InterlockedDecrement(&reference_count_);
-  if (uCount == 0) {
-    delete this;
-  }
-  return uCount;
-}
-
-STDMETHODIMP SourceReaderCallback::OnReadSample(HRESULT status,
-                                                DWORD stream_index,
-                                                DWORD stream_flags,
-                                                LONGLONG timestamp_hns,
-                                                IMFSample* unwrapped_sample) {
-  base::win::ScopedComPtr<IMFSample> sample(unwrapped_sample);
-
-  if (FAILED(status)) {
-    on_read_sample_cb_.Run(media::MediaDataStatus::kError, stream_index,
-                           sample);
-    return S_OK;
-  }
-
-  if (stream_flags & MF_SOURCE_READERF_ENDOFSTREAM) {
-    on_read_sample_cb_.Run(media::MediaDataStatus::kEOS, stream_index, sample);
-    return S_OK;
-  }
-
-  if (stream_flags & MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED) {
-    on_read_sample_cb_.Run(media::MediaDataStatus::kConfigChanged, stream_index,
-                           sample);
-    return S_OK;
-  }
-
-  if (!sample) {
-    // NULL |sample| can occur when there is a gap in the stream what
-    // is signalled by |MF_SOURCE_READERF_STREAMTICK| flag but from the sparse
-    // documentation that can be found on the subject it seems to be used only
-    // with "live sources" of AV data (like cameras?), so we should be safe to
-    // ignore it
-    DCHECK(!(stream_flags & MF_SOURCE_READERF_STREAMTICK));
-    on_read_sample_cb_.Run(media::MediaDataStatus::kError, stream_index,
-                           sample);
-    return E_ABORT;
-  }
-
-  on_read_sample_cb_.Run(media::MediaDataStatus::kOk, stream_index, sample);
-  return S_OK;
-}
-
-STDMETHODIMP SourceReaderCallback::OnEvent(DWORD, IMFMediaEvent*) {
-  return S_OK;
-}
-
-STDMETHODIMP SourceReaderCallback::OnFlush(DWORD) {
-  return S_OK;
-}
-
-// Helper function that counts how many bits are set in the input number.
-int NumberOfSetBits(uint32_t i) {
-  int number_of_set_bits = 0;
-  while (i > 0) {
-    if (i & 1) {
-      number_of_set_bits++;
-    }
-    i = i >> 1;
-  }
-  return number_of_set_bits;
-}
-
-}  // namespace
-
-class WMFMediaPipeline::AudioTimestampCalculator {
- public:
-  AudioTimestampCalculator();
-  ~AudioTimestampCalculator() {}
-
-  void SetChannelCount(int channel_count);
-  void SetBytesPerSample(int bytes_per_sample);
-  void SetSamplesPerSecond(int samples_per_second);
-  void RecapturePosition();
-
-  int64_t GetFramesCount(int64_t data_size);
-  base::TimeDelta GetTimestamp(int64_t timestamp_hns, bool discontinuity);
-  base::TimeDelta GetDuration(int64_t frames_count);
-  void UpdateFrameCounter(int64_t frames_count);
-
- private:
-  int channel_count_;
-  int bytes_per_sample_;
-  int samples_per_second_;
-  int64_t frame_sum_;
-  int64_t frame_offset_;
-  bool must_recapture_position_;
-};  // class WMFMediaPipeline::AudioTimestampCalculator
-
-struct WMFMediaPipeline::Direct3DContext {
- public:
-  Direct3DContext() : dev_manager_reset_token(0) {}
-
-  bool Initialize();
-
-  base::win::ScopedComPtr<IDirect3D9Ex> d3d9;
-  base::win::ScopedComPtr<IDirect3DDevice9Ex> device;
-  base::win::ScopedComPtr<IDirect3DDeviceManager9> device_manager;
-  base::win::ScopedComPtr<IDirect3DQuery9> query;
-  uint32_t dev_manager_reset_token;
-};  // class WMFMediaPipeline::Direct3DContext
-
-class WMFMediaPipeline::DXVAPictureBuffer {
- public:
-  ~DXVAPictureBuffer();
-  static scoped_ptr<DXVAPictureBuffer> Create(
-      uint32_t texture_id,
-      gfx::Size texture_size,
-      EGLConfig EGL_config,
-      IDirect3DDevice9Ex* direct3d_device);
-  bool Fill(const Direct3DContext& direct3d_context,
-            IDirect3DSurface9* source_surface);
-  void Reuse();
-
- private:
-  DXVAPictureBuffer(uint32_t texture_id,
-                    gfx::Size texture_size,
-                    EGLConfig EGL_config)
-      : texture_id_(texture_id),
-        texture_size_(texture_size),
-        decoding_surface_(NULL),
-        use_rgb_(true) {}
-
-  static const int kMaxIterationsForD3DFlush{10};
-
-  uint32_t texture_id_;
-  gfx::Size texture_size_;
-  EGLSurface decoding_surface_;
-  bool use_rgb_;
-  base::win::ScopedComPtr<IDirect3DTexture9> decoding_texture_;
-};  // class WMFMediaPipeline::DXVAPictureBuffer
-
-WMFMediaPipeline::AudioTimestampCalculator::AudioTimestampCalculator()
-    : channel_count_(0),
-      bytes_per_sample_(0),
-      samples_per_second_(0),
-      frame_sum_(0),
-      frame_offset_(0),
-      must_recapture_position_(false) {
-}
-
-void WMFMediaPipeline::AudioTimestampCalculator::SetChannelCount(
-    int channel_count) {
-  channel_count_ = channel_count;
-}
-
-void WMFMediaPipeline::AudioTimestampCalculator::SetBytesPerSample(
-    int bytes_per_sample) {
-  bytes_per_sample_ = bytes_per_sample;
-}
-
-void WMFMediaPipeline::AudioTimestampCalculator::SetSamplesPerSecond(
-    int samples_per_second) {
-  samples_per_second_ = samples_per_second;
-}
-
-void WMFMediaPipeline::AudioTimestampCalculator::RecapturePosition() {
-  must_recapture_position_ = true;
-}
-
-int64_t WMFMediaPipeline::AudioTimestampCalculator::GetFramesCount(
-    int64_t data_size) {
-  return data_size / bytes_per_sample_ / channel_count_;
-}
-
-base::TimeDelta WMFMediaPipeline::AudioTimestampCalculator::GetTimestamp(
-    int64_t timestamp_hns,
-    bool discontinuity) {
-  // If this sample block comes after a discontinuity (i.e. a gap or seek)
-  // reset the frame counters, and capture the timestamp. Future timestamps
-  // will be offset from this block's timestamp.
-  if (must_recapture_position_ || discontinuity != 0) {
-    frame_sum_ = 0;
-    frame_offset_ =
-        timestamp_hns * samples_per_second_ / kHundredsOfNanosecondsPerSecond;
-    must_recapture_position_ = false;
-  }
-  return base::TimeDelta::FromMicroseconds((frame_offset_ + frame_sum_) *
-                                           kMicrosecondsPerSecond /
-                                           samples_per_second_);
-}
-
-base::TimeDelta WMFMediaPipeline::AudioTimestampCalculator::GetDuration(
-    int64_t frames_count) {
-  return base::TimeDelta::FromMicroseconds(
-      frames_count * kMicrosecondsPerSecond / samples_per_second_);
-}
-
-void WMFMediaPipeline::AudioTimestampCalculator::UpdateFrameCounter(
-    int64_t frames_count) {
-  frame_sum_ += frames_count;
-}
-
-WMFMediaPipeline::DXVAPictureBuffer::~DXVAPictureBuffer() {
-  if (decoding_surface_) {
-    EGLDisplay egl_display = gfx::GLSurfaceEGL::GetHardwareDisplay();
-
-    eglReleaseTexImage(egl_display, decoding_surface_, EGL_BACK_BUFFER);
-    eglDestroySurface(egl_display, decoding_surface_);
-  }
-}
-
-scoped_ptr<WMFMediaPipeline::DXVAPictureBuffer>
-WMFMediaPipeline::DXVAPictureBuffer::Create(
-    uint32_t texture_id,
-    gfx::Size texture_size,
-    EGLConfig egl_config,
-    IDirect3DDevice9Ex* direct3d_device) {
-  if (!gfx::GLContext::GetCurrent())
-    return nullptr;
-
-  scoped_ptr<DXVAPictureBuffer> dxva_picture_buffer(
-      new DXVAPictureBuffer(texture_id, texture_size, egl_config));
-
-  EGLDisplay egl_display = gfx::GLSurfaceEGL::GetHardwareDisplay();
-
-  EGLint use_rgb = 1;
-  eglGetConfigAttrib(egl_display, egl_config, EGL_BIND_TO_TEXTURE_RGB,
-                     &use_rgb);
-
-  EGLint attrib_list[] = {EGL_WIDTH,
-                          texture_size.width(),
-                          EGL_HEIGHT,
-                          texture_size.height(),
-                          EGL_TEXTURE_FORMAT,
-                          use_rgb ? EGL_TEXTURE_RGB : EGL_TEXTURE_RGBA,
-                          EGL_TEXTURE_TARGET,
-                          EGL_TEXTURE_2D,
-                          EGL_NONE};
-
-  dxva_picture_buffer->decoding_surface_ =
-      eglCreatePbufferSurface(egl_display, egl_config, attrib_list);
-  if (!dxva_picture_buffer->decoding_surface_) {
-    DLOG(ERROR) << "Failed to create surface";
-    return nullptr;
-  }
-
-  dxva_picture_buffer->use_rgb_ = use_rgb != 0;
-
-  HANDLE share_handle = nullptr;
-  EGLBoolean ret = eglQuerySurfacePointerANGLE(
-      egl_display, dxva_picture_buffer->decoding_surface_,
-      EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE, &share_handle);
-
-  if (!share_handle || ret != EGL_TRUE) {
-    DLOG(ERROR) << "Failed to query ANGLE surface pointer";
-    return nullptr;
-  }
-
-  HRESULT hr = direct3d_device->CreateTexture(
-      dxva_picture_buffer->texture_size_.width(),
-      dxva_picture_buffer->texture_size_.height(), 1, D3DUSAGE_RENDERTARGET,
-      dxva_picture_buffer->use_rgb_ ? D3DFMT_X8R8G8B8 : D3DFMT_A8R8G8B8,
-      D3DPOOL_DEFAULT, dxva_picture_buffer->decoding_texture_.Receive(),
-      &share_handle);
-
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to create texture";
-    return nullptr;
-  }
-
-  return dxva_picture_buffer;
-}
-
-bool WMFMediaPipeline::DXVAPictureBuffer::Fill(
-    const Direct3DContext& direct3d_context,
-    IDirect3DSurface9* source_surface) {
-  if (!gfx::GLContext::GetCurrent())
-    return false;
-
-  D3DSURFACE_DESC surface_desc;
-  HRESULT hr = source_surface->GetDesc(&surface_desc);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to get surface description";
-    return false;
-  }
-
-  // TODO(ggacek): check if dimensions of source and destination texture match.
-  hr = direct3d_context.d3d9->CheckDeviceFormatConversion(
-      D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, surface_desc.Format,
-      use_rgb_ ? D3DFMT_X8R8G8B8 : D3DFMT_A8R8G8B8);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Device does not support format converision";
-    return false;
-  }
-
-  GLint current_texture = 0;
-  glGetIntegerv(GL_TEXTURE_BINDING_2D, &current_texture);
-
-  glBindTexture(media::kPlatformMediaPipelineTextureTarget, texture_id_);
-
-  glTexParameteri(media::kPlatformMediaPipelineTextureTarget,
-                  GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-
-  base::win::ScopedComPtr<IDirect3DSurface9> d3d_surface;
-  hr = decoding_texture_->GetSurfaceLevel(0, d3d_surface.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to get surface from texture";
-    return false;
-  }
-
-  hr = direct3d_context.device->StretchRect(
-      source_surface, NULL, d3d_surface.get(), NULL, D3DTEXF_NONE);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Colorspace conversion via StretchRect failed";
-    return false;
-  }
-
-  // Ideally, this should be done immediately before the draw call that uses
-  // the texture. Flush it once here though.
-  hr = direct3d_context.query->Issue(D3DISSUE_END);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to issue END";
-    return false;
-  }
-
-  // The DXVA decoder has its own device which it uses for decoding. ANGLE
-  // has its own device which we don't have access to.
-  // The above code attempts to copy the decoded picture into a surface
-  // which is owned by ANGLE. As there are multiple devices involved in
-  // this, the StretchRect call above is not synchronous.
-  // We attempt to flush the batched operations to ensure that the picture is
-  // copied to the surface owned by ANGLE.
-  // We need to do this in a loop and call flush multiple times.
-  // We have seen the GetData call for flushing the command buffer fail to
-  // return success occassionally on multi core machines, leading to an
-  // infinite loop.
-  // Workaround is to have an upper limit of 10 on the number of iterations to
-  // wait for the Flush to finish.
-  int iterations = 0;
-  while (
-      (direct3d_context.query->GetData(NULL, 0, D3DGETDATA_FLUSH) == S_FALSE) &&
-      ++iterations < kMaxIterationsForD3DFlush) {
-    Sleep(1);  // Poor-man's Yield().
-  }
-
-  EGLDisplay egl_display = gfx::GLSurfaceEGL::GetHardwareDisplay();
-  eglBindTexImage(egl_display, decoding_surface_, EGL_BACK_BUFFER);
-  glTexParameteri(media::kPlatformMediaPipelineTextureTarget,
-                  GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-  glBindTexture(media::kPlatformMediaPipelineTextureTarget, current_texture);
-
-  return true;
-}
-
-void WMFMediaPipeline::DXVAPictureBuffer::Reuse() {
-  DCHECK(decoding_surface_);
-  DCHECK(gfx::GLContext::GetCurrent());
-
-  EGLDisplay egl_display = gfx::GLSurfaceEGL::GetHardwareDisplay();
-  eglReleaseTexImage(egl_display, decoding_surface_, EGL_BACK_BUFFER);
-}
-
-bool WMFMediaPipeline::Direct3DContext::Initialize() {
-  HRESULT hr = Direct3DCreate9Ex(D3D_SDK_VERSION, d3d9.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Direct3DCreate9Ex failed";
-    return false;
-  }
-
-  D3DPRESENT_PARAMETERS present_params = {0};
-  present_params.BackBufferWidth = 1;
-  present_params.BackBufferHeight = 1;
-  present_params.BackBufferFormat = D3DFMT_UNKNOWN;
-  present_params.BackBufferCount = 1;
-  present_params.SwapEffect = D3DSWAPEFFECT_DISCARD;
-  present_params.hDeviceWindow = ::GetShellWindow();
-  present_params.Windowed = TRUE;
-  present_params.Flags = D3DPRESENTFLAG_VIDEO;
-
-  hr = d3d9->CreateDeviceEx(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
-                            ::GetShellWindow(),
-                            D3DCREATE_FPU_PRESERVE | D3DCREATE_MULTITHREADED |
-                                D3DCREATE_MIXED_VERTEXPROCESSING,
-                            &present_params, NULL, device.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to create D3D device";
-    return false;
-  }
-
-  hr = DXVA2CreateDirect3DDeviceManager9(&dev_manager_reset_token,
-                                         device_manager.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "DXVA2CreateDirect3DDeviceManager9 failed";
-    return false;
-  }
-
-  hr = device_manager->ResetDevice(device.get(), dev_manager_reset_token);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to reset device";
-    return false;
-  }
-
-  hr = device->CreateQuery(D3DQUERYTYPE_EVENT, query.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to create D3D device query";
-    return false;
-  }
-  // Ensure query API works.
-  hr = query->Issue(D3DISSUE_END);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to issue END test query";
-    return false;
-  }
-
-  return true;
-}
-
-struct WMFMediaPipeline::InitializationResult {
-  InitializationResult()
-      : source_reader_output_video_format(MFVideoFormat_YV12),
-        video_decoding_mode(media::PlatformMediaDecodingMode::SOFTWARE) {}
-
-  GUID source_reader_output_video_format;
-  Direct3DContext direct3d_context;
-  media::PlatformMediaDecodingMode video_decoding_mode;
-  base::win::ScopedComPtr<IMFSourceReader> source_reader;
-};
-
-WMFMediaPipeline::WMFMediaPipeline(
-    media::DataSource* data_source,
-    const AudioConfigChangedCB& audio_config_changed_cb,
-    const VideoConfigChangedCB& video_config_changed_cb,
-    media::PlatformMediaDecodingMode preferred_video_decoding_mode,
-    const MakeGLContextCurrentCB& make_gl_context_current_cb)
-    : data_source_(data_source),
-      audio_config_changed_cb_(audio_config_changed_cb),
-      video_config_changed_cb_(video_config_changed_cb),
-      source_reader_creation_thread_("source_reader_creation_thread"),
-      input_video_subtype_guid_(GUID_NULL),
-      audio_timestamp_calculator_(new AudioTimestampCalculator),
-      source_reader_output_video_format_(MFVideoFormat_YV12),
-      make_gl_context_current_cb_(make_gl_context_current_cb),
-      egl_config_(preferred_video_decoding_mode ==
-                          media::PlatformMediaDecodingMode::HARDWARE
-                      ? GetEGLConfig(make_gl_context_current_cb)
-                      : nullptr),
-      current_dxva_picture_buffer_(nullptr),
-      get_stride_function_(nullptr),
-      weak_ptr_factory_(this) {
-  DCHECK(!audio_config_changed_cb_.is_null());
-  DCHECK(!video_config_changed_cb_.is_null());
-  std::fill(stream_indices_,
-            stream_indices_ + media::PLATFORM_MEDIA_DATA_TYPE_COUNT,
-            static_cast<DWORD>(MF_SOURCE_READER_INVALID_STREAM_INDEX));
-}
-
-WMFMediaPipeline::~WMFMediaPipeline() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  if (byte_stream_)
-    byte_stream_->Stop();
-}
-
-// static
-EGLConfig WMFMediaPipeline::GetEGLConfig(
-    const MakeGLContextCurrentCB& make_gl_context_current_cb) {
-  DCHECK(!make_gl_context_current_cb.is_null());
-  if (!make_gl_context_current_cb.Run())
-    return nullptr;
-
-  EGLDisplay egl_display = gfx::GLSurfaceEGL::GetHardwareDisplay();
-
-  EGLint config_attribs[] = {EGL_BUFFER_SIZE, 32,
-                             EGL_RED_SIZE, 8,
-                             EGL_GREEN_SIZE, 8,
-                             EGL_BLUE_SIZE, 8,
-                             EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
-                             EGL_ALPHA_SIZE, 0,
-                             EGL_NONE};
-
-  EGLConfig egl_config = nullptr;
-  EGLint num_configs;
-  if (!eglChooseConfig(egl_display, config_attribs, &egl_config, 1,
-                       &num_configs)) {
-    return nullptr;
-  }
-
-  return egl_config;
-}
-
-// static
-WMFMediaPipeline::InitializationResult WMFMediaPipeline::CreateSourceReader(
-    const scoped_refptr<WMFByteStream>& byte_stream,
-    const base::win::ScopedComPtr<IMFAttributes>& attributes,
-    media::PlatformMediaDecodingMode preferred_decoding_mode) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(attributes);
-
-  if (preferred_decoding_mode == media::PlatformMediaDecodingMode::HARDWARE) {
-    InitializationResult result;
-    if (CreateDXVASourceReader(byte_stream, attributes, &result))
-      return result;
-  }
-
-  // Fall back to SW SourceReader.
-  InitializationResult result;
-  const HRESULT hr = MFCreateSourceReaderFromByteStream(
-      byte_stream.get(), attributes.get(), result.source_reader.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to create source reader.";
-    // We use (result.source_reader != NULL) as status.
-    result.source_reader.Release();
-  }
-
-  return result;
-}
-
-// static
-bool WMFMediaPipeline::CreateDXVASourceReader(
-    const scoped_refptr<WMFByteStream>& byte_stream,
-    const base::win::ScopedComPtr<IMFAttributes>& attributes,
-    InitializationResult* result) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(attributes);
-
-  if (!result->direct3d_context.Initialize())
-    return false;
-
-  base::win::ScopedComPtr<IMFAttributes> attributes_hw;
-  HRESULT hr = MFCreateAttributes(attributes_hw.Receive(), 1);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to create source reader attributes.";
-    return false;
-  }
-
-  hr = attributes->CopyAllItems(attributes_hw.get());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to create source reader attributes.";
-    return false;
-  }
-
-  hr = attributes_hw->SetUnknown(MF_SOURCE_READER_D3D_MANAGER,
-                                 result->direct3d_context.device_manager.get());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to set d3d device manager attribute.";
-    return false;
-  }
-
-  hr = attributes_hw->SetUINT32(MF_SOURCE_READER_DISABLE_DXVA, FALSE);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to set DXVA attribute.";
-    return false;
-  }
-
-  hr = MFCreateSourceReaderFromByteStream(
-      byte_stream.get(), attributes_hw.get(), result->source_reader.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to create source reader with DXVA support.";
-    return false;
-  }
-
-  result->video_decoding_mode = media::PlatformMediaDecodingMode::HARDWARE;
-
-  // MSDN shyly mentions that it is only preferred format for DXVA
-  // decoding but in reality setting other formats results in flawless
-  // configuration but MF_E_INVALIDMEDIATYPE when reading samples.
-  result->source_reader_output_video_format = MFVideoFormat_NV12;
-
-  return true;
-}
-
-void WMFMediaPipeline::Initialize(const std::string& mime_type,
-                                  const InitializeCB& initialize_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(!source_reader_.get());
-  DCHECK(data_source_);
-
-  // For diagnostics, the attempted video decoding mode is at least as
-  // interesting on failure as it is on success.
-  video_config_.decoding_mode =
-      egl_config_ ? media::PlatformMediaDecodingMode::HARDWARE
-                  : media::PlatformMediaDecodingMode::SOFTWARE;
-
-  if (!InitializeImpl(mime_type, initialize_cb)) {
-    initialize_cb.Run(false, -1, media::PlatformMediaTimeInfo(),
-                      media::PlatformAudioConfig(), video_config_);
-  }
-}
-
-bool WMFMediaPipeline::InitializeImpl(const std::string& mime_type,
-                                      const InitializeCB& initialize_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  // We've already made this check in WebMediaPlayerImpl, but that's been in
-  // a different process, so let's take its result with a grain of salt.
-  const bool has_platform_support = media::IsPlatformMediaPipelineAvailable(
-      media::PlatformMediaCheckType::FULL);
-
-  get_stride_function_ = reinterpret_cast<decltype(get_stride_function_)>(
-      media::GetFunctionFromLibrary("MFGetStrideForBitmapInfoHeader",
-                                    "evr.dll"));
-
-  if (!has_platform_support || !get_stride_function_) {
-    DVLOG(1) << "Can't access required media libraries in the system";
-    return false;
-  }
-
-  media::InitializeMediaFoundation();
-
-  base::win::ScopedComPtr<IMFAttributes> source_reader_attributes;
-  if (!CreateSourceReaderCallbackAndAttributes(&source_reader_attributes)) {
-    DVLOG(1) << "Failed to create source reader attributes";
-    return false;
-  }
-
-  byte_stream_ = new WMFByteStream(data_source_);
-  if (FAILED(byte_stream_->Initialize(
-          std::wstring(mime_type.begin(), mime_type.end()).c_str()))) {
-    DVLOG(1) << "Failed to create byte stream.";
-    return false;
-  }
-
-  // |byte_stream_| is created and destroyed on |media_pipeline_thread| and
-  // uses WeakPtr to |this| in its OnReadData callback, so we need to run it on
-  // the same thread. When SourceReader is created it spawns another thread to
-  // read some data (using our |byte_stream_|) and blocks current thread. As
-  // we want WMFByteStream::OnReadSample to run on |media_pipeline-thread| we
-  // need to move SourceReader creation to separate thread to avoid deadlock.
-  if (!source_reader_creation_thread_.Start())
-    return false;
-
-  return base::PostTaskAndReplyWithResult(
-      source_reader_creation_thread_.task_runner().get(), FROM_HERE,
-      base::Bind(&WMFMediaPipeline::CreateSourceReader, byte_stream_,
-                 source_reader_attributes, video_config_.decoding_mode),
-      base::Bind(&WMFMediaPipeline::FinalizeInitialization,
-                 weak_ptr_factory_.GetWeakPtr(), initialize_cb));
-}
-
-void WMFMediaPipeline::FinalizeInitialization(
-    const InitializeCB& initialize_cb,
-    const InitializationResult& result) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  source_reader_creation_thread_.Stop();
-
-  media::PlatformMediaTimeInfo time_info;
-  int bitrate = 0;
-  media::PlatformAudioConfig audio_config;
-
-  // Store the decoding mode eventually attempted (takes HW->SW fallback into
-  // account).
-  video_config_.decoding_mode = result.video_decoding_mode;
-
-  if (!result.source_reader) {
-    initialize_cb.Run(false, bitrate, time_info, audio_config, video_config_);
-    return;
-  }
-
-  source_reader_ = result.source_reader;
-  direct3d_context_.reset(new Direct3DContext(result.direct3d_context));
-  source_reader_output_video_format_ = result.source_reader_output_video_format;
-
-  if (!RetrieveStreamIndices()) {
-    DVLOG(1) << "Failed to find streams";
-    initialize_cb.Run(false, bitrate, time_info, audio_config, video_config_);
-    return;
-  }
-
-  if (!ConfigureSourceReader()) {
-    initialize_cb.Run(false, bitrate, time_info, audio_config, video_config_);
-    return;
-  }
-
-  time_info.duration = GetDuration();
-  bitrate = GetBitrate(time_info.duration);
-
-  if (HasMediaStream(media::PLATFORM_MEDIA_AUDIO)) {
-    if (!GetAudioDecoderConfig(&audio_config)) {
-      initialize_cb.Run(false, bitrate, time_info, audio_config, video_config_);
-      return;
-    }
-  }
-
-  if (HasMediaStream(media::PLATFORM_MEDIA_VIDEO)) {
-    if (!GetVideoDecoderConfig(&video_config_)) {
-      initialize_cb.Run(false, bitrate, time_info, audio_config, video_config_);
-      return;
-    }
-  }
-
-  initialize_cb.Run(true, bitrate, time_info, audio_config, video_config_);
-}
-
-void WMFMediaPipeline::ReadAudioData(const ReadDataCB& read_audio_data_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(read_audio_data_cb_.is_null());
-  DCHECK(source_reader_.get());
-
-  // We might have some data ready to send.
-  if (pending_decoded_data_[media::PLATFORM_MEDIA_AUDIO]) {
-    read_audio_data_cb.Run(pending_decoded_data_[media::PLATFORM_MEDIA_AUDIO]);
-    pending_decoded_data_[media::PLATFORM_MEDIA_AUDIO] = nullptr;
-    return;
-  }
-
-  // Read the next sample using asynchronous mode.
-  // http://msdn.microsoft.com/en-us/library/windows/desktop/gg583871(v=vs.85).aspx
-  HRESULT hr =
-      source_reader_->ReadSample(stream_indices_[media::PLATFORM_MEDIA_AUDIO],
-                                 0, nullptr, nullptr, nullptr, nullptr);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to read audio sample";
-    read_audio_data_cb.Run(nullptr);
-    return;
-  }
-
-  read_audio_data_cb_ = read_audio_data_cb;
-}
-
-void WMFMediaPipeline::ReadVideoData(const ReadDataCB& read_video_data_cb,
-                                     uint32_t texture_id) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(read_video_data_cb_.is_null());
-  DCHECK(!current_dxva_picture_buffer_);
-
-  // We might have some data ready to send.
-  if (pending_decoded_data_[media::PLATFORM_MEDIA_VIDEO]) {
-    read_video_data_cb.Run(pending_decoded_data_[media::PLATFORM_MEDIA_VIDEO]);
-    pending_decoded_data_[media::PLATFORM_MEDIA_VIDEO] = nullptr;
-    return;
-  }
-
-  if (video_config_.decoding_mode ==
-      media::PlatformMediaDecodingMode::HARDWARE) {
-    current_dxva_picture_buffer_ = GetDXVAPictureBuffer(texture_id);
-    if (!current_dxva_picture_buffer_) {
-      DLOG(ERROR) << "Failed to create DXVAPictureBuffer.";
-      read_video_data_cb.Run(nullptr);
-      return;
-    }
-  }
-
-  DCHECK(source_reader_.get());
-
-  // Read the next sample using asynchronous mode.
-  // http://msdn.microsoft.com/en-us/library/windows/desktop/gg583871(v=vs.85).aspx
-  HRESULT hr =
-      source_reader_->ReadSample(stream_indices_[media::PLATFORM_MEDIA_VIDEO],
-                                 0, nullptr, nullptr, nullptr, nullptr);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to read video sample";
-    read_video_data_cb.Run(nullptr);
-    return;
-  }
-
-  read_video_data_cb_ = read_video_data_cb;
-}
-
-void WMFMediaPipeline::OnReadSample(
-    media::MediaDataStatus status,
-    DWORD stream_index,
-    const base::win::ScopedComPtr<IMFSample>& sample) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  PlatformMediaPipeline::ReadDataCB* read_data_cb = nullptr;
-  media::PlatformMediaDataType media_type = media::PLATFORM_MEDIA_AUDIO;
-  if (stream_index == stream_indices_[media::PLATFORM_MEDIA_AUDIO]) {
-    read_data_cb = &read_audio_data_cb_;
-  } else if (stream_index == stream_indices_[media::PLATFORM_MEDIA_VIDEO]) {
-    media_type = media::PLATFORM_MEDIA_VIDEO;
-    read_data_cb = &read_video_data_cb_;
-  } else {
-    NOTREACHED() << "Unknown stream type";
-  }
-  DCHECK(!(*read_data_cb).is_null());
-  DCHECK(!pending_decoded_data_[media_type]);
-
-  scoped_refptr<media::DataBuffer> data_buffer;
-  switch (status) {
-    case media::kOk:
-      DCHECK(sample);
-      data_buffer = CreateDataBuffer(sample.get(), media_type);
-      break;
-
-    case media::kEOS:
-      data_buffer = media::DataBuffer::CreateEOSBuffer();
-      break;
-
-    case media::kError:
-      break;
-
-    case media::kConfigChanged: {
-      // Chromium's pipeline does not want any decoded data when we report
-      // that configuration has changed. We need to buffer the sample and
-      // send it during next read operation.
-      pending_decoded_data_[media_type] =
-          CreateDataBuffer(sample.get(), media_type);
-
-      if (media_type == media::PLATFORM_MEDIA_AUDIO) {
-        media::PlatformAudioConfig audio_config;
-        if (GetAudioDecoderConfig(&audio_config)) {
-          read_audio_data_cb_.Reset();
-          audio_config_changed_cb_.Run(audio_config);
-          return;
-        }
-
-        DLOG(ERROR) << "Error while getting decoder audio configuration.";
-        status = media::kError;
-        break;
-      } else if (media_type == media::PLATFORM_MEDIA_VIDEO) {
-        media::PlatformVideoConfig video_config;
-        if (GetVideoDecoderConfig(&video_config)) {
-          current_dxva_picture_buffer_ = nullptr;
-          read_video_data_cb_.Reset();
-          video_config_changed_cb_.Run(video_config);
-          return;
-        }
-
-        DLOG(ERROR) << "Error while getting decoder video configuration.";
-        status = media::kError;
-        break;
-      }
-      // Fallthrough.
-    }
-
-    default:
-      NOTREACHED();
-  }
-
-  if (stream_index == stream_indices_[media::PLATFORM_MEDIA_VIDEO]) {
-    current_dxva_picture_buffer_ = nullptr;
-  }
-  base::ResetAndReturn(read_data_cb).Run(data_buffer);
-}
-
-scoped_refptr<media::DataBuffer> WMFMediaPipeline::CreateDataBufferFromMemory(
-    IMFSample* sample) {
-  // Get a pointer to the IMFMediaBuffer in the sample.
-  base::win::ScopedComPtr<IMFMediaBuffer> output_buffer;
-  HRESULT hr = sample->ConvertToContiguousBuffer(output_buffer.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to get pointer to data in sample.";
-    return nullptr;
-  }
-
-  // Get the actual data from the IMFMediaBuffer
-  uint8_t* data = nullptr;
-  DWORD data_size = 0;
-  hr = output_buffer->Lock(&data, NULL, &data_size);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to lock buffer.";
-    return nullptr;
-  }
-  scoped_refptr<media::DataBuffer> data_buffer =
-      media::DataBuffer::CopyFrom(data, data_size);
-
-  // Unlock the IMFMediaBuffer buffer.
-  output_buffer->Unlock();
-
-  return data_buffer;
-}
-
-scoped_refptr<media::DataBuffer> WMFMediaPipeline::CreateDataBufferFromTexture(
-    IMFSample* sample) {
-  DCHECK(current_dxva_picture_buffer_);
-  DCHECK(direct3d_context_);
-
-  if (!make_gl_context_current_cb_.Run())
-    return nullptr;
-
-  base::win::ScopedComPtr<IMFMediaBuffer> output_buffer;
-  HRESULT hr = sample->GetBufferByIndex(0, output_buffer.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to get buffer from output sample.";
-    return nullptr;
-  }
-
-  base::win::ScopedComPtr<IDirect3DSurface9> surface;
-  hr = MFGetService(output_buffer.get(), MR_BUFFER_SERVICE,
-                    IID_PPV_ARGS(surface.Receive()));
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to get D3D surface from output sample.";
-    return nullptr;
-  }
-
-  // TODO(ggacek): verify surface size matches texture in buffer.
-  if (!current_dxva_picture_buffer_->Fill(*(direct3d_context_.get()),
-                                          surface.get())) {
-    return nullptr;
-  }
-
-  return scoped_refptr<media::DataBuffer>(new media::DataBuffer(0));
-}
-
-scoped_refptr<media::DataBuffer> WMFMediaPipeline::CreateDataBuffer(
-    IMFSample* sample,
-    media::PlatformMediaDataType media_type) {
-  scoped_refptr<media::DataBuffer> data_buffer;
-  if (media_type == media::PLATFORM_MEDIA_VIDEO &&
-      video_config_.decoding_mode ==
-          media::PlatformMediaDecodingMode::HARDWARE) {
-    data_buffer = CreateDataBufferFromTexture(sample);
-  } else {
-    data_buffer = CreateDataBufferFromMemory(sample);
-  }
-  if (!data_buffer)
-    return nullptr;
-
-  int64_t timestamp_hns;  // timestamp in hundreds of nanoseconds
-  HRESULT hr = sample->GetSampleTime(&timestamp_hns);
-  if (FAILED(hr)) {
-    timestamp_hns = 0;
-  }
-
-  int64_t duration_hns;  // duration in hundreds of nanoseconds
-  hr = sample->GetSampleDuration(&duration_hns);
-  if (FAILED(hr)) {
-    duration_hns = 0;
-  }
-
-  UINT32 discontinuity;
-  hr = sample->GetUINT32(MFSampleExtension_Discontinuity, &discontinuity);
-  if (FAILED(hr)) {
-    discontinuity = 0;
-  }
-
-  if (media_type == media::PLATFORM_MEDIA_AUDIO) {
-    // We calculate the timestamp and the duration based on the number of
-    // audio frames we've already played. We don't trust the timestamp
-    // stored on the IMFSample, as sometimes it's wrong, possibly due to
-    // buggy encoders?
-    data_buffer->set_timestamp(audio_timestamp_calculator_->GetTimestamp(
-        timestamp_hns, discontinuity != 0));
-    int64_t frames_count = audio_timestamp_calculator_->GetFramesCount(
-        static_cast<int64_t>(data_buffer->data_size()));
-    data_buffer->set_duration(
-        audio_timestamp_calculator_->GetDuration(frames_count));
-    audio_timestamp_calculator_->UpdateFrameCounter(frames_count);
-  } else if (media_type == media::PLATFORM_MEDIA_VIDEO) {
-    data_buffer->set_timestamp(
-        base::TimeDelta::FromMicroseconds(timestamp_hns / 10));
-    data_buffer->set_duration(
-        base::TimeDelta::FromMicroseconds(duration_hns / 10));
-  }
-
-  return data_buffer;
-}
-
-void WMFMediaPipeline::Seek(base::TimeDelta time, const SeekCB& seek_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  AutoPropVariant position;
-  // IMFSourceReader::SetCurrentPosition expects position in 100-nanosecond
-  // units, so we have to multiply time in microseconds by 10.
-  HRESULT hr =
-      InitPropVariantFromInt64(time.InMicroseconds() * 10, position.get());
-  if (FAILED(hr)) {
-    seek_cb.Run(false);
-    return;
-  }
-
-  audio_timestamp_calculator_->RecapturePosition();
-  hr = source_reader_->SetCurrentPosition(GUID_NULL, position.get_ref());
-  seek_cb.Run(SUCCEEDED(hr));
-}
-
-bool WMFMediaPipeline::HasMediaStream(media::PlatformMediaDataType type) const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return stream_indices_[type] != MF_SOURCE_READER_INVALID_STREAM_INDEX;
-}
-
-void WMFMediaPipeline::SetNoMediaStream(media::PlatformMediaDataType type) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  stream_indices_[type] =
-      static_cast<DWORD>(MF_SOURCE_READER_INVALID_STREAM_INDEX);
-}
-
-bool WMFMediaPipeline::GetAudioDecoderConfig(
-    media::PlatformAudioConfig* audio_config) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(source_reader_.get());
-
-  // In case of some audio streams SourceReader might not get everything
-  // right just from examining the stream (i.e. during initialization), so some
-  // of the values reported here might be wrong. In such case first sample
-  // shall be decoded with |MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED| status,
-  // what will allow us to get proper configuration.
-
-  audio_config->format = media::kSampleFormatF32;
-
-  base::win::ScopedComPtr<IMFMediaType> media_type;
-  HRESULT hr = source_reader_->GetCurrentMediaType(
-      stream_indices_[media::PLATFORM_MEDIA_AUDIO], media_type.Receive());
-  if (FAILED(hr) || !media_type) {
-    DLOG(ERROR) << "Failed to obtain audio media type.";
-    return false;
-  }
-
-  audio_config->channel_count =
-      MFGetAttributeUINT32(media_type.get(), MF_MT_AUDIO_NUM_CHANNELS, 0);
-  if (audio_config->channel_count == 0) {
-    audio_config->channel_count = NumberOfSetBits(
-        MFGetAttributeUINT32(media_type.get(), MF_MT_AUDIO_CHANNEL_MASK, 0));
-  }
-
-  audio_timestamp_calculator_->SetChannelCount(audio_config->channel_count);
-
-  audio_timestamp_calculator_->SetBytesPerSample(
-      MFGetAttributeUINT32(media_type.get(), MF_MT_AUDIO_BITS_PER_SAMPLE, 16) /
-      8);
-
-  audio_config->samples_per_second =
-      MFGetAttributeUINT32(media_type.get(), MF_MT_AUDIO_SAMPLES_PER_SECOND, 0);
-  audio_timestamp_calculator_->SetSamplesPerSecond(
-      audio_config->samples_per_second);
-
-  return true;
-}
-
-bool WMFMediaPipeline::GetVideoDecoderConfig(
-    media::PlatformVideoConfig* video_config) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(source_reader_.get());
-
-  // In case of some video streams SourceReader might not get everything
-  // right just from examining the stream (i.e. during initialization), so some
-  // of the values reported here might be wrong. In such case first sample
-  // shall be decoded with |MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED| status,
-  // what will allow us to get proper configuration.
-
-  base::win::ScopedComPtr<IMFMediaType> media_type;
-  HRESULT hr = source_reader_->GetCurrentMediaType(
-      stream_indices_[media::PLATFORM_MEDIA_VIDEO], media_type.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to obtain video media type.";
-    return false;
-  }
-
-  uint32_t frame_width = 0;
-  uint32_t frame_height = 0;
-  hr = MFGetAttributeSize(media_type.get(), MF_MT_FRAME_SIZE, &frame_width,
-                          &frame_height);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to obtain width and height.";
-    return false;
-  }
-
-  video_config->coded_size = gfx::Size(frame_width, frame_height);
-
-  // The visible rect and the natural size of the video frame have to be
-  // calculated with consideration of the pan scan aperture, the display
-  // aperture and the pixel aspec ratio. For more info see:
-  // http://msdn.microsoft.com/en-us/library/windows/desktop/bb530115(v=vs.85).aspx
-
-  MFVideoArea video_area;
-  uint32_t pan_scan_enabled =
-      MFGetAttributeUINT32(media_type.get(), MF_MT_PAN_SCAN_ENABLED, FALSE);
-  if (pan_scan_enabled) {
-    hr = media_type->GetBlob(MF_MT_PAN_SCAN_APERTURE,
-                             reinterpret_cast<uint8_t*>(&video_area),
-                             sizeof(MFVideoArea),
-                             NULL);
-    if (SUCCEEDED(hr)) {
-      // MFOffset structure consists of the integer part and the fractional
-      // part, but pixels are not divisible, so we ignore the fractional part.
-      video_config->visible_rect = gfx::Rect(video_area.OffsetX.value,
-                                             video_area.OffsetY.value,
-                                             video_area.Area.cx,
-                                             video_area.Area.cy);
-    }
-  }
-
-  if (!pan_scan_enabled || FAILED(hr)) {
-    hr = media_type->GetBlob(MF_MT_MINIMUM_DISPLAY_APERTURE,
-                             reinterpret_cast<uint8_t*>(&video_area),
-                             sizeof(MFVideoArea),
-                             NULL);
-    if (FAILED(hr)) {
-      hr = media_type->GetBlob(MF_MT_GEOMETRIC_APERTURE,
-                               reinterpret_cast<uint8_t*>(&video_area),
-                               sizeof(MFVideoArea),
-                               NULL);
-    }
-
-    if (SUCCEEDED(hr)) {
-      // MFOffset structure consists of the integer part and the fractional
-      // part, but pixels are not divisible, so we ignore the fractional part.
-      video_config->visible_rect = gfx::Rect(video_area.OffsetX.value,
-                                             video_area.OffsetY.value,
-                                             video_area.Area.cx,
-                                             video_area.Area.cy);
-    } else {
-      video_config->visible_rect = gfx::Rect(frame_width, frame_height);
-    }
-  }
-
-  uint32_t aspect_numerator = 0;
-  uint32_t aspect_denominator = 0;
-  hr = MFGetAttributeRatio(media_type.get(), MF_MT_PIXEL_ASPECT_RATIO,
-                           &aspect_numerator, &aspect_denominator);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to obtain pixel aspect ratio.";
-    return false;
-  }
-
-  if (aspect_numerator == aspect_denominator) {
-    video_config->natural_size = gfx::Size(frame_width, frame_height);
-  } else if (aspect_numerator > aspect_denominator) {
-    video_config->natural_size =
-        gfx::Size(MulDiv(frame_width, aspect_numerator, aspect_denominator),
-                  frame_height);
-  } else {
-    video_config->natural_size =
-        gfx::Size(frame_width,
-                  MulDiv(frame_height, aspect_denominator, aspect_numerator));
-  }
-
-  int stride = -1;
-  if (!GetStride(&stride))
-    return false;
-
-  video_config->planes[media::VideoFrame::kYPlane].stride = stride;
-  video_config->planes[media::VideoFrame::kVPlane].stride = stride / 2;
-  video_config->planes[media::VideoFrame::kUPlane].stride = stride / 2;
-
-  int rows = frame_height;
-
-  // Y plane is first and is not downsampled.
-  video_config->planes[media::VideoFrame::kYPlane].offset = 0;
-  video_config->planes[media::VideoFrame::kYPlane].size =
-      rows * video_config->planes[media::VideoFrame::kYPlane].stride;
-
-  // In YV12 V and U planes are downsampled vertically and horizontally by 2.
-  rows /= 2;
-
-  // V plane preceeds U.
-  video_config->planes[media::VideoFrame::kVPlane].offset =
-      video_config->planes[media::VideoFrame::kYPlane].offset +
-      video_config->planes[media::VideoFrame::kYPlane].size;
-  video_config->planes[media::VideoFrame::kVPlane].size =
-      rows * video_config->planes[media::VideoFrame::kVPlane].stride;
-
-  video_config->planes[media::VideoFrame::kUPlane].offset =
-      video_config->planes[media::VideoFrame::kVPlane].offset +
-      video_config->planes[media::VideoFrame::kVPlane].size;
-  video_config->planes[media::VideoFrame::kUPlane].size =
-      rows * video_config->planes[media::VideoFrame::kUPlane].stride;
-
-  switch (MFGetAttributeUINT32(media_type.get(), MF_MT_VIDEO_ROTATION,
-                               MFVideoRotationFormat_0)) {
-    case MFVideoRotationFormat_90:
-      video_config->rotation = media::VIDEO_ROTATION_90;
-      break;
-    case MFVideoRotationFormat_180:
-      video_config->rotation = media::VIDEO_ROTATION_180;
-      break;
-    case MFVideoRotationFormat_270:
-      video_config->rotation = media::VIDEO_ROTATION_270;
-      break;
-    default:
-      video_config->rotation = media::VIDEO_ROTATION_0;
-      break;
-  }
-
-  // Set when SourceReader is created.
-  video_config->decoding_mode = video_config_.decoding_mode;
-  video_config_ = *video_config;
-  return true;
-}
-
-bool WMFMediaPipeline::CreateSourceReaderCallbackAndAttributes(
-    base::win::ScopedComPtr<IMFAttributes>* attributes) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(!source_reader_callback_.get());
-
-  source_reader_callback_ =
-      new SourceReaderCallback(media::BindToCurrentLoop(base::Bind(
-          &WMFMediaPipeline::OnReadSample, weak_ptr_factory_.GetWeakPtr())));
-
-  HRESULT hr = MFCreateAttributes((*attributes).Receive(), 1);
-  if (FAILED(hr)) {
-    source_reader_callback_.Release();
-    return false;
-  }
-
-  hr = (*attributes)
-           ->SetUnknown(MF_SOURCE_READER_ASYNC_CALLBACK,
-                        source_reader_callback_.get());
-  if (FAILED(hr))
-    return false;
-
-  return true;
-}
-
-bool WMFMediaPipeline::RetrieveStreamIndices() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(source_reader_.get());
-
-  DWORD stream_index = 0;
-  HRESULT hr = S_OK;
-
-  while (!(HasMediaStream(media::PLATFORM_MEDIA_AUDIO) &&
-           HasMediaStream(media::PLATFORM_MEDIA_VIDEO))) {
-    base::win::ScopedComPtr<IMFMediaType> media_type;
-    hr = source_reader_->GetNativeMediaType(
-        stream_index, 0, media_type.Receive());
-
-    if (hr == MF_E_INVALIDSTREAMNUMBER)
-      break;  // No more streams.
-
-    if (SUCCEEDED(hr)) {
-      GUID major_type;
-      hr = media_type->GetMajorType(&major_type);
-      if (SUCCEEDED(hr)) {
-        if (major_type == MFMediaType_Audio &&
-            stream_indices_[media::PLATFORM_MEDIA_AUDIO] ==
-                MF_SOURCE_READER_INVALID_STREAM_INDEX) {
-          stream_indices_[media::PLATFORM_MEDIA_AUDIO] = stream_index;
-        } else if (major_type == MFMediaType_Video &&
-                   stream_indices_[media::PLATFORM_MEDIA_VIDEO] ==
-                       MF_SOURCE_READER_INVALID_STREAM_INDEX) {
-          stream_indices_[media::PLATFORM_MEDIA_VIDEO] = stream_index;
-        }
-      }
-    }
-    ++stream_index;
-  }
-
-  return HasMediaStream(media::PLATFORM_MEDIA_AUDIO) ||
-         HasMediaStream(media::PLATFORM_MEDIA_VIDEO);
-}
-
-bool WMFMediaPipeline::ConfigureStream(DWORD stream_index) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(source_reader_.get());
-  DCHECK(stream_index == stream_indices_[media::PLATFORM_MEDIA_AUDIO] ||
-         stream_index == stream_indices_[media::PLATFORM_MEDIA_VIDEO]);
-  bool is_video = stream_index == stream_indices_[media::PLATFORM_MEDIA_VIDEO];
-
-  if (is_video) {
-    base::win::ScopedComPtr<IMFMediaType> input_video_type;
-    HRESULT hr = source_reader_->GetCurrentMediaType(
-        stream_indices_[media::PLATFORM_MEDIA_VIDEO],
-        input_video_type.Receive());
-    if (FAILED(hr)) {
-      DVLOG(1) << "Failed to obtain video media type. No video track?";
-      return false;
-    }
-    input_video_type->GetGUID(MF_MT_SUBTYPE, &input_video_subtype_guid_);
-  }
-
-  base::win::ScopedComPtr<IMFMediaType> new_current_media_type;
-  HRESULT hr = MFCreateMediaType(new_current_media_type.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to create media type.";
-    return false;
-  }
-
-  hr = new_current_media_type->SetGUID(
-      MF_MT_MAJOR_TYPE, is_video ? MFMediaType_Video : MFMediaType_Audio);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to set media major type.";
-    return false;
-  }
-
-  hr = new_current_media_type->SetGUID(
-      MF_MT_SUBTYPE,
-      is_video ? source_reader_output_video_format_ : MFAudioFormat_Float);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to set media subtype.";
-    return false;
-  }
-
-  hr = source_reader_->SetCurrentMediaType(
-      stream_index, NULL, new_current_media_type.get());
-  if (FAILED(hr)) {
-    DVLOG(1) << "Failed to set media type. No "
-             << (is_video ? "video" : "audio") << " track?";
-    return false;
-  }
-
-  // When we set the media type without providing complete media information
-  // WMF tries to figure it out on its own.  But it doesn't do it until it's
-  // needed -- e.g., when decoding is requested.  Since this figuring-out
-  // process can fail, let's force it now by calling GetCurrentMediaType().
-  base::win::ScopedComPtr<IMFMediaType> media_type;
-  hr = source_reader_->GetCurrentMediaType(stream_index, media_type.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to obtain media type.";
-    return false;
-  }
-
-  return true;
-}
-
-bool WMFMediaPipeline::ConfigureSourceReader() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(source_reader_.get());
-
-  static const media::PlatformMediaDataType media_types[] = {
-      media::PLATFORM_MEDIA_AUDIO, media::PLATFORM_MEDIA_VIDEO};
-  static_assert(arraysize(media_types) == media::PLATFORM_MEDIA_DATA_TYPE_COUNT,
-                "Not all media types chosen to be configured.");
-
-  bool status = false;
-  for (const auto& media_type : media_types) {
-    if (!ConfigureStream(stream_indices_[media_type])) {
-      SetNoMediaStream(media_type);
-    } else {
-      DCHECK(HasMediaStream(media_type));
-      status = true;
-    }
-  }
-
-  return status;
-}
-
-base::TimeDelta WMFMediaPipeline::GetDuration() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(source_reader_.get());
-
-  AutoPropVariant var;
-
-  HRESULT hr = source_reader_->GetPresentationAttribute(
-      static_cast<DWORD>(MF_SOURCE_READER_MEDIASOURCE),
-      MF_PD_DURATION,
-      var.get());
-  if (FAILED(hr)) {
-    DLOG_IF(WARNING, !data_source_->IsStreaming())
-        << "Failed to obtain media duration.";
-    return media::kInfiniteDuration();
-  }
-
-  int64_t duration_int64 = 0;
-  hr = var.ToInt64(&duration_int64);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to obtain media duration.";
-    return media::kInfiniteDuration();
-  }
-  // Have to divide duration64 by ten to convert from
-  // hundreds of nanoseconds (WMF style) to microseconds.
-  return base::TimeDelta::FromMicroseconds(duration_int64 / 10);
-}
-
-int WMFMediaPipeline::GetBitrate(base::TimeDelta duration) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(source_reader_.get());
-  DCHECK_GT(duration.InMicroseconds(), 0);
-
-  AutoPropVariant var;
-
-  // Calculating the media bitrate
-  HRESULT hr = source_reader_->GetPresentationAttribute(
-      static_cast<DWORD>(MF_SOURCE_READER_MEDIASOURCE),
-      MF_PD_AUDIO_ENCODING_BITRATE,
-      var.get());
-  int audio_bitrate = 0;
-  hr = var.ToInt32(&audio_bitrate);
-  if (FAILED(hr))
-    audio_bitrate = 0;
-
-  hr = source_reader_->GetPresentationAttribute(
-      static_cast<DWORD>(MF_SOURCE_READER_MEDIASOURCE),
-      MF_PD_VIDEO_ENCODING_BITRATE,
-      var.get());
-  int video_bitrate = 0;
-  hr = var.ToInt32(&video_bitrate);
-  if (FAILED(hr))
-    video_bitrate = 0;
-
-  const int bitrate = std::max(audio_bitrate + video_bitrate, 0);
-  if (bitrate == 0 && !data_source_->IsStreaming()) {
-    // If we have a valid bitrate we can use it, otherwise we have to calculate
-    // it from file size and duration.
-    hr = source_reader_->GetPresentationAttribute(
-        static_cast<DWORD>(MF_SOURCE_READER_MEDIASOURCE), MF_PD_TOTAL_FILE_SIZE,
-        var.get());
-    if (SUCCEEDED(hr) && duration.InMicroseconds() > 0) {
-      int64_t file_size_in_bytes;
-      hr = var.ToInt64(&file_size_in_bytes);
-      if (SUCCEEDED(hr))
-        return (8000000.0 * file_size_in_bytes) / duration.InMicroseconds();
-    }
-    DLOG(ERROR) << "Failed to obtain media bitrate.";
-  }
-
-  return bitrate;
-}
-
-bool WMFMediaPipeline::GetStride(int* stride) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(source_reader_.get());
-
-  base::win::ScopedComPtr<IMFMediaType> media_type;
-  HRESULT hr = source_reader_->GetCurrentMediaType(
-      stream_indices_[media::PLATFORM_MEDIA_VIDEO], media_type.Receive());
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to obtain media type.";
-    return false;
-  }
-
-  UINT32 width = 0;
-  UINT32 height = 0;
-  hr = MFGetAttributeSize(media_type.get(), MF_MT_FRAME_SIZE, &width, &height);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to obtain width and height.";
-    return false;
-  }
-
-  LONG stride_long = 0;
-  hr = get_stride_function_(source_reader_output_video_format_.Data1, width,
-                            &stride_long);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to obtain stride.";
-    return false;
-  }
-
-  *stride = base::saturated_cast<int>(stride_long);
-
-  return true;
-}
-
-WMFMediaPipeline::DXVAPictureBuffer* WMFMediaPipeline::GetDXVAPictureBuffer(
-    uint32_t texture_id) {
-  DCHECK(video_config_.decoding_mode ==
-         media::PlatformMediaDecodingMode::HARDWARE);
-  DCHECK(direct3d_context_);
-  if (!make_gl_context_current_cb_.Run())
-    return nullptr;
-
-  DXVAPictureBuffer* dxva_picture_buffer =
-      known_picture_buffers_.get(texture_id);
-  if (dxva_picture_buffer) {
-    dxva_picture_buffer->Reuse();
-    return dxva_picture_buffer;
-  }
-
-  scoped_ptr<DXVAPictureBuffer> new_dxva_picture_buffer =
-      DXVAPictureBuffer::Create(texture_id, video_config_.coded_size,
-                                egl_config_, direct3d_context_->device.get());
-  if (!new_dxva_picture_buffer.get())
-    return nullptr;
-
-  dxva_picture_buffer = new_dxva_picture_buffer.get();
-  known_picture_buffers_.add(texture_id, std::move(new_dxva_picture_buffer));
-  return dxva_picture_buffer;
-}
-
-}  // namespace content
diff --git a/content/common/gpu/media/wmf_media_pipeline.h b/content/common/gpu/media/wmf_media_pipeline.h
deleted file mode 100644
index ac49c2e..0000000
--- a/content/common/gpu/media/wmf_media_pipeline.h
+++ /dev/null
@@ -1,147 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_COMMON_GPU_MEDIA_WMF_MEDIA_PIPELINE_H_
-#define CONTENT_COMMON_GPU_MEDIA_WMF_MEDIA_PIPELINE_H_
-
-#include <mfidl.h>
-#include <d3d9.h>  // if included before |mfidl.h| breaks <propvarutil.h>
-// Work around bug in this header by disabling the relevant warning for it.
-// https://connect.microsoft.com/VisualStudio/feedback/details/911260/dxva2api-h-in-win8-sdk-triggers-c4201-with-w4
-#pragma warning(push)
-#pragma warning(disable : 4201)
-#include <dxva2api.h>  // if included before |mfidl.h| breaks <propvarutil.h>
-#pragma warning(pop)
-#include <mfreadwrite.h>
-#include <propvarutil.h>
-
-#include <string>
-
-#include "base/containers/scoped_ptr_hash_map.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/memory/weak_ptr.h"
-#include "base/threading/thread.h"
-#include "base/threading/thread_checker.h"
-#include "base/win/scoped_comptr.h"
-#include "content/common/gpu/media/platform_media_pipeline.h"
-#include "content/common/gpu/media/wmf_byte_stream.h"
-#include "media/filters/platform_media_pipeline_types.h"
-
-namespace content {
-
-class WMFByteStream;
-
-class WMFMediaPipeline : public PlatformMediaPipeline {
- public:
-  WMFMediaPipeline(
-      media::DataSource* data_source,
-      const AudioConfigChangedCB& audio_config_changed_cb,
-      const VideoConfigChangedCB& video_config_changed_cb,
-      media::PlatformMediaDecodingMode preferred_video_decoding_mode,
-      const MakeGLContextCurrentCB& make_gl_context_current_cb);
-  ~WMFMediaPipeline() override;
-
-  void Initialize(const std::string& mime_type,
-                  const InitializeCB& initialize_cb) override;
-  void ReadAudioData(const ReadDataCB& read_audio_data_cb) override;
-  void ReadVideoData(const ReadDataCB& read_video_data_cb,
-                     uint32_t texture_id) override;
-  void WillSeek() override {}
-  void Seek(base::TimeDelta time, const SeekCB& seek_cb) override;
-
- private:
-  using EGLConfig = void*;
-
-  class AudioTimestampCalculator;
-  struct Direct3DContext;
-  class DXVAPictureBuffer;
-  struct InitializationResult;
-
-  // Caller doesn't become an owner of object pointed-to by return value.
-  static EGLConfig GetEGLConfig(
-      const MakeGLContextCurrentCB& make_gl_context_current_cb);
-  static InitializationResult CreateSourceReader(
-      const scoped_refptr<WMFByteStream>& byte_stream,
-      const base::win::ScopedComPtr<IMFAttributes>& attributes,
-      media::PlatformMediaDecodingMode preferred_decoding_mode);
-  static bool CreateDXVASourceReader(
-      const scoped_refptr<WMFByteStream>& byte_stream,
-      const base::win::ScopedComPtr<IMFAttributes>& attributes,
-      InitializationResult* result);
-
-  bool CreateSourceReaderCallbackAndAttributes(
-      base::win::ScopedComPtr<IMFAttributes>* attributes);
-
-  bool InitializeImpl(const std::string& mime_type,
-                      const InitializeCB& initialize_cb);
-  void FinalizeInitialization(const InitializeCB& initialize_cb,
-                              const InitializationResult& result);
-  bool RetrieveStreamIndices();
-  bool ConfigureStream(DWORD stream_index);
-  bool ConfigureSourceReader();
-  bool HasMediaStream(media::PlatformMediaDataType type) const;
-  void SetNoMediaStream(media::PlatformMediaDataType type);
-  base::TimeDelta GetDuration();
-  int GetBitrate(base::TimeDelta duration);
-  bool GetStride(int* stride);
-  bool GetAudioDecoderConfig(media::PlatformAudioConfig* audio_config);
-  bool GetVideoDecoderConfig(media::PlatformVideoConfig* video_config);
-  void OnReadSample(media::MediaDataStatus status,
-                    DWORD stream_index,
-                    const base::win::ScopedComPtr<IMFSample>& sample);
-  scoped_refptr<media::DataBuffer> CreateDataBuffer(
-      IMFSample* sample,
-      media::PlatformMediaDataType media_type);
-  scoped_refptr<media::DataBuffer> CreateDataBufferFromMemory(
-      IMFSample* sample);
-  scoped_refptr<media::DataBuffer> CreateDataBufferFromTexture(
-      IMFSample* sample);
-
-  // Caller doesn't become an owner of object pointed-to by return value.
-  DXVAPictureBuffer* GetDXVAPictureBuffer(uint32_t texture_id);
-
-  media::DataSource* data_source_;
-  scoped_refptr<WMFByteStream> byte_stream_;
-  base::win::ScopedComPtr<IMFSourceReaderCallback> source_reader_callback_;
-  base::win::ScopedComPtr<IMFSourceReader> source_reader_;
-
-  AudioConfigChangedCB audio_config_changed_cb_;
-  VideoConfigChangedCB video_config_changed_cb_;
-
-  base::Thread source_reader_creation_thread_;
-
-  DWORD stream_indices_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  GUID input_video_subtype_guid_;
-
-  scoped_ptr<AudioTimestampCalculator> audio_timestamp_calculator_;
-
-  media::PlatformVideoConfig video_config_;
-  GUID source_reader_output_video_format_;
-
-  MakeGLContextCurrentCB make_gl_context_current_cb_;
-  EGLConfig egl_config_;
-  scoped_ptr<Direct3DContext> direct3d_context_;
-  DXVAPictureBuffer* current_dxva_picture_buffer_;
-  base::ScopedPtrHashMap<uint32_t, scoped_ptr<DXVAPictureBuffer>>
-      known_picture_buffers_;
-
-  ReadDataCB read_audio_data_cb_;
-  ReadDataCB read_video_data_cb_;
-
-  scoped_refptr<media::DataBuffer>
-      pending_decoded_data_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  // See |WMFDecoderImpl::get_stride_function_|.
-  decltype(MFGetStrideForBitmapInfoHeader)* get_stride_function_;
-
-  base::ThreadChecker thread_checker_;
-  base::WeakPtrFactory<WMFMediaPipeline> weak_ptr_factory_;
-};
-
-}  // namespace content
-
-#endif  // CONTENT_COMMON_GPU_MEDIA_WMF_MEDIA_PIPELINE_H_
diff --git a/content/common/gpu_process_launch_causes.h b/content/common/gpu_process_launch_causes.h
index 48d7f47..b7acd35 100644
--- a/content/common/gpu_process_launch_causes.h
+++ b/content/common/gpu_process_launch_causes.h
@@ -24,8 +24,6 @@ enum CauseForGpuLaunch {
   CAUSE_FOR_GPU_LAUNCH_JPEGDECODEACCELERATOR_INITIALIZE,
   CAUSE_FOR_GPU_LAUNCH_MOJO_SETUP,
   CAUSE_FOR_GPU_LAUNCH_GET_GPU_SERVICE_REGISTRY,
-  CAUSE_FOR_GPU_LAUNCH_ARCVIDEOACCELERATOR,
-  CAUSE_FOR_GPU_LAUNCH_PLATFORM_MEDIA_PIPELINE,
 
   // All new values should be inserted above this point so that
   // existing values continue to match up with those in histograms.xml.
diff --git a/content/common/media/media_pipeline_messages.h b/content/common/media/media_pipeline_messages.h
deleted file mode 100644
index 8d09a04..0000000
--- a/content/common/media/media_pipeline_messages.h
+++ /dev/null
@@ -1,133 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "base/memory/shared_memory.h"
-#include "base/time/time.h"
-#include "content/common/content_export.h"
-#include "ipc/ipc_message_macros.h"
-#include "media/filters/platform_media_pipeline_types.h"
-
-#undef IPC_MESSAGE_EXPORT
-#define IPC_MESSAGE_EXPORT CONTENT_EXPORT
-
-#define IPC_MESSAGE_START MediaPipelineMsgStart
-
-IPC_ENUM_TRAITS_MAX_VALUE(media::PlatformMediaDataType,
-                          media::PLATFORM_MEDIA_DATA_TYPE_COUNT - 1)
-
-IPC_ENUM_TRAITS_MAX_VALUE(media::MediaDataStatus,
-                          media::kMediaDataStatusCount - 1)
-
-IPC_ENUM_TRAITS_MAX_VALUE(
-    media::PlatformMediaDecodingMode,
-    static_cast<int>(media::PlatformMediaDecodingMode::COUNT) - 1)
-
-IPC_ENUM_TRAITS_MAX_VALUE(media::SampleFormat, media::kSampleFormatMax)
-
-IPC_ENUM_TRAITS_MAX_VALUE(media::VideoRotation, media::VIDEO_ROTATION_MAX)
-
-IPC_STRUCT_TRAITS_BEGIN(media::PlatformMediaTimeInfo)
-  IPC_STRUCT_TRAITS_MEMBER(duration)
-  IPC_STRUCT_TRAITS_MEMBER(start_time)
-IPC_STRUCT_TRAITS_END()
-
-IPC_STRUCT_TRAITS_BEGIN(media::PlatformAudioConfig)
-  IPC_STRUCT_TRAITS_MEMBER(format)
-  IPC_STRUCT_TRAITS_MEMBER(channel_count)
-  IPC_STRUCT_TRAITS_MEMBER(samples_per_second)
-IPC_STRUCT_TRAITS_END()
-
-IPC_STRUCT_TRAITS_BEGIN(media::PlatformVideoConfig::Plane)
-  IPC_STRUCT_TRAITS_MEMBER(stride)
-  IPC_STRUCT_TRAITS_MEMBER(offset)
-  IPC_STRUCT_TRAITS_MEMBER(size)
-IPC_STRUCT_TRAITS_END()
-
-IPC_STRUCT_TRAITS_BEGIN(media::PlatformVideoConfig)
-  IPC_STRUCT_TRAITS_MEMBER(coded_size)
-  IPC_STRUCT_TRAITS_MEMBER(visible_rect)
-  IPC_STRUCT_TRAITS_MEMBER(natural_size)
-  IPC_STRUCT_TRAITS_MEMBER(planes)
-  IPC_STRUCT_TRAITS_MEMBER(rotation)
-  IPC_STRUCT_TRAITS_MEMBER(decoding_mode)
-IPC_STRUCT_TRAITS_END()
-
-IPC_STRUCT_BEGIN(MediaPipelineMsg_DecodedDataReady_Params)
-  IPC_STRUCT_MEMBER(media::PlatformMediaDataType, type)
-  IPC_STRUCT_MEMBER(media::MediaDataStatus, status)
-  IPC_STRUCT_MEMBER(int, size)
-  IPC_STRUCT_MEMBER(base::TimeDelta, timestamp)
-  IPC_STRUCT_MEMBER(base::TimeDelta, duration)
-  // Relevant only when hardware accelerated video decoding is used.
-  IPC_STRUCT_MEMBER(uint32_t, client_texture_id)
-IPC_STRUCT_END()
-
-IPC_SYNC_MESSAGE_CONTROL2_0(
-    MediaPipelineMsg_New,
-    int32_t /* route_id */,
-    int32_t /* gpu_video_accelerator_factories_route_id */)
-
-IPC_MESSAGE_CONTROL1(MediaPipelineMsg_Destroy,
-                     int32_t /* route_id */)
-
-IPC_MESSAGE_ROUTED1(MediaPipelineMsg_RequestBufferForRawData,
-                    size_t /* requested_size */)
-
-IPC_MESSAGE_ROUTED2(MediaPipelineMsg_BufferForRawDataReady,
-                    size_t /* buffer_size */,
-                    base::SharedMemoryHandle /* handle */)
-
-IPC_MESSAGE_ROUTED2(MediaPipelineMsg_RequestBufferForDecodedData,
-                    media::PlatformMediaDataType /* type */,
-                    size_t /* requested_size */)
-
-IPC_MESSAGE_ROUTED3(MediaPipelineMsg_BufferForDecodedDataReady,
-                    media::PlatformMediaDataType /* type */,
-                    size_t /* buffer_size */,
-                    base::SharedMemoryHandle /* handle */)
-
-IPC_MESSAGE_ROUTED2(MediaPipelineMsg_ReadRawData,
-                    int64_t /* position */,
-                    int /* size */)
-
-IPC_MESSAGE_ROUTED1(MediaPipelineMsg_RawDataReady,
-                    int /* size (DataSource::kReadError on error, 0 on EOS) */)
-
-IPC_MESSAGE_ROUTED2(MediaPipelineMsg_ReadDecodedData,
-                    media::PlatformMediaDataType /* type */,
-                    // Relevant only for hardware accelarated video decoding.
-                    uint32_t /* texture_id */)
-
-IPC_MESSAGE_ROUTED1(MediaPipelineMsg_DecodedDataReady,
-                    MediaPipelineMsg_DecodedDataReady_Params /* data */)
-
-IPC_MESSAGE_ROUTED3(MediaPipelineMsg_Initialize,
-                    int64_t /* data_source_size (<0 means "unknown") */,
-                    bool /* is_data_source_streaming */,
-                    std::string /* mime_type */)
-
-IPC_MESSAGE_ROUTED5(MediaPipelineMsg_Initialized,
-                    bool /* status */,
-                    int /* bitrate */,
-                    media::PlatformMediaTimeInfo /* time_info */,
-                    media::PlatformAudioConfig /* audio_config */,
-                    media::PlatformVideoConfig /* video_config */)
-
-IPC_MESSAGE_ROUTED1(MediaPipelineMsg_AudioConfigChanged,
-                    media::PlatformAudioConfig /* audio_config */)
-
-IPC_MESSAGE_ROUTED1(MediaPipelineMsg_VideoConfigChanged,
-                    media::PlatformVideoConfig /* video_config */)
-
-IPC_MESSAGE_ROUTED0(MediaPipelineMsg_WillSeek)
-
-IPC_MESSAGE_ROUTED1(MediaPipelineMsg_Seek,
-                    base::TimeDelta /* time */)
-
-IPC_MESSAGE_ROUTED1(MediaPipelineMsg_Sought,
-                    bool /* success */)
-
-IPC_MESSAGE_ROUTED0(MediaPipelineMsg_Stop)
diff --git a/content/common/sandbox_mac.mm b/content/common/sandbox_mac.mm
index dd01959..6a7f2cf 100644
--- a/content/common/sandbox_mac.mm
+++ b/content/common/sandbox_mac.mm
@@ -35,7 +35,6 @@ extern "C" {
 #include "base/strings/sys_string_conversions.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/sys_info.h"
-#include "content/common/gpu/media/at_init.h"
 #include "content/common/gpu/media/vt_video_decode_accelerator_mac.h"
 #include "content/grit/content_resources.h"
 #include "content/public/common/content_client.h"
@@ -331,12 +330,6 @@ void Sandbox::SandboxWarmup(int sandbox_type) {
   }
 
   // Process-type dependent warm-up.
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (sandbox_type == SANDBOX_TYPE_RENDERER) {
-    InitializeAudioToolbox();
-  }
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
   if (sandbox_type == SANDBOX_TYPE_UTILITY) {
     // CFTimeZoneCopyZone() tries to read /etc and /private/etc/localtime - 10.8
     // Needed by Media Galleries API Picasa - crbug.com/151701
@@ -350,9 +343,6 @@ void Sandbox::SandboxWarmup(int sandbox_type) {
 
     // Preload VideoToolbox.
     InitializeVideoToolbox();
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    InitializeAudioToolbox();
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
   }
 
   if (sandbox_type == SANDBOX_TYPE_PPAPI) {
diff --git a/content/content_common.gypi b/content/content_common.gypi
index 0ed9621..916c724 100644
--- a/content/content_common.gypi
+++ b/content/content_common.gypi
@@ -599,17 +599,6 @@
     }],
   ],
   'conditions': [
-    ['system_proprietary_codecs==1', {
-      'sources': [
-        'common/media/media_pipeline_messages.h',
-      ],
-    }],
-    ['system_proprietary_codecs==1 and OS=="mac"', {
-      'sources': [
-        'common/gpu/media/at_init.cc',
-        'common/gpu/media/at_init.h',
-      ],
-    }],
     ['OS=="mac"', {
       'dependencies': [
         '../media/media.gyp:media',
@@ -957,7 +946,6 @@
            '-lmf.lib',
            '-lmfplat.lib',
            '-lmfuuid.lib',
-           '-lPropsys.lib',
         ],
         'msvs_settings': {
           'VCLinkerTool': {
@@ -967,7 +955,6 @@
               'dxva2.dll',
               'mf.dll',
               'mfplat.dll',
-              'Propsys.dll',
             ],
           },
         },
diff --git a/content/content_gpu.gypi b/content/content_gpu.gypi
index fcbe173..57baf47 100644
--- a/content/content_gpu.gypi
+++ b/content/content_gpu.gypi
@@ -45,52 +45,6 @@
         ],
       },
     }],
-    ['system_proprietary_codecs==1 and OS=="win"', {
-      'dependencies': [
-        '<(DEPTH)/net/net.gyp:net', # For GetMimeTypeFromFile
-      ],
-      'sources': [
-        'common/gpu/media/wmf_byte_stream.cc',
-        'common/gpu/media/wmf_byte_stream.h',
-        'common/gpu/media/wmf_media_pipeline.cc',
-        'common/gpu/media/wmf_media_pipeline.h',
-      ],
-    }],
-    ['system_proprietary_codecs==1', {
-      'sources': [
-        'common/gpu/media/avf_data_buffer_queue.h',
-        'common/gpu/media/avf_data_buffer_queue.mm',
-        'common/gpu/media/avf_audio_tap.h',
-        'common/gpu/media/avf_audio_tap.mm',
-        'common/gpu/media/avf_media_decoder.h',
-        'common/gpu/media/avf_media_decoder.mm',
-        'common/gpu/media/avf_media_pipeline.h',
-        'common/gpu/media/avf_media_pipeline.mm',
-        'common/gpu/media/avf_media_reader.h',
-        'common/gpu/media/avf_media_reader.mm',
-        'common/gpu/media/avf_media_reader_runner.h',
-        'common/gpu/media/avf_media_reader_runner.mm',
-        'common/gpu/media/data_request_handler.h',
-        'common/gpu/media/data_request_handler.mm',
-        'common/gpu/media/data_source_loader.h',
-        'common/gpu/media/data_source_loader.mm',
-        'common/gpu/media/ipc_data_source.h',
-        'common/gpu/media/ipc_data_source_impl.cc',
-        'common/gpu/media/ipc_data_source_impl.h',
-        'common/gpu/media/ipc_media_pipeline.cc',
-        'common/gpu/media/ipc_media_pipeline.h',
-        'common/gpu/media/platform_media_pipeline.h',
-        'common/gpu/media/platform_media_pipeline_mac.cc',
-        'common/gpu/media/platform_media_pipeline_win.cc',
-        'common/gpu/media/propmedia_gpu_channel.cc',
-        'common/gpu/media/propmedia_gpu_channel.h',
-        'common/gpu/media/propmedia_gpu_channel_manager.cc',
-        'common/gpu/media/propmedia_gpu_channel_manager.h',
-      ],
-      'dependencies': [
-        '../media/media.gyp:media',
-      ],
-    }],
     ['target_arch!="arm" and chromeos == 1', {
       'include_dirs': [
         '<(DEPTH)/third_party/libva',
diff --git a/content/content_renderer.gypi b/content/content_renderer.gypi
index 28357f4..d31c8ba 100644
--- a/content/content_renderer.gypi
+++ b/content/content_renderer.gypi
@@ -810,12 +810,6 @@
         'renderer/webscrollbarbehavior_impl_mac.mm',
       ],
     }],
-    ['system_proprietary_codecs==1', {
-      'sources': [
-        'renderer/media/ipc_media_pipeline_host_impl.cc',
-        'renderer/media/ipc_media_pipeline_host_impl.h',
-      ],
-    }],
     ['OS=="android"', {
       'sources': [
         'renderer/external_popup_menu.cc',
diff --git a/content/content_tests.gypi b/content/content_tests.gypi
index eac51fa..dfd6ab7 100644
--- a/content/content_tests.gypi
+++ b/content/content_tests.gypi
@@ -1186,16 +1186,6 @@
             'renderer/media/video_track_recorder_unittest.cc',
           ],
         }],
-        ['system_proprietary_codecs==1', {
-          'sources': [
-            'common/gpu/media/avf_data_buffer_queue_unittest.mm',
-            'common/gpu/media/data_request_handler_unittest.mm',
-            'common/gpu/media/ipc_audio_decoder_unittest.cc',
-            'common/gpu/media/platform_media_pipeline_integration_test.cc',
-            'common/gpu/media/test_pipeline_host.cc',
-            'common/gpu/media/test_pipeline_host.h',
-          ],
-        }],
         # Avoid windows due to non-availability of cursor resources in test.
         ['OS != "linux"', {
           'sources!': [
diff --git a/content/gpu/gpu_child_thread.cc b/content/gpu/gpu_child_thread.cc
index 15e2769..e652ca9 100644
--- a/content/gpu/gpu_child_thread.cc
+++ b/content/gpu/gpu_child_thread.cc
@@ -48,10 +48,6 @@
 #include "gpu/vulkan/vulkan_surface.h"
 #endif
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "content/common/gpu/media/propmedia_gpu_channel_manager.h"
-#endif
-
 namespace content {
 namespace {
 
@@ -412,12 +408,7 @@ void GpuChildThread::OnInitialize(const gpu::GpuPreferences& gpu_preferences) {
   // IPC messages before the sandbox has been enabled and all other necessary
   // initialization has succeeded.
   gpu_channel_manager_.reset(
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-      new gpu::ProprietaryMediaGpuChannelManager
-#else
-      new gpu::GpuChannelManager
-#endif
-                            (gpu_preferences_, this, watchdog_thread_.get(),
+      new gpu::GpuChannelManager(gpu_preferences_, this, watchdog_thread_.get(),
                             base::ThreadTaskRunnerHandle::Get().get(),
                             ChildProcess::current()->io_task_runner(),
                             ChildProcess::current()->GetShutDownEvent(),
diff --git a/content/renderer/media/ipc_media_pipeline_host_impl.cc b/content/renderer/media/ipc_media_pipeline_host_impl.cc
deleted file mode 100644
index b9101c8..0000000
--- a/content/renderer/media/ipc_media_pipeline_host_impl.cc
+++ /dev/null
@@ -1,689 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "content/renderer/media/ipc_media_pipeline_host_impl.h"
-
-#include <algorithm>
-#include <map>
-#include <queue>
-
-#include "base/callback_helpers.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/trace_event/trace_event.h"
-#include "content/common/gpu/media/platform_media_pipeline.h"
-#include "content/common/media/media_pipeline_messages.h"
-#include "content/renderer/render_thread_impl.h"
-#include "gpu/command_buffer/common/mailbox.h"
-#include "media/base/bind_to_current_loop.h"
-#include "media/base/data_source.h"
-#include "media/base/decoder_buffer.h"
-#include "media/filters/pass_through_decoder_texture.h"
-#include "media/filters/platform_media_pipeline_constants.h"
-#include "media/filters/platform_media_pipeline_types.h"
-#include "media/renderers/gpu_video_accelerator_factories.h"
-
-namespace {
-
-struct IPCPictureBuffer {
-  IPCPictureBuffer(uint32_t texture_id, gpu::Mailbox texture_mailbox)
-      : texture_id(texture_id), texture_mailbox(texture_mailbox) {}
-
-  uint32_t texture_id;
-  gpu::Mailbox texture_mailbox;
-};
-
-const char* const kDecodedDataReadTraceEventNames[] = {"ReadAudioData",
-                                                       "ReadVideoData"};
-static_assert(arraysize(kDecodedDataReadTraceEventNames) ==
-                  media::PLATFORM_MEDIA_DATA_TYPE_COUNT,
-              "Incorrect number of defined tracing event names.");
-
-template <media::PlatformMediaDataType type, typename ConfigType>
-void HandleConfigChange(const ConfigType& new_config,
-                        ConfigType* current_config,
-                        MediaPipelineMsg_DecodedDataReady_Params* params) {
-  params->type = type;
-
-  if (!new_config.is_valid()) {
-    DLOG(ERROR) << "Invalid configuration received";
-    params->status = media::kError;
-    return;
-  }
-
-  *current_config = new_config;
-  params->status = media::kConfigChanged;
-}
-
-}  // namespace
-
-namespace content {
-
-using media::DemuxerStream;
-
-// Manages IPCPictureBuffers used for transferring video frames which were
-// decoded using hardware acceleration.
-class IPCMediaPipelineHostImpl::PictureBufferManager {
- public:
-  explicit PictureBufferManager(media::GpuVideoAcceleratorFactories* factories);
-  ~PictureBufferManager();
-
-  const IPCPictureBuffer* ProvidePictureBuffer(const gfx::Size& size);
-  scoped_ptr<media::AutoReleasedPassThroughDecoderTexture> CreateWrappedTexture(
-      uint32_t texture_id);
-  void DismissPictureBufferInUse();
-
- private:
-  static void ReleaseMailbox(
-      base::WeakPtr<PictureBufferManager> buffer_manager,
-      media::GpuVideoAcceleratorFactories* factories,
-      uint32_t texture_id,
-      const gpu::SyncToken& release_sync_point);
-
-  void ReusePictureBuffer(uint32_t texture_id);
-
-  media::GpuVideoAcceleratorFactories* factories_;
-
-  scoped_ptr<IPCPictureBuffer> picture_buffer_in_use_;
-  std::queue<IPCPictureBuffer> available_picture_buffers_;
-  std::map<int32_t, IPCPictureBuffer> picture_buffers_at_display_;
-
-  base::WeakPtrFactory<PictureBufferManager> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(PictureBufferManager);
-};
-
-IPCMediaPipelineHostImpl::PictureBufferManager::PictureBufferManager(
-    media::GpuVideoAcceleratorFactories* factories)
-    : factories_(factories), weak_ptr_factory_(this) {
-  DCHECK(factories_);
-}
-
-IPCMediaPipelineHostImpl::PictureBufferManager::~PictureBufferManager() {
-  if (picture_buffer_in_use_) {
-    factories_->DeleteTexture(picture_buffer_in_use_->texture_id);
-  }
-
-  while (!available_picture_buffers_.empty()) {
-    factories_->DeleteTexture(available_picture_buffers_.front().texture_id);
-    available_picture_buffers_.pop();
-  }
-
-  // Textures described by PictureBuffer objects stored in
-  // |picture_buffers_at_display_| are in use by an external object which is
-  // responsible to properly dispose of them, once they are no longer needed.
-}
-
-const IPCPictureBuffer*
-IPCMediaPipelineHostImpl::PictureBufferManager::ProvidePictureBuffer(
-    const gfx::Size& size) {
-  DCHECK(factories_->GetTaskRunner()->RunsTasksOnCurrentThread());
-  DCHECK(!picture_buffer_in_use_);
-
-  if (!available_picture_buffers_.empty()) {
-    picture_buffer_in_use_.reset(
-        new IPCPictureBuffer(available_picture_buffers_.front()));
-    available_picture_buffers_.pop();
-    return picture_buffer_in_use_.get();
-  }
-
-  std::vector<uint32_t> texture_ids;
-  std::vector<gpu::Mailbox> texture_mailboxes;
-  if (!factories_->CreateTextures(1, size, &texture_ids, &texture_mailboxes,
-                                  media::kPlatformMediaPipelineTextureTarget)) {
-    DLOG(ERROR) << "Failed to create texture.";
-    return NULL;
-  }
-  DCHECK_EQ(texture_ids.size(), 1U);
-  DCHECK_EQ(texture_mailboxes.size(), 1U);
-
-  picture_buffer_in_use_.reset(
-      new IPCPictureBuffer(texture_ids[0], texture_mailboxes[0]));
-  return picture_buffer_in_use_.get();
-}
-
-scoped_ptr<media::AutoReleasedPassThroughDecoderTexture>
-IPCMediaPipelineHostImpl::PictureBufferManager::CreateWrappedTexture(
-    uint32_t texture_id) {
-  DCHECK(picture_buffer_in_use_);
-
-  if (picture_buffer_in_use_->texture_id != texture_id) {
-    DLOG(ERROR) << "Unexpected texture id " << texture_id;
-    return NULL;
-  }
-
-  scoped_ptr<media::PassThroughDecoderTexture> texture_info(
-      new media::PassThroughDecoderTexture);
-  texture_info->texture_id = texture_id;
-  texture_info->mailbox_holder = make_scoped_ptr(new gpu::MailboxHolder(
-      picture_buffer_in_use_->texture_mailbox, gpu::SyncToken(),
-      media::kPlatformMediaPipelineTextureTarget));
-  // This callback has to be run when texture is no longer needed.
-  // PassThroughDecoderTextureWrapper will take care of it if no one will try to
-  // use its load.
-  texture_info->mailbox_holder_release_cb = media::BindToCurrentLoop(
-      base::Bind(&ReleaseMailbox, weak_ptr_factory_.GetWeakPtr(), factories_,
-                 picture_buffer_in_use_->texture_id));
-
-  picture_buffers_at_display_.insert(
-      std::make_pair(texture_id, *picture_buffer_in_use_));
-  picture_buffer_in_use_.reset();
-
-  return make_scoped_ptr(
-     new media::AutoReleasedPassThroughDecoderTexture(std::move(texture_info)));
-}
-
-void IPCMediaPipelineHostImpl::PictureBufferManager::ReleaseMailbox(
-    base::WeakPtr<PictureBufferManager> buffer_manager,
-    media::GpuVideoAcceleratorFactories* factories,
-    uint32_t texture_id,
-    const gpu::SyncToken& release_sync_point) {
-  DCHECK(factories->GetTaskRunner()->BelongsToCurrentThread());
-  factories->WaitSyncToken(release_sync_point);
-
-  if (buffer_manager) {
-    buffer_manager->ReusePictureBuffer(texture_id);
-    return;
-  }
-
-  // This is the last chance to delete this texture if |buffer_manager| exists
-  // no more.
-  factories->DeleteTexture(texture_id);
-}
-
-void IPCMediaPipelineHostImpl::PictureBufferManager::ReusePictureBuffer(
-    uint32_t texture_id) {
-  auto it = picture_buffers_at_display_.find(texture_id);
-  DCHECK(it != picture_buffers_at_display_.end());
-
-  available_picture_buffers_.push(it->second);
-  picture_buffers_at_display_.erase(it);
-}
-
-void IPCMediaPipelineHostImpl::PictureBufferManager::
-    DismissPictureBufferInUse() {
-  if (picture_buffer_in_use_) {
-    available_picture_buffers_.push(*picture_buffer_in_use_);
-    picture_buffer_in_use_.reset();
-  }
-}
-
-class IPCMediaPipelineHostImpl::SharedData {
- public:
-  explicit SharedData(gpu::GpuChannelHost* channel);
-  ~SharedData();
-
-  bool Prepare(size_t size);
-  // Checks if internal buffer is present and big enough.
-  bool IsSufficient(int needed_size) const;
-
-  base::SharedMemoryHandle handle() const;
-  uint8_t* memory() const;
-  int mapped_size() const;
-
- private:
-  gpu::GpuChannelHost* channel_;
-  scoped_ptr<base::SharedMemory> memory_;
-};
-
-IPCMediaPipelineHostImpl::SharedData::SharedData(gpu::GpuChannelHost* channel)
-    : channel_(channel) {
-  DCHECK(channel_);
-}
-
-IPCMediaPipelineHostImpl::SharedData::~SharedData() {
-}
-
-bool IPCMediaPipelineHostImpl::SharedData::Prepare(size_t size) {
-  if (size == 0 || !base::IsValueInRangeForNumericType<int>(size)) {
-    return false;
-  }
-
-  if (!IsSufficient(static_cast<int>(size))) {
-    memory_ = channel_->factory()->AllocateSharedMemory(size);
-    if (!memory_)
-      return false;
-
-    if (!memory_->Map(size)) {
-      memory_.reset(NULL);
-      return false;
-    }
-  }
-  return true;
-}
-
-bool IPCMediaPipelineHostImpl::SharedData::IsSufficient(int needed_size) const {
-  return base::IsValueInRangeForNumericType<size_t>(needed_size) && memory_ &&
-         memory_->mapped_size() >= static_cast<size_t>(needed_size);
-}
-
-base::SharedMemoryHandle IPCMediaPipelineHostImpl::SharedData::handle() const {
-  DCHECK(memory_);
-  return memory_->handle();
-}
-
-uint8_t* IPCMediaPipelineHostImpl::SharedData::memory() const {
-  DCHECK(memory_);
-  return static_cast<uint8_t*>(memory_->memory());
-}
-
-int IPCMediaPipelineHostImpl::SharedData::mapped_size() const {
-  DCHECK(memory_);
-  return base::saturated_cast<int>(memory_->mapped_size());
-}
-
-IPCMediaPipelineHostImpl::IPCMediaPipelineHostImpl(
-    gpu::GpuChannelHost* channel,
-    const scoped_refptr<base::SequencedTaskRunner>& task_runner,
-    media::GpuVideoAcceleratorFactories* factories,
-    media::DataSource* data_source)
-    : task_runner_(task_runner),
-      data_source_(data_source),
-      channel_(channel),
-      routing_id_(MSG_ROUTING_NONE),
-      shared_raw_data_(new SharedData(channel)),
-      factories_(factories),
-      weak_ptr_factory_(this) {
-  DCHECK(channel_.get());
-  DCHECK(data_source_);
-
-  for (int i = 0; i < media::PLATFORM_MEDIA_DATA_TYPE_COUNT; ++i) {
-    shared_decoded_data_[i].reset(new SharedData(channel));
-  }
-}
-
-IPCMediaPipelineHostImpl::~IPCMediaPipelineHostImpl() {
-  // We use WeakPtrs which require that we (i.e. our |weak_ptr_factory_|) are
-  // destroyed on the same thread they are used.
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-
-  if (is_connected()) {
-    DLOG(ERROR) << "Object was not brought down properly. Missing "
-                   "MediaPipelineMsg_Stopped?";
-  }
-}
-
-void IPCMediaPipelineHostImpl::Initialize(const std::string& mimetype,
-                                          const InitializeCB& callback) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-  DCHECK(!is_connected());
-  DCHECK(init_callback_.is_null());
-
-  routing_id_ = channel_->GenerateRouteID();
-  int32_t gpu_video_accelerator_factories_route_id =
-      factories_ ? factories_->GetRouteID() : MSG_ROUTING_NONE;
-  if (!channel_->Send(new MediaPipelineMsg_New(
-          routing_id_, gpu_video_accelerator_factories_route_id))) {
-    callback.Run(false, -1, media::PlatformMediaTimeInfo(),
-                 media::PlatformAudioConfig(), media::PlatformVideoConfig());
-    return;
-  }
-
-  channel_->AddRoute(routing_id_, weak_ptr_factory_.GetWeakPtr());
-
-  init_callback_ = callback;
-  int64_t size = -1;
-  if (!data_source_->GetSize(&size))
-    size = -1;
-  channel_->Send(new MediaPipelineMsg_Initialize(
-      routing_id_, size, data_source_->IsStreaming(), mimetype));
-}
-
-void IPCMediaPipelineHostImpl::OnInitialized(
-    bool success,
-    int bitrate,
-    const media::PlatformMediaTimeInfo& time_info,
-    const media::PlatformAudioConfig& audio_config,
-    const media::PlatformVideoConfig& video_config) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-
-  if (init_callback_.is_null()) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    return;
-  }
-
-  if (audio_config.is_valid()) {
-    audio_config_ = audio_config;
-  }
-
-  if (video_config.is_valid()) {
-    video_config_ = video_config;
-    if (video_config_.decoding_mode ==
-        media::PlatformMediaDecodingMode::HARDWARE) {
-      picture_buffer_manager_.reset(new PictureBufferManager(factories_));
-    }
-  }
-
-  success = success && bitrate >= 0;
-
-  base::ResetAndReturn(&init_callback_)
-      .Run(success, bitrate, time_info, audio_config, video_config);
-}
-
-void IPCMediaPipelineHostImpl::OnRequestBufferForRawData(
-    size_t requested_size) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-
-  if (shared_raw_data_->Prepare(requested_size)) {
-    channel_->Send(new MediaPipelineMsg_BufferForRawDataReady(
-        routing_id_,
-        shared_raw_data_->mapped_size(),
-        channel_->ShareToGpuProcess(shared_raw_data_->handle())));
-  } else {
-    channel_->Send(new MediaPipelineMsg_BufferForRawDataReady(
-        routing_id_, 0, base::SharedMemory::NULLHandle()));
-  }
-}
-
-void IPCMediaPipelineHostImpl::OnRequestBufferForDecodedData(
-    media::PlatformMediaDataType type,
-    size_t requested_size) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-
-  if (!is_read_in_progress(type)) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    return;
-  }
-
-  if (shared_decoded_data_[type]->Prepare(requested_size)) {
-    channel_->Send(new MediaPipelineMsg_BufferForDecodedDataReady(
-        routing_id_,
-        type,
-        shared_decoded_data_[type]->mapped_size(),
-        channel_->ShareToGpuProcess(shared_decoded_data_[type]->handle())));
-  } else {
-    channel_->Send(new MediaPipelineMsg_BufferForDecodedDataReady(
-        routing_id_, type, 0, base::SharedMemory::NULLHandle()));
-  }
-}
-
-void IPCMediaPipelineHostImpl::StartWaitingForSeek() {
-  channel_->Send(new MediaPipelineMsg_WillSeek(routing_id_));
-}
-
-void IPCMediaPipelineHostImpl::Seek(base::TimeDelta time,
-                                    const media::PipelineStatusCB& status_cb) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-  DCHECK(is_connected());
-  DCHECK(seek_callback_.is_null());
-
-  TRACE_EVENT_ASYNC_BEGIN0("IPC_MEDIA", "Seek", this);
-
-  seek_callback_ = status_cb;
-  channel_->Send(new MediaPipelineMsg_Seek(routing_id_, time));
-}
-
-void IPCMediaPipelineHostImpl::OnSought(bool success) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-
-  if (seek_callback_.is_null()) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    return;
-  }
-
-  base::ResetAndReturn(&seek_callback_)
-      .Run(success ? media::PIPELINE_OK : media::PIPELINE_ERROR_ABORT);
-
-  TRACE_EVENT_ASYNC_END0("IPC_MEDIA", "Seek", this);
-}
-
-void IPCMediaPipelineHostImpl::Stop() {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-  DCHECK(is_connected());
-
-  TRACE_EVENT0("IPC_MEDIA", "Stop");
-
-  channel_->Send(new MediaPipelineMsg_Stop(routing_id_));
-
-  channel_->Send(new MediaPipelineMsg_Destroy(routing_id_));
-  channel_->RemoveRoute(routing_id_);
-  routing_id_ = MSG_ROUTING_NONE;
-
-  data_source_->Stop();
-}
-
-void IPCMediaPipelineHostImpl::ReadDecodedData(
-    media::PlatformMediaDataType type,
-    const DemuxerStream::ReadCB& read_cb) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-  DCHECK(!is_read_in_progress(type)) << "Overlapping reads are not supported";
-  DCHECK(is_connected());
-
-  TRACE_EVENT_ASYNC_BEGIN0(
-      "IPC_MEDIA", kDecodedDataReadTraceEventNames[type], this);
-
-  uint32_t texture_id = 0;
-
-  if (is_handling_accelerated_video_decode(type)) {
-    DCHECK(picture_buffer_manager_);
-
-    const IPCPictureBuffer* picture_buffer =
-        picture_buffer_manager_->ProvidePictureBuffer(video_config_.coded_size);
-    if (!picture_buffer) {
-      read_cb.Run(DemuxerStream::kAborted, NULL);
-      return;
-    }
-    texture_id = picture_buffer->texture_id;
-  }
-
-  if (!channel_->Send(new MediaPipelineMsg_ReadDecodedData(routing_id_, type,
-                                                           texture_id))) {
-    read_cb.Run(DemuxerStream::kAborted, NULL);
-    return;
-  }
-
-  decoded_data_read_callbacks_[type] = read_cb;
-}
-
-bool IPCMediaPipelineHostImpl::PlatformEnlargesBuffersOnUnderflow() const {
-  return PlatformMediaPipeline::EnlargesBuffersOnUnderflow();
-}
-
-base::TimeDelta IPCMediaPipelineHostImpl::GetTargetBufferDurationBehind()
-    const {
-  return PlatformMediaPipeline::GetTargetBufferDurationBehind();
-}
-
-base::TimeDelta IPCMediaPipelineHostImpl::GetTargetBufferDurationAhead() const {
-  return PlatformMediaPipeline::GetTargetBufferDurationAhead();
-}
-
-void IPCMediaPipelineHostImpl::OnReadRawData(int64_t position, int size) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-
-  TRACE_EVENT_ASYNC_BEGIN0("IPC_MEDIA", "ReadRawData", this);
-
-  if (!shared_raw_data_->IsSufficient(size)) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    channel_->Send(new MediaPipelineMsg_RawDataReady(
-        routing_id_, media::DataSource::kReadError));
-    TRACE_EVENT_ASYNC_END0("IPC_MEDIA", "ReadRawData", this);
-  }
-
-  data_source_->Read(position,
-                     size,
-                     shared_raw_data_->memory(),
-                     media::BindToCurrentLoop(base::Bind(
-                         &IPCMediaPipelineHostImpl::OnReadRawDataFinished,
-                         weak_ptr_factory_.GetWeakPtr())));
-}
-
-void IPCMediaPipelineHostImpl::OnReadRawDataFinished(int size) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-  DCHECK(shared_raw_data_->IsSufficient(size) ||
-         size == media::DataSource::kReadError);
-
-  if (!is_connected())
-    // Someone called Stop() after we got the ReadRawData message and beat us
-    // to it.
-    return;
-
-  channel_->Send(new MediaPipelineMsg_RawDataReady(routing_id_, size));
-  TRACE_EVENT_ASYNC_END0("IPC_MEDIA", "ReadRawData", this);
-}
-
-bool IPCMediaPipelineHostImpl::OnMessageReceived(const IPC::Message& msg) {
-  // GpuChannelHost gives us messages for handling on the thread that called
-  // AddRoute().
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-
-  bool handled = true;
-  IPC_BEGIN_MESSAGE_MAP(IPCMediaPipelineHostImpl, msg)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_RequestBufferForDecodedData,
-                        OnRequestBufferForDecodedData)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_RequestBufferForRawData,
-                        OnRequestBufferForRawData)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_ReadRawData, OnReadRawData)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_DecodedDataReady, OnDecodedDataReady)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_Initialized, OnInitialized)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_Sought, OnSought)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_AudioConfigChanged,
-                        OnAudioConfigChanged)
-    IPC_MESSAGE_HANDLER(MediaPipelineMsg_VideoConfigChanged,
-                        OnVideoConfigChanged)
-    IPC_MESSAGE_UNHANDLED(handled = false)
-  IPC_END_MESSAGE_MAP()
-  DCHECK(handled) << msg.type();
-  return handled;
-}
-
-bool IPCMediaPipelineHostImpl::is_connected() const {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-  return routing_id_ != MSG_ROUTING_NONE;
-}
-
-void IPCMediaPipelineHostImpl::OnDecodedDataReady(
-    const MediaPipelineMsg_DecodedDataReady_Params& params) {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-  DCHECK(!is_handling_accelerated_video_decode(params.type) ||
-         picture_buffer_manager_);
-
-  if (!is_read_in_progress(params.type)) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    return;
-  }
-
-  switch (params.status) {
-    case media::MediaDataStatus::kOk: {
-      scoped_refptr<media::DecoderBuffer> buffer;
-      if (is_handling_accelerated_video_decode(params.type)) {
-        scoped_ptr<media::AutoReleasedPassThroughDecoderTexture>
-            wrapped_texture = picture_buffer_manager_->CreateWrappedTexture(
-                params.client_texture_id);
-        if (!wrapped_texture) {
-          DLOG(ERROR) << "Received invalid picture buffer id "
-                      << params.client_texture_id;
-          base::ResetAndReturn(&decoded_data_read_callbacks_[params.type])
-              .Run(DemuxerStream::kOk, new media::DecoderBuffer(0));
-          return;
-        }
-
-        // PassThroughDecoderImpl treats 0-sized buffers as a sign of an error.
-        buffer = new media::DecoderBuffer(1);
-        buffer->set_wrapped_texture(std::move(wrapped_texture));
-      } else {
-        if (!shared_decoded_data_[params.type]->IsSufficient(params.size)) {
-          DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-          return;
-        }
-
-        buffer = media::DecoderBuffer::CopyFrom(
-            shared_decoded_data_[params.type]->memory(), params.size);
-      }
-
-      buffer->set_timestamp(params.timestamp);
-      buffer->set_duration(params.duration);
-
-      base::ResetAndReturn(&decoded_data_read_callbacks_[params.type])
-          .Run(DemuxerStream::kOk, buffer);
-      break;
-    }
-
-    case media::MediaDataStatus::kEOS:
-      if (is_handling_accelerated_video_decode(params.type)) {
-        // Necessary if the video is looped.
-        picture_buffer_manager_->DismissPictureBufferInUse();
-      }
-      base::ResetAndReturn(&decoded_data_read_callbacks_[params.type])
-          .Run(DemuxerStream::kOk, media::DecoderBuffer::CreateEOSBuffer());
-      break;
-
-    case media::MediaDataStatus::kConfigChanged:
-      if (is_handling_accelerated_video_decode(params.type)) {
-        // Decoded data is not returned on config change.
-        picture_buffer_manager_->DismissPictureBufferInUse();
-      }
-      base::ResetAndReturn(&decoded_data_read_callbacks_[params.type])
-          .Run(DemuxerStream::kConfigChanged, nullptr);
-      break;
-
-    case media::MediaDataStatus::kError:
-      // Note that this is a decoder error rather than demuxer error.  Don't
-      // return DemuxerStream::kAborted.  Instead, return an empty buffer so
-      // that the decoder can signal a decoder error.
-      base::ResetAndReturn(&decoded_data_read_callbacks_[params.type])
-          .Run(DemuxerStream::kOk, new media::DecoderBuffer(0));
-      break;
-
-    default:
-      NOTREACHED();
-      break;
-  }
-
-  TRACE_EVENT_ASYNC_END0(
-      "IPC_MEDIA", kDecodedDataReadTraceEventNames[params.type], this);
-}
-
-void IPCMediaPipelineHostImpl::OnAudioConfigChanged(
-    const media::PlatformAudioConfig& new_audio_config) {
-  DVLOG(1) << __FUNCTION__;
-
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-
-  if (!is_read_in_progress(media::PLATFORM_MEDIA_AUDIO)) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    return;
-  }
-
-  MediaPipelineMsg_DecodedDataReady_Params params;
-  HandleConfigChange<media::PLATFORM_MEDIA_AUDIO>(new_audio_config,
-                                                  &audio_config_, &params);
-  OnDecodedDataReady(params);
-}
-
-void IPCMediaPipelineHostImpl::OnVideoConfigChanged(
-    const media::PlatformVideoConfig& new_video_config) {
-  DVLOG(1) << __FUNCTION__;
-
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-
-  if (!is_read_in_progress(media::PLATFORM_MEDIA_VIDEO)) {
-    DLOG(ERROR) << "Unexpected call to " << __FUNCTION__;
-    return;
-  }
-
-  MediaPipelineMsg_DecodedDataReady_Params params;
-  if (new_video_config.decoding_mode != video_config_.decoding_mode) {
-    DLOG(ERROR) << "New video config tries to change decoding mode.";
-    params.status = media::kError;
-  } else {
-    HandleConfigChange<media::PLATFORM_MEDIA_VIDEO>(new_video_config,
-                                                    &video_config_, &params);
-  }
-
-  OnDecodedDataReady(params);
-}
-
-media::PlatformAudioConfig IPCMediaPipelineHostImpl::audio_config() const {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-  return audio_config_;
-}
-
-media::PlatformVideoConfig IPCMediaPipelineHostImpl::video_config() const {
-  DCHECK(task_runner_->RunsTasksOnCurrentThread());
-  return video_config_;
-}
-
-}  // namespace content
diff --git a/content/renderer/media/ipc_media_pipeline_host_impl.h b/content/renderer/media/ipc_media_pipeline_host_impl.h
deleted file mode 100644
index 115d4bb..0000000
--- a/content/renderer/media/ipc_media_pipeline_host_impl.h
+++ /dev/null
@@ -1,145 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef CONTENT_RENDERER_MEDIA_IPC_MEDIA_PIPELINE_HOST_IMPL_H_
-#define CONTENT_RENDERER_MEDIA_IPC_MEDIA_PIPELINE_HOST_IMPL_H_
-
-#include <string>
-#include <vector>
-
-#include "base/memory/ref_counted.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/memory/shared_memory.h"
-#include "base/memory/weak_ptr.h"
-#include "ipc/ipc_listener.h"
-#include "media/filters/ipc_media_pipeline_host.h"
-#include "media/filters/platform_media_pipeline_types.h"
-
-struct MediaPipelineMsg_DecodedDataReady_Params;
-
-namespace base {
-class SequencedTaskRunner;
-}
-
-namespace media {
-class DataSource;
-class GpuVideoAcceleratorFactories;
-}  // namespace media
-
-namespace content {
-class GpuChannelHost;
-
-class IPCMediaPipelineHostImpl : public media::IPCMediaPipelineHost,
-                                 public IPC::Listener {
- public:
-  IPCMediaPipelineHostImpl(
-      gpu::GpuChannelHost* channel,
-      const scoped_refptr<base::SequencedTaskRunner>& task_runner,
-      media::GpuVideoAcceleratorFactories* factories,
-      media::DataSource* data_source);
-  ~IPCMediaPipelineHostImpl() override;
-
-  // media::IPCMediaPipelineHost implementation.
-  void Initialize(const std::string& mimetype,
-                  const InitializeCB& callback) override;
-  void StartWaitingForSeek() override;
-  void Seek(base::TimeDelta time,
-            const media::PipelineStatusCB& status_cb) override;
-  void Stop() override;
-  void ReadDecodedData(
-      media::PlatformMediaDataType type,
-      const media::DemuxerStream::ReadCB& read_cb) override;
-  bool PlatformEnlargesBuffersOnUnderflow() const override;
-  base::TimeDelta GetTargetBufferDurationBehind() const override;
-  base::TimeDelta GetTargetBufferDurationAhead() const override;
-  media::PlatformAudioConfig audio_config() const override;
-  media::PlatformVideoConfig video_config() const override;
-
-  // IPC::Listener implementation.
-  bool OnMessageReceived(const IPC::Message& msg) override;
-
- private:
-  class PictureBufferManager;
-  class SharedData;
-
-  typedef base::Callback<void(media::MediaDataStatus status,
-                              const uint8_t* data,
-                              int data_size,
-                              base::TimeDelta timestamp,
-                              base::TimeDelta duration)> DecodedDataErrorCB;
-
-  bool is_connected() const;
-
-  // Calls the Closure callback when the media pipeline initializes.
-  void OnInitialized(bool success,
-                     int bitrate,
-                     const media::PlatformMediaTimeInfo& time_info,
-                     const media::PlatformAudioConfig& audio_config,
-                     const media::PlatformVideoConfig& video_config);
-
-  // Calls the PipelineStatusCB callback after the seek is finished.
-  void OnSought(bool success);
-
-  // Creates and passes to GPU process buffer for transferring raw data.
-  void OnRequestBufferForRawData(size_t requested_size);
-  // Creates and passes to GPU process buffer for transferring decoded data.
-  void OnRequestBufferForDecodedData(media::PlatformMediaDataType type,
-                                     size_t requested_size);
-
-  // Performs an actual read operation on the data source and
-  // returns the red data to the media pipeline over the IPC.
-  void OnReadRawData(int64_t position, int size);
-  void OnReadRawDataFinished(int size);
-
-  void OnDecodedDataReady(
-      const MediaPipelineMsg_DecodedDataReady_Params& params);
-  void OnAudioConfigChanged(const media::PlatformAudioConfig& new_audio_config);
-  void OnVideoConfigChanged(const media::PlatformVideoConfig& new_video_config);
-
-  bool is_handling_accelerated_video_decode(
-      media::PlatformMediaDataType type) const {
-    return type == media::PLATFORM_MEDIA_VIDEO &&
-           video_config_.decoding_mode ==
-               media::PlatformMediaDecodingMode::HARDWARE;
-  }
-
-  bool is_read_in_progress(media::PlatformMediaDataType type) const {
-    return !decoded_data_read_callbacks_[type].is_null();
-  }
-
-  scoped_refptr<base::SequencedTaskRunner> task_runner_;
-
-  media::DataSource* data_source_;
-  scoped_refptr<gpu::GpuChannelHost> channel_;
-  int32_t routing_id_;
-
-  InitializeCB init_callback_;
-  media::PipelineStatusCB seek_callback_;
-  media::DemuxerStream::ReadCB
-      decoded_data_read_callbacks_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  // A buffer for raw media data, shared with the GPU process. Filled in the
-  // renderer process, consumed in the GPU process.
-  scoped_ptr<SharedData> shared_raw_data_;
-
-  // Buffers for decoded media data, shared with the GPU process. Filled in
-  // the GPU process, consumed in the renderer process.
-  scoped_ptr<SharedData>
-      shared_decoded_data_[media::PLATFORM_MEDIA_DATA_TYPE_COUNT];
-
-  media::PlatformAudioConfig audio_config_;
-  media::PlatformVideoConfig video_config_;
-
-  media::GpuVideoAcceleratorFactories* factories_;
-
-  scoped_ptr<PictureBufferManager> picture_buffer_manager_;
-
-  base::WeakPtrFactory<IPCMediaPipelineHostImpl> weak_ptr_factory_;
-};
-
-}  // namespace content
-
-#endif  // CONTENT_RENDERER_MEDIA_IPC_MEDIA_PIPELINE_HOST_IMPL_H_
diff --git a/content/renderer/media/render_media_log.cc b/content/renderer/media/render_media_log.cc
index a863387..0d1e88f 100644
--- a/content/renderer/media/render_media_log.cc
+++ b/content/renderer/media/render_media_log.cc
@@ -15,10 +15,6 @@
 #include "content/common/view_messages.h"
 #include "content/public/renderer/render_thread.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/base/pipeline_stats.h"
-#endif
-
 namespace {
 
 // Print an event to the chromium log.
@@ -48,9 +44,6 @@ RenderMediaLog::RenderMediaLog()
 }
 
 void RenderMediaLog::AddEvent(std::unique_ptr<media::MediaLogEvent> event) {
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  media::pipeline_stats::SerializeInto(&event->params);
-#endif
   Log(event.get());
 
   // For enforcing delay until it's been a second since the last ipc message was
diff --git a/content/renderer/media/renderer_gpu_video_accelerator_factories.cc b/content/renderer/media/renderer_gpu_video_accelerator_factories.cc
index 1c537032..9136081 100644
--- a/content/renderer/media/renderer_gpu_video_accelerator_factories.cc
+++ b/content/renderer/media/renderer_gpu_video_accelerator_factories.cc
@@ -140,16 +140,6 @@ RendererGpuVideoAcceleratorFactories::CreateVideoEncodeAccelerator() {
           channel, context_provider_->GetCommandBufferProxy()));
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-int RendererGpuVideoAcceleratorFactories::GetRouteID() {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  if (CheckContextLost())
-    return MSG_ROUTING_NONE;
-  return context_provider_->GetCommandBufferProxy()->route_id();
-}
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 bool RendererGpuVideoAcceleratorFactories::CreateTextures(
     int32_t count,
     const gfx::Size& size,
diff --git a/content/renderer/media/renderer_gpu_video_accelerator_factories.h b/content/renderer/media/renderer_gpu_video_accelerator_factories.h
index e55a11b..a1f1e39 100644
--- a/content/renderer/media/renderer_gpu_video_accelerator_factories.h
+++ b/content/renderer/media/renderer_gpu_video_accelerator_factories.h
@@ -95,10 +95,6 @@ class CONTENT_EXPORT RendererGpuVideoAcceleratorFactories
 
   ~RendererGpuVideoAcceleratorFactories() override;
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  int GetRouteID() override;
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
  private:
   RendererGpuVideoAcceleratorFactories(
       gpu::GpuChannelHost* gpu_channel_host,
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 667fadb..3f3fe7b 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -2448,11 +2448,7 @@ blink::WebMediaPlayer* RenderFrameImpl::createMediaPlayer(
                  base::Unretained(GetContentClient()->renderer()),
                  static_cast<RenderFrame*>(this),
                  GetWebMediaPlayerDelegate()->has_played_media()),
-      audio_renderer_sink, media_log,
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-      render_thread->GetIPCMediaPipelineHostCreator(),
-#endif
-      render_thread->GetMediaThreadTaskRunner(),
+      audio_renderer_sink, media_log, render_thread->GetMediaThreadTaskRunner(),
       render_thread->GetWorkerTaskRunner(),
       render_thread->compositor_task_runner(), context_3d_cb,
       base::Bind(&v8::Isolate::AdjustAmountOfExternalAllocatedMemory,
diff --git a/content/renderer/render_thread_impl.cc b/content/renderer/render_thread_impl.cc
index 6f5eecc..a0f5004 100644
--- a/content/renderer/render_thread_impl.cc
+++ b/content/renderer/render_thread_impl.cc
@@ -193,11 +193,6 @@
 #include "content/renderer/media/webrtc_identity_service.h"
 #endif
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "content/renderer/media/ipc_media_pipeline_host_impl.h"
-#include "media/filters/ipc_audio_decoder.h"
-#endif
-
 #ifdef ENABLE_VTUNE_JIT_INTERFACE
 #include "v8/src/third_party/vtune/v8-vtune.h"
 #endif
@@ -807,14 +802,6 @@ void RenderThreadImpl::Init(
   }
 #endif
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (media::IPCAudioDecoder::IsAvailable()) {
-    media::IPCAudioDecoder::Preinitialize(GetIPCMediaPipelineHostCreator(),
-                                          base::ThreadTaskRunnerHandle::Get(),
-                                          GetMediaThreadTaskRunner());
-  }
-#endif  // USE_SYSTEM_PROPRIETARY_CODECS
-
   memory_pressure_listener_.reset(new base::MemoryPressureListener(
       base::Bind(&RenderThreadImpl::OnMemoryPressure, base::Unretained(this))));
 
@@ -1505,31 +1492,6 @@ media::GpuVideoAcceleratorFactories* RenderThreadImpl::GetGpuFactories() {
   return nullptr;
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-scoped_ptr<media::IPCMediaPipelineHost>
-RenderThreadImpl::CreateIPCMediaPipelineHost(
-    media::GpuVideoAcceleratorFactories* factories,
-    const scoped_refptr<base::SequencedTaskRunner>& decode_task_runner,
-    media::DataSource* data_source) {
-  scoped_refptr<gpu::GpuChannelHost> gpu_channel_host = GetGpuChannel();
-  if (!gpu_channel_host) {
-    gpu_channel_host =
-        EstablishGpuChannelSync(CAUSE_FOR_GPU_LAUNCH_PLATFORM_MEDIA_PIPELINE);
-  }
-  return make_scoped_ptr(gpu_channel_host
-                             ? new IPCMediaPipelineHostImpl(
-                                   gpu_channel_host.get(), decode_task_runner,
-                                   factories, data_source)
-                             : nullptr);
-}
-
-media::IPCMediaPipelineHost::Creator
-RenderThreadImpl::GetIPCMediaPipelineHostCreator() {
-  return base::Bind(&RenderThreadImpl::CreateIPCMediaPipelineHost,
-                    base::Unretained(this), GetGpuFactories());
-}
-#endif
-
 scoped_ptr<WebGraphicsContext3DCommandBufferImpl>
 RenderThreadImpl::CreateOffscreenContext3d() {
   // This is used to create a few different offscreen contexts:
diff --git a/content/renderer/render_thread_impl.h b/content/renderer/render_thread_impl.h
index 65963ca..3d1b5bf 100644
--- a/content/renderer/render_thread_impl.h
+++ b/content/renderer/render_thread_impl.h
@@ -34,10 +34,6 @@
 #include "third_party/WebKit/public/platform/WebConnectionType.h"
 #include "ui/gfx/native_widget_types.h"
 
-#if (defined(OS_WIN) || defined(OS_MACOSX))
-#include "media/filters/ipc_media_pipeline_host.h"
-#endif
-
 #if defined(OS_MACOSX)
 #include "third_party/WebKit/public/web/mac/WebScrollbarTheme.h"
 #endif
@@ -363,11 +359,6 @@ class CONTENT_EXPORT RenderThreadImpl
 
   media::GpuVideoAcceleratorFactories* GetGpuFactories();
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  // This creator must be invoked on the renderer main thread.
-  media::IPCMediaPipelineHost::Creator GetIPCMediaPipelineHostCreator();
-#endif
-
   scoped_refptr<cc_blink::ContextProviderWebContext>
   SharedMainThreadContextProvider();
 
@@ -534,13 +525,6 @@ class CONTENT_EXPORT RenderThreadImpl
 
   void ReleaseFreeMemory();
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  scoped_ptr<media::IPCMediaPipelineHost> CreateIPCMediaPipelineHost(
-      media::GpuVideoAcceleratorFactories* factories,
-      const scoped_refptr<base::SequencedTaskRunner>& decode_task_runner,
-      media::DataSource* data_source);
-#endif
-
   scoped_ptr<WebGraphicsContext3DCommandBufferImpl> CreateOffscreenContext3d();
 
   // These objects live solely on the render thread.
diff --git a/content/renderer/render_thread_impl_browsertest.cc b/content/renderer/render_thread_impl_browsertest.cc
index eeff4c2..f1b21a4 100644
--- a/content/renderer/render_thread_impl_browsertest.cc
+++ b/content/renderer/render_thread_impl_browsertest.cc
@@ -30,11 +30,6 @@
 #include "gpu/GLES2/gl2extchromium.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-// Need to disable IPC Audio for these tests, or the tests will hang
-#include "media/filters/ipc_audio_decoder.h"
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 // IPC messages for testing ----------------------------------------------------
 
 // TODO(mdempsky): Fix properly by moving into a separate
@@ -205,10 +200,6 @@ class RenderThreadImplBrowserTest : public testing::Test {
   scoped_ptr<RenderThreadImplBrowserIPCTestHelper> test_helper_;
   scoped_ptr<MockRenderProcess> mock_process_;
   scoped_refptr<QuitOnTestMsgFilter> test_msg_filter_;
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  // Need to disable IPC Audio for these tests, or the test will hang
-  media::IPCAudioDecoder::ScopedDisableForTesting ipc_audio_decoder_disabler_;
-#endif
   RenderThreadImplForTest* thread_;  // Owned by mock_process_.
   std::string channel_id_;
 };
diff --git a/content/renderer/renderer_blink_platform_impl.cc b/content/renderer/renderer_blink_platform_impl.cc
index e416222..45da15f 100644
--- a/content/renderer/renderer_blink_platform_impl.cc
+++ b/content/renderer/renderer_blink_platform_impl.cc
@@ -474,12 +474,6 @@ RendererBlinkPlatformImpl::MimeRegistry::supportsMediaMIMEType(
     const WebString& codecs) {
   const std::string mime_type_ascii = ToASCIIOrEmpty(mime_type);
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  // Some containers are known to be partially supported.
-  if (media::IsPartiallySupportedMediaMimeType(mime_type_ascii))
-    return MayBeSupported;
-#endif
-
   std::vector<std::string> codec_vector;
   media::ParseCodecString(ToASCIIOrEmpty(codecs), &codec_vector, false);
   return static_cast<WebMimeRegistry::SupportsType>(
diff --git a/content/renderer/renderer_main_platform_delegate_win.cc b/content/renderer/renderer_main_platform_delegate_win.cc
index 6a6346d..25381a5 100644
--- a/content/renderer/renderer_main_platform_delegate_win.cc
+++ b/content/renderer/renderer_main_platform_delegate_win.cc
@@ -27,10 +27,6 @@
 #include "ui/gfx/win/direct_write.h"
 #include "ui/gfx/win/dpi.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/base/win/mf_util.h"
-#endif
-
 namespace content {
 namespace {
 
@@ -43,14 +39,6 @@ void SkiaPreCacheFont(const LOGFONT& logfont) {
   }
 }
 
-void WarmUpMediaFoundation() {
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  media::LoadMFCommonLibraries();
-  media::LoadMFAudioDecoderLibraries();
-  media::LoadMFVideoDecoderLibraries();
-#endif
-}
-
 }  // namespace
 
 RendererMainPlatformDelegate::RendererMainPlatformDelegate(
@@ -84,8 +72,6 @@ void RendererMainPlatformDelegate::PlatformInitialize() {
     } else {
       SkTypeface_SetEnsureLOGFONTAccessibleProc(SkiaPreCacheFont);
     }
-
-    WarmUpMediaFoundation();
   }
   blink::WebFontRendering::setUseDirectWrite(use_direct_write);
   blink::WebFontRendering::setDeviceScaleFactor(gfx::GetDPIScale());
diff --git a/gpu/config/gpu_switches.cc b/gpu/config/gpu_switches.cc
index b67722b..554582d 100644
--- a/gpu/config/gpu_switches.cc
+++ b/gpu/config/gpu_switches.cc
@@ -31,11 +31,4 @@ const char kGpuTestingGLRenderer[] = "gpu-testing-gl-renderer";
 // Override gl version from the GpuInfoCollector.
 const char kGpuTestingGLVersion[] = "gpu-testing-gl-version";
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-// Attempts to turn on hardware accelerated video decoding. Relevant when
-// platform decoders are used.
-const char kEnablePlatformAcceleratedVideoDecoding[] =
-    "enable-platform-accelerated-video-decoding";
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 }  // namespace switches
diff --git a/gpu/config/gpu_switches.h b/gpu/config/gpu_switches.h
index 5c6320e..8bf00f1 100644
--- a/gpu/config/gpu_switches.h
+++ b/gpu/config/gpu_switches.h
@@ -18,10 +18,6 @@ GPU_EXPORT extern const char kGpuTestingGLVendor[];
 GPU_EXPORT extern const char kGpuTestingGLRenderer[];
 GPU_EXPORT extern const char kGpuTestingGLVersion[];
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-GPU_EXPORT extern const char kEnablePlatformAcceleratedVideoDecoding[];
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 }  // namespace switches
 
 #endif  // GPU_CONFIG_GPU_SWITCHES_H_
diff --git a/gpu/ipc/service/gpu_channel.cc b/gpu/ipc/service/gpu_channel.cc
index 2cf9379..7661318 100644
--- a/gpu/ipc/service/gpu_channel.cc
+++ b/gpu/ipc/service/gpu_channel.cc
@@ -30,7 +30,6 @@
 #include "base/trace_event/process_memory_dump.h"
 #include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
-#include "content/public/common/content_switches.h"
 #include "gpu/command_buffer/common/mailbox.h"
 #include "gpu/command_buffer/common/value_state.h"
 #include "gpu/command_buffer/service/command_executor.h"
diff --git a/gpu/ipc/service/gpu_channel.h b/gpu/ipc/service/gpu_channel.h
index 05fa48d..8090b40 100644
--- a/gpu/ipc/service/gpu_channel.h
+++ b/gpu/ipc/service/gpu_channel.h
@@ -183,10 +183,9 @@ class GPU_EXPORT GpuChannel
   // Map of routing id to command buffer stub.
   base::ScopedPtrHashMap<int32_t, scoped_ptr<GpuCommandBufferStub>> stubs_;
 
- protected:
-  virtual bool OnControlMessageReceived(const IPC::Message& msg);
-
  private:
+  bool OnControlMessageReceived(const IPC::Message& msg);
+
   void HandleMessage(const scoped_refptr<GpuChannelMessageQueue>& queue);
 
   // Some messages such as WaitForGetOffsetInRange and WaitForTokenInRange are
@@ -196,14 +195,12 @@ class GPU_EXPORT GpuChannel
 
   void HandleMessageHelper(const IPC::Message& msg);
 
- protected:
   scoped_refptr<GpuChannelMessageQueue> CreateStream(
       int32_t stream_id,
       GpuStreamPriority stream_priority);
 
   scoped_refptr<GpuChannelMessageQueue> LookupStream(int32_t stream_id);
 
- private:
   void DestroyStreamIfNecessary(
       const scoped_refptr<GpuChannelMessageQueue>& queue);
 
@@ -358,7 +355,7 @@ struct GpuChannelMessage {
   DISALLOW_COPY_AND_ASSIGN(GpuChannelMessage);
 };
 
-class GPU_EXPORT GpuChannelMessageQueue
+class GpuChannelMessageQueue
     : public base::RefCountedThreadSafe<GpuChannelMessageQueue> {
  public:
   static scoped_refptr<GpuChannelMessageQueue> Create(
diff --git a/gpu/ipc/service/gpu_channel_manager.h b/gpu/ipc/service/gpu_channel_manager.h
index 91af037..9b39cda 100644
--- a/gpu/ipc/service/gpu_channel_manager.h
+++ b/gpu/ipc/service/gpu_channel_manager.h
@@ -170,7 +170,6 @@ class GPU_EXPORT GpuChannelManager {
   PreemptionFlag* preemption_flag() const {
     return preemption_flag_.get();
   }
-  GpuWatchdog* watchdog() {return watchdog_;}
 
   scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
   scoped_refptr<base::SingleThreadTaskRunner> io_task_runner_;
diff --git a/ipc/ipc_message_start.h b/ipc/ipc_message_start.h
index d4f51f5..c3abddc 100644
--- a/ipc/ipc_message_start.h
+++ b/ipc/ipc_message_start.h
@@ -79,7 +79,6 @@ enum IPCMessageStart {
   WebSocketMsgStart,
   NaClHostMsgStart,
   WebRTCIdentityMsgStart,
-  MediaPipelineMsgStart,
   PowerMonitorMsgStart,
   EncryptedMediaMsgStart,
   CacheStorageMsgStart,
diff --git a/ipc/ipc_message_utils.cc b/ipc/ipc_message_utils.cc
index ca9c82b..9edc3bb 100644
--- a/ipc/ipc_message_utils.cc
+++ b/ipc/ipc_message_utils.cc
@@ -424,8 +424,7 @@ void ParamTraits<unsigned int>::Log(const param_type& p, std::string* l) {
 }
 
 #if defined(OS_WIN) || defined(OS_LINUX) || \
-    (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS)) || \
-    defined(USE_SYSTEM_PROPRIETARY_CODECS)
+    (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
 void ParamTraits<long>::Log(const param_type& p, std::string* l) {
   l->append(base::Int64ToString(static_cast<int64_t>(p)));
 }
diff --git a/ipc/ipc_message_utils.h b/ipc/ipc_message_utils.h
index 0163978..cf4fa8f 100644
--- a/ipc/ipc_message_utils.h
+++ b/ipc/ipc_message_utils.h
@@ -209,8 +209,7 @@ struct ParamTraits<unsigned int> {
 // Since we want to support Android 32<>64 bit IPC, as long as we don't have
 // these traits for 32 bit ARM then that'll catch any errors.
 #if defined(OS_WIN) || defined(OS_LINUX) || \
-    (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS)) || \
-    defined(USE_SYSTEM_PROPRIETARY_CODECS)
+    (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
 template <>
 struct ParamTraits<long> {
   typedef long param_type;
@@ -307,35 +306,6 @@ struct IPC_EXPORT ParamTraits<double> {
   static void Log(const param_type& p, std::string* l);
 };
 
-template <class P, size_t n>
-struct ParamTraits<P[n]> {
-  typedef P param_type[n];
-  static void Write(base::Pickle* m, const param_type& p) {
-    WriteParam(m, static_cast<int>(n));
-    for (size_t i = 0; i < n; i++)
-      WriteParam(m, p[i]);
-  }
-  static bool Read(const base::Pickle* m,
-                   base::PickleIterator* iter,
-                   param_type* r) {
-    int size;
-    if (!iter->ReadLength(&size) || size != static_cast<int>(n))
-      return false;
-    for (int i = 0; i < size; i++) {
-      if (!ReadParam(m, iter, &(*r)[i]))
-        return false;
-    }
-    return true;
-  }
-  static void Log(const param_type& p, std::string* l) {
-    for (size_t i = 0; i < n; ++i) {
-      if (i != 0)
-        l->append(" ");
-      LogParam((p[i]), l);
-    }
-  }
-};
-
 // STL ParamTraits -------------------------------------------------------------
 
 template <>
diff --git a/media/base/audio_decoder_config.cc b/media/base/audio_decoder_config.cc
index 7c2b784..253c82b 100644
--- a/media/base/audio_decoder_config.cc
+++ b/media/base/audio_decoder_config.cc
@@ -15,7 +15,6 @@ AudioDecoderConfig::AudioDecoderConfig()
       bytes_per_channel_(0),
       channel_layout_(CHANNEL_LAYOUT_UNSUPPORTED),
       samples_per_second_(0),
-      input_samples_per_second_(0),
       bytes_per_frame_(0),
       codec_delay_(0) {}
 
@@ -44,7 +43,6 @@ void AudioDecoderConfig::Initialize(AudioCodec codec,
   codec_ = codec;
   channel_layout_ = channel_layout;
   samples_per_second_ = samples_per_second;
-  input_samples_per_second_ = 0;
   sample_format_ = sample_format;
   bytes_per_channel_ = SampleFormatToBytesPerChannel(sample_format);
   extra_data_ = extra_data;
@@ -65,10 +63,9 @@ bool AudioDecoderConfig::IsValidConfig() const {
          bytes_per_channel_ <= limits::kMaxBytesPerSample &&
          samples_per_second_ > 0 &&
          samples_per_second_ <= limits::kMaxSampleRate &&
-         input_samples_per_second_ >= 0 &&
-         input_samples_per_second_ <= limits::kMaxSampleRate &&
          sample_format_ != kUnknownSampleFormat &&
-         seek_preroll_ >= base::TimeDelta() && codec_delay_ >= 0;
+         seek_preroll_ >= base::TimeDelta() &&
+         codec_delay_ >= 0;
 }
 
 bool AudioDecoderConfig::Matches(const AudioDecoderConfig& config) const {
diff --git a/media/base/audio_decoder_config.h b/media/base/audio_decoder_config.h
index 24d2619..266de82 100644
--- a/media/base/audio_decoder_config.h
+++ b/media/base/audio_decoder_config.h
@@ -87,25 +87,12 @@ class MEDIA_EXPORT AudioDecoderConfig {
     return encryption_scheme_;
   }
 
-  // The sampling rate on decoder input.  Note that |samples_per_second| refers
-  // to the output sampling rate.
-  // TODO(wdzierzanowski): This should become unnecessary when DNA-35764 is
-  // fixed.
-  int input_samples_per_second() const {
-    return input_samples_per_second_ > 0 ? input_samples_per_second_
-                                         : samples_per_second_;
-  }
-  void set_input_samples_per_second(int input_samples_per_second) {
-    input_samples_per_second_ = input_samples_per_second;
-  }
-
  private:
   AudioCodec codec_;
   SampleFormat sample_format_;
   int bytes_per_channel_;
   ChannelLayout channel_layout_;
   int samples_per_second_;
-  int input_samples_per_second_;
   int bytes_per_frame_;
   std::vector<uint8_t> extra_data_;
   EncryptionScheme encryption_scheme_;
diff --git a/media/base/container_names.cc b/media/base/container_names.cc
index 8a23796..24d8ea9 100644
--- a/media/base/container_names.cc
+++ b/media/base/container_names.cc
@@ -1079,6 +1079,8 @@ static bool ValidMpegAudioFrameHeader(const uint8_t* header,
   }
   if (layer == LAYER_1)
     *framesize = ((12000 * bitrate) / sampling_rate + padding) * 4;
+  else
+    *framesize = (144000 * bitrate) / sampling_rate + padding;
   return (bitrate > 0 && sampling_rate > 0);
 }
 
@@ -1674,48 +1676,6 @@ MediaContainerName DetermineContainer(const uint8_t* buffer, int buffer_size) {
   return CONTAINER_UNKNOWN;
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-static bool CheckMP4(const uint8_t* buffer, int buffer_size) {
-  // Reference: Media Type Sniffing draft-ietf-websec-mime-sniff-03
-  // https://tools.ietf.org/html/draft-ietf-websec-mime-sniff-03#page-16
-  RCHECK(buffer_size >= 12);
-  int box_size = Read32(buffer);
-  if (box_size <= 0 || buffer_size < box_size || (box_size % 4 != 0))
-    return false;
-  uint32_t atom_type = Read32(buffer + 4);
-  if (atom_type == TAG('f', 't', 'y', 'p')) {
-    const char mp4_tag[3] = {'m', 'p', '4'};
-    for (int i = 2; i <= box_size / 4 - 1; i++) {
-      if (i == 3)
-        continue;
-      if (buffer_size < 4 * i + 3)
-        return false;  // Buffer ended.
-      if (memcmp(buffer + 4 * i, mp4_tag, 3) == 0)
-        return true;
-    }
-  }
-  return false;
-}
-
-MediaContainerName OperaDetermineContainer(const uint8_t* buffer,
-                                           int buffer_size) {
-  DCHECK(buffer);
-
-  MediaContainerName result = LookupContainerByFirst4(buffer, buffer_size);
-  if (result != CONTAINER_UNKNOWN)
-    return result;
-
-  if (CheckMP4(buffer, buffer_size))
-    // Formally MP4 isn't the same as H264 but we lack proper name.
-    return CONTAINER_H264;
-
-  if (CheckH264(buffer, buffer_size))
-    return CONTAINER_H264;
-
-  return CONTAINER_UNKNOWN;
-}
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 }  // namespace container_names
 
 }  // namespace media
diff --git a/media/base/container_names.h b/media/base/container_names.h
index c099ba9..e3885ae 100644
--- a/media/base/container_names.h
+++ b/media/base/container_names.h
@@ -66,13 +66,6 @@ enum MediaContainerName {
 MEDIA_EXPORT MediaContainerName DetermineContainer(const uint8_t* buffer,
                                                    int buffer_size);
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-// This is a simplified version used by Opera's ProtocolSniffer, in particular
-// we don't want to CheckMov as it triggers also for MPEG4.
-MEDIA_EXPORT MediaContainerName
-    OperaDetermineContainer(const uint8_t* buffer, int buffer_size);
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 }  // namespace container_names
 
 }  // namespace media
diff --git a/media/base/container_names_unittest.cc b/media/base/container_names_unittest.cc
index 3e2ce5d..b05632a 100644
--- a/media/base/container_names_unittest.cc
+++ b/media/base/container_names_unittest.cc
@@ -148,66 +148,6 @@ void TestFile(MediaContainerName expected, const base::FilePath& filename) {
       << "Failure with file " << filename.value();
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-// Determine the container type of a specified file.
-void OperaTestFile(MediaContainerName expected,
-                   const base::FilePath& filename) {
-  char buffer[8192];
-
-  // Windows implementation of ReadFile fails if file smaller than desired size,
-  // so use file length if file less than 8192 bytes (http://crbug.com/243885).
-  int read_size = sizeof(buffer);
-  int64_t actual_size;
-  if (base::GetFileSize(filename, &actual_size) && actual_size < read_size)
-    read_size = actual_size;
-  int read = base::ReadFile(filename, buffer, read_size);
-
-  // Now verify the type.
-  EXPECT_EQ(
-      expected,
-      OperaDetermineContainer(reinterpret_cast<const uint8_t*>(buffer), read))
-      << "Failure (Opera) with file " << filename.value();
-}
-
-TEST(ContainerNamesTest, OperaFileCheckMP4) {
-  OperaTestFile(CONTAINER_H264, GetTestDataFilePath("bear-1280x720.mp4"));
-  EXPECT_EQ(
-     CONTAINER_H264,
-     OperaDetermineContainer(reinterpret_cast<const uint8_t*>(kBug263073Buffer),
-                              sizeof(kBug263073Buffer)));
-}
-
-uint8_t kBigBoxSize[] = {0x00, 0x66, 0x00, 0x18, 0x66, 0x74, 0x79,
-                       0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                       0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00};
-
-uint8_t kNegativeBoxSize[] = {0xF2, 0x26, 0x01, 0x1C, 0x66, 0x74, 0x79,
-                            0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                            0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00};
-
-// Try a few non containers.
-TEST(ContainerNamesTest, OperaFileCheckUNKNOWN) {
-  OperaTestFile(CONTAINER_UNKNOWN, GetTestDataFilePath("ten_byte_file"));
-  OperaTestFile(CONTAINER_UNKNOWN, GetTestDataFilePath("README"));
-  OperaTestFile(CONTAINER_UNKNOWN,
-                GetTestDataFilePath("bali_640x360_P422.yuv"));
-  OperaTestFile(CONTAINER_UNKNOWN,
-                GetTestDataFilePath("bali_640x360_RGB24.rgb"));
-  OperaTestFile(CONTAINER_UNKNOWN, GetTestDataFilePath("webm_vp8_track_entry"));
-
-  EXPECT_EQ(CONTAINER_UNKNOWN,
-      OperaDetermineContainer(reinterpret_cast<const uint8_t*>(kBigBoxSize),
-                                    sizeof(kBigBoxSize)));
-  EXPECT_EQ(
-     CONTAINER_UNKNOWN,
-     OperaDetermineContainer(reinterpret_cast<const uint8_t*>(kNegativeBoxSize),
-                              sizeof(kNegativeBoxSize)));
-}
-
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 TEST(ContainerNamesTest, FileCheckOGG) {
   TestFile(CONTAINER_OGG, GetTestDataFilePath("bear.ogv"));
   TestFile(CONTAINER_OGG, GetTestDataFilePath("9ch.ogg"));
diff --git a/media/base/decoder_buffer.h b/media/base/decoder_buffer.h
index 16b4d82..9010eaa 100644
--- a/media/base/decoder_buffer.h
+++ b/media/base/decoder_buffer.h
@@ -22,10 +22,6 @@
 #include "media/base/media_export.h"
 #include "media/base/timestamp_constants.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/filters/pass_through_decoder_texture.h"
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 namespace media {
 
 // A specialized buffer for interfacing with audio / video decoders.
@@ -166,17 +162,6 @@ class MEDIA_EXPORT DecoderBuffer
     splice_timestamp_ = splice_timestamp;
   }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  scoped_ptr<AutoReleasedPassThroughDecoderTexture> PassWrappedTexture() {
-    return std::move(wrapped_texture_);
-  }
-
-  void set_wrapped_texture(scoped_ptr<
-      media::AutoReleasedPassThroughDecoderTexture> wrapped_texture) {
-    wrapped_texture_ = std::move(wrapped_texture);
-  }
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
   bool is_key_frame() const {
     DCHECK(!end_of_stream());
     return is_key_frame_;
@@ -219,10 +204,6 @@ class MEDIA_EXPORT DecoderBuffer
   base::TimeDelta splice_timestamp_;
   bool is_key_frame_;
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  scoped_ptr<media::AutoReleasedPassThroughDecoderTexture> wrapped_texture_;
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
   // Constructor helper method for memory allocations.
   void Initialize();
 
diff --git a/media/base/mac/avfoundation_glue.h b/media/base/mac/avfoundation_glue.h
index 1438f6a..a5b4304 100644
--- a/media/base/mac/avfoundation_glue.h
+++ b/media/base/mac/avfoundation_glue.h
@@ -20,7 +20,6 @@
 
 #include "base/macros.h"
 #include "media/base/mac/coremedia_glue.h"
-#include "media/base/mac/mediatoolbox_glue.h"
 #include "media/base/media_export.h"
 
 class MEDIA_EXPORT AVFoundationGlue {
@@ -46,30 +45,10 @@ class MEDIA_EXPORT AVFoundationGlue {
   static NSString* AVCaptureSessionDidStopRunningNotification();
   static NSString* AVCaptureSessionErrorKey();
 
-  // Originally from AVAudioSettings.h but in global namespace.
-  static NSString* AVFormatIDKey();
-  static NSString* AVChannelLayoutKey();
-
   // Originally from AVVideoSettings.h but in global namespace.
   static NSString* AVVideoScalingModeKey();
   static NSString* AVVideoScalingModeResizeAspectFill();
 
-  static NSString* AVPlayerItemDidPlayToEndTimeNotification();
-  static NSString* AVPlayerItemFailedToPlayToEndTimeNotification();
-  static Class AVAssetClass();
-  static Class AVAssetReaderClass();
-  static Class AVAssetReaderTrackOutputClass();
-  static Class AVAssetResourceLoaderClass();
-  static Class AVAssetResourceLoadingContentInformationRequestClass();
-  static Class AVAssetResourceLoadingDataRequestClass();
-  static Class AVAssetResourceLoadingRequestClass();
-
-  static Class AVMutableAudioMixClass();
-  static Class AVMutableAudioMixInputParametersClass();
-  static Class AVPlayerClass();
-  static Class AVPlayerItemClass();
-  static Class AVPlayerItemVideoOutputClass();
-
   static Class AVCaptureSessionClass();
   static Class AVCaptureVideoDataOutputClass();
 #endif  // defined(__OBJC__)
@@ -80,64 +59,6 @@ class MEDIA_EXPORT AVFoundationGlue {
 
 #if defined(__OBJC__)
 
-// Originally AVAssetResourceLoadingContentInformationRequest and coming from
-// AVAssetResourceLoader.h.
-@interface CrAVAssetResourceLoadingContentInformationRequest : NSObject
-
-- (NSString*)contentType;
-- (void)setContentType:(NSString*)type;
-- (int64_t)contentLength;
-- (void)setContentLength:(int64_t)length;
-- (void)setByteRangeAccessSupported:(bool)supported;
-
-@end
-
-// Originally AVAssetResourceLoadingDataRequest and coming from
-// AVAssetResourceLoader.h.
-@interface CrAVAssetResourceLoadingDataRequest : NSObject
-
-- (void)respondWithData:(NSData*)data;
-- (int64_t)requestedOffset;
-- (NSInteger)requestedLength;
-- (int64_t)currentOffset;
-
-@end
-
-// Originally AVAssetResourceLoadingRequest and coming from
-// AVAssetResourceLoader.h.
-@interface CrAVAssetResourceLoadingRequest : NSObject
-
-- (CrAVAssetResourceLoadingDataRequest*)dataRequest;
-- (void)finishLoading;
-- (void)finishLoadingWithError:(NSError*)error;
-- (bool)isFinished;
-- (NSURLRequest*)request;
-- (CrAVAssetResourceLoadingContentInformationRequest*)contentInformationRequest;
-
-@end
-
-@class CrAVAssetResourceLoader;
-
-// Originally AVAssetResourceLoaderDelegate and coming from
-// AVAssetResourceLoader.h.
-@protocol CrAVAssetResourceLoaderDelegate<NSObject>
-
-- (BOOL)resourceLoader:(CrAVAssetResourceLoader*)resourceLoader
-    shouldWaitForLoadingOfRequestedResource:
-        (CrAVAssetResourceLoadingRequest*)loadingRequest;
-- (void)resourceLoader:(CrAVAssetResourceLoader*)resourceLoader
-    didCancelLoadingRequest:(CrAVAssetResourceLoadingRequest*)loadingRequest;
-
-@end
-
-// Originally AVAssetResourceLoader and coming from AVAssetResourceLoader.h.
-@interface CrAVAssetResourceLoader : NSObject
-
-- (void)setDelegate:(id<CrAVAssetResourceLoaderDelegate>)delegate
-              queue:(dispatch_queue_t)delegateQueue;
-
-@end
-
 // Originally AVCaptureDevice and coming from AVCaptureDevice.h
 MEDIA_EXPORT
 @interface CrAVCaptureDevice : NSObject
@@ -245,13 +166,6 @@ MEDIA_EXPORT
 
 @end
 
-// Originally AVMutableAudioMixInputParameters and coming from AVAudioMix.h.
-@interface CrAVMutableAudioMixInputParameters : AVAudioMixInputParameters
-
-- (void)setAudioTapProcessor:(MediaToolboxGlue::MTAudioProcessingTapRef)tap;
-
-@end
-
 // Class to provide access to class methods of AVCaptureDeviceInput.
 MEDIA_EXPORT
 @interface AVCaptureDeviceInputGlue : NSObject
diff --git a/media/base/mac/avfoundation_glue.mm b/media/base/mac/avfoundation_glue.mm
index 83bc09c..84b7734 100644
--- a/media/base/mac/avfoundation_glue.mm
+++ b/media/base/mac/avfoundation_glue.mm
@@ -19,7 +19,6 @@
 // Forward declarations of AVFoundation.h strings.
 // This is needed to avoid compile time warnings since currently
 // |mac_deployment_target| is 10.6.
-extern NSString* const AVPlayerItemDidPlayToEndTimeNotification;
 extern NSString* const AVCaptureDeviceWasConnectedNotification;
 extern NSString* const AVCaptureDeviceWasDisconnectedNotification;
 extern NSString* const AVMediaTypeVideo;
@@ -45,12 +44,6 @@ class AVFoundationInternal {
 
   NSBundle* bundle() const { return bundle_; }
 
-  NSString* AVPlayerItemDidPlayToEndTimeNotification() const {
-    return AVPlayerItemDidPlayToEndTimeNotification_;
-  }
-  NSString* AVPlayerItemFailedToPlayToEndTimeNotification() const {
-    return AVPlayerItemFailedToPlayToEndTimeNotification_;
-  }
   NSString* AVCaptureDeviceWasConnectedNotification() const {
     return AVCaptureDeviceWasConnectedNotification_;
   }
@@ -69,8 +62,6 @@ class AVFoundationInternal {
   NSString* AVCaptureSessionErrorKey() const {
     return AVCaptureSessionErrorKey_;
   }
-  NSString* AVFormatIDKey() const { return AVFormatIDKey_; }
-  NSString* AVChannelLayoutKey() const { return AVChannelLayoutKey_; }
   NSString* AVVideoScalingModeKey() const { return AVVideoScalingModeKey_; }
   NSString* AVVideoScalingModeResizeAspectFill() const {
     return AVVideoScalingModeResizeAspectFill_;
@@ -80,10 +71,6 @@ class AVFoundationInternal {
   NSBundle* bundle_;
   void* library_handle_;
   // The following members are replicas of the respectives in AVFoundation.
-  NSString* AVPlayerItemDidPlayToEndTimeNotification_ =
-      ::AVPlayerItemDidPlayToEndTimeNotification;
-  NSString* AVPlayerItemFailedToPlayToEndTimeNotification_ =
-      ::AVPlayerItemFailedToPlayToEndTimeNotification;
   NSString* AVCaptureDeviceWasConnectedNotification_ =
       ::AVCaptureDeviceWasConnectedNotification;
   NSString* AVCaptureDeviceWasDisconnectedNotification_ =
@@ -96,8 +83,6 @@ class AVFoundationInternal {
   NSString* AVCaptureSessionDidStopRunningNotification_ =
       ::AVCaptureSessionDidStopRunningNotification;
   NSString* AVCaptureSessionErrorKey_ = ::AVCaptureSessionErrorKey;
-  NSString* AVFormatIDKey_ = ::AVFormatIDKey;
-  NSString* AVChannelLayoutKey_ = ::AVChannelLayoutKey;
   NSString* AVVideoScalingModeKey_ = ::AVVideoScalingModeKey;
   NSString* AVVideoScalingModeResizeAspectFill_ =
       ::AVVideoScalingModeResizeAspectFill;
@@ -105,25 +90,35 @@ class AVFoundationInternal {
   DISALLOW_COPY_AND_ASSIGN(AVFoundationInternal);
 };
 
+static base::ThreadLocalStorage::StaticSlot g_avfoundation_handle =
+    TLS_INITIALIZER;
+
+void TlsCleanup(void* value) {
+  delete static_cast<AVFoundationInternal*>(value);
+}
+
+AVFoundationInternal* GetAVFoundationInternal() {
+  return static_cast<AVFoundationInternal*>(g_avfoundation_handle.Get());
+}
+
 // This contains the logic of checking whether AVFoundation is supported.
 // It's called only once and the results are cached in a static bool.
 bool LoadAVFoundationInternal() {
+  g_avfoundation_handle.Initialize(TlsCleanup);
+  g_avfoundation_handle.Set(new AVFoundationInternal());
   const bool ret = [AVFoundationGlue::AVFoundationBundle() load];
   CHECK(ret);
   return ret;
 }
 
-}  // namespace
-
-static base::LazyInstance<AVFoundationInternal>::Leaky g_avfoundation_handle =
-    LAZY_INSTANCE_INITIALIZER;
-
 enum {
   INITIALIZE_NOT_CALLED = 0,
   AVFOUNDATION_IS_SUPPORTED,
   AVFOUNDATION_NOT_SUPPORTED
 } static g_avfoundation_initialization = INITIALIZE_NOT_CALLED;
 
+}  // namespace
+
 void AVFoundationGlue::InitializeAVFoundation() {
   TRACE_EVENT0("video", "AVFoundationGlue::InitializeAVFoundation");
   CHECK([NSThread isMainThread]);
@@ -134,66 +129,49 @@ void AVFoundationGlue::InitializeAVFoundation() {
 }
 
 NSBundle const* AVFoundationGlue::AVFoundationBundle() {
-  return g_avfoundation_handle.Get().bundle();
+  return GetAVFoundationInternal()->bundle();
 }
 
 NSString* AVFoundationGlue::AVCaptureDeviceWasConnectedNotification() {
-  return g_avfoundation_handle.Get().AVCaptureDeviceWasConnectedNotification();
+  return GetAVFoundationInternal()->AVCaptureDeviceWasConnectedNotification();
 }
 
 NSString* AVFoundationGlue::AVCaptureDeviceWasDisconnectedNotification() {
-  return
-      g_avfoundation_handle.Get().AVCaptureDeviceWasDisconnectedNotification();
+  return GetAVFoundationInternal()
+      ->AVCaptureDeviceWasDisconnectedNotification();
 }
 
 NSString* AVFoundationGlue::AVMediaTypeVideo() {
-  return g_avfoundation_handle.Get().AVMediaTypeVideo();
+  return GetAVFoundationInternal()->AVMediaTypeVideo();
 }
 
 NSString* AVFoundationGlue::AVMediaTypeAudio() {
-  return g_avfoundation_handle.Get().AVMediaTypeAudio();
+  return GetAVFoundationInternal()->AVMediaTypeAudio();
 }
 
 NSString* AVFoundationGlue::AVMediaTypeMuxed() {
-  return g_avfoundation_handle.Get().AVMediaTypeMuxed();
+  return GetAVFoundationInternal()->AVMediaTypeMuxed();
 }
 
 NSString* AVFoundationGlue::AVCaptureSessionRuntimeErrorNotification() {
-  return g_avfoundation_handle.Get().AVCaptureSessionRuntimeErrorNotification();
+  return GetAVFoundationInternal()->AVCaptureSessionRuntimeErrorNotification();
 }
 
 NSString* AVFoundationGlue::AVCaptureSessionDidStopRunningNotification() {
-  return
-      g_avfoundation_handle.Get().AVCaptureSessionDidStopRunningNotification();
+  return GetAVFoundationInternal()
+      ->AVCaptureSessionDidStopRunningNotification();
 }
 
 NSString* AVFoundationGlue::AVCaptureSessionErrorKey() {
-  return g_avfoundation_handle.Get().AVCaptureSessionErrorKey();
-}
-
-NSString* AVFoundationGlue::AVFormatIDKey() {
-  return g_avfoundation_handle.Get().AVFormatIDKey();
-}
-
-NSString* AVFoundationGlue::AVChannelLayoutKey() {
-  return g_avfoundation_handle.Get().AVChannelLayoutKey();
+  return GetAVFoundationInternal()->AVCaptureSessionErrorKey();
 }
 
 NSString* AVFoundationGlue::AVVideoScalingModeKey() {
-  return g_avfoundation_handle.Get().AVVideoScalingModeKey();
+  return GetAVFoundationInternal()->AVVideoScalingModeKey();
 }
 
 NSString* AVFoundationGlue::AVVideoScalingModeResizeAspectFill() {
-  return g_avfoundation_handle.Get().AVVideoScalingModeResizeAspectFill();
-}
-
-NSString* AVFoundationGlue::AVPlayerItemDidPlayToEndTimeNotification() {
-  return g_avfoundation_handle.Get().AVPlayerItemDidPlayToEndTimeNotification();
-}
-
-NSString* AVFoundationGlue::AVPlayerItemFailedToPlayToEndTimeNotification() {
-  return g_avfoundation_handle.Get().
-      AVPlayerItemFailedToPlayToEndTimeNotification();
+  return GetAVFoundationInternal()->AVVideoScalingModeResizeAspectFill();
 }
 
 Class AVFoundationGlue::AVCaptureSessionClass() {
@@ -204,55 +182,6 @@ Class AVFoundationGlue::AVCaptureVideoDataOutputClass() {
   return [AVFoundationBundle() classNamed:@"AVCaptureVideoDataOutput"];
 }
 
-Class AVFoundationGlue::AVAssetClass() {
-  return [AVFoundationBundle() classNamed:@"AVAsset"];
-}
-
-Class AVFoundationGlue::AVAssetReaderClass() {
-  return [AVFoundationBundle() classNamed:@"AVAssetReader"];
-}
-
-Class AVFoundationGlue::AVAssetReaderTrackOutputClass() {
-  return [AVFoundationBundle() classNamed:@"AVAssetReaderTrackOutput"];
-}
-
-Class AVFoundationGlue::AVAssetResourceLoaderClass() {
-  return [AVFoundationBundle() classNamed:@"AVAssetResourceLoader"];
-}
-
-Class AVFoundationGlue::AVAssetResourceLoadingContentInformationRequestClass() {
-  return [AVFoundationBundle()
-      classNamed:@"AVAssetResourceLoadingContentInformationRequest"];
-}
-
-Class AVFoundationGlue::AVAssetResourceLoadingDataRequestClass() {
-  return [AVFoundationBundle() classNamed:@"AVAssetResourceLoadingDataRequest"];
-}
-
-Class AVFoundationGlue::AVAssetResourceLoadingRequestClass() {
-  return [AVFoundationBundle() classNamed:@"AVAssetResourceLoadingRequest"];
-}
-
-Class AVFoundationGlue::AVMutableAudioMixClass() {
-  return [AVFoundationBundle() classNamed:@"AVMutableAudioMix"];
-}
-
-Class AVFoundationGlue::AVPlayerClass() {
-  return [AVFoundationBundle() classNamed:@"AVPlayer"];
-}
-
-Class AVFoundationGlue::AVPlayerItemClass() {
-  return [AVFoundationBundle() classNamed:@"AVPlayerItem"];
-}
-
-Class AVFoundationGlue::AVPlayerItemVideoOutputClass() {
-  return [AVFoundationBundle() classNamed:@"AVPlayerItemVideoOutput"];
-}
-
-Class AVFoundationGlue::AVMutableAudioMixInputParametersClass() {
-  return [AVFoundationBundle() classNamed:@"AVMutableAudioMixInputParameters"];
-}
-
 @implementation AVCaptureDeviceGlue
 
 + (NSArray*)devices {
@@ -283,125 +212,3 @@ Class AVFoundationGlue::AVMutableAudioMixInputParametersClass() {
 }
 
 @end  // @implementation AVCaptureDeviceInputGlue
-
-@implementation CrAVAssetResourceLoader
-
-- (void) setDelegate:(id<CrAVAssetResourceLoaderDelegate>)delegate
-               queue:(dispatch_queue_t)delegateQueue {
-  SEL selector =
-      @selector(setDelegate:CrAVAssetResourceLoaderDelegate:dispatch_queue_t:);
-  NSInvocation* inv = [NSInvocation invocationWithMethodSignature:
-      [AVFoundationGlue::AVAssetResourceLoaderClass()
-          methodSignatureForSelector:selector]];
-  [inv setSelector:selector];
-  [inv setTarget:AVFoundationGlue::AVAssetResourceLoaderClass()];
-  [inv setArgument:&delegate atIndex:2];
-  [inv setArgument:&delegateQueue atIndex:3];
-  [inv invoke];
-}
-
-@end
-
-@implementation CrAVAssetResourceLoadingDataRequest
-
-- (void) respondWithData:(NSData*)data {
-  [AVFoundationGlue::AVAssetResourceLoadingDataRequestClass()
-      performSelector:@selector(respondWithData) withObject:data];
-}
-
-- (int64_t) requestedOffset {
-  return (int64_t)([AVFoundationGlue::AVAssetResourceLoadingDataRequestClass()
-      performSelector:@selector(requestedOffset)]);
-}
-
-- (NSInteger) requestedLength {
-  return (NSInteger)[AVFoundationGlue::AVAssetResourceLoadingDataRequestClass()
-                     performSelector : @selector(requestedLength)];
-}
-
-- (int64_t) currentOffset {
-  return (int64_t)([AVFoundationGlue::AVAssetResourceLoadingDataRequestClass()
-      performSelector:@selector(currentOffset)]);
-}
-
-@end
-
-@implementation CrAVAssetResourceLoadingRequest : NSObject
-
-- (CrAVAssetResourceLoadingDataRequest*) dataRequest {
-  return (CrAVAssetResourceLoadingDataRequest*)
-      ([AVFoundationGlue::AVAssetResourceLoadingRequestClass()
-          performSelector:@selector(dataRequest)]);
-}
-
-- (void) finishLoading {
-  [AVFoundationGlue::AVAssetResourceLoadingRequestClass()
-      performSelector:@selector(finishLoading)];
-}
-
-- (void) finishLoadingWithError:(NSError*)error {
-  [AVFoundationGlue::AVAssetResourceLoadingRequestClass()
-      performSelector:@selector(finishLoading) withObject:error];
-}
-
--(bool) isFinished {
-  return (bool)([AVFoundationGlue::AVAssetResourceLoadingRequestClass()
-      performSelector:@selector(isFinished)]);
-}
-
-- (NSURLRequest*) request {
-  return (NSURLRequest*)([AVFoundationGlue::AVAssetResourceLoadingRequestClass()
-      performSelector:@selector(request)]);
-}
-
-- (CrAVAssetResourceLoadingContentInformationRequest*)
-    contentInformationRequest {
-  return (CrAVAssetResourceLoadingContentInformationRequest*)
-      ([AVFoundationGlue::AVAssetResourceLoadingRequestClass()
-          performSelector:@selector(contentInformationRequest)]);
-}
-
-@end
-
-@implementation CrAVAssetResourceLoadingContentInformationRequest
-
-- (NSString*) contentType {
-  return (NSString*)
-      [AVFoundationGlue::AVAssetResourceLoadingContentInformationRequestClass()
-          performSelector:@selector(contentType)];
-}
-
-- (void) setContentType:(NSString*)type {
-  [AVFoundationGlue::AVAssetResourceLoadingContentInformationRequestClass()
-      performSelector:@selector(setContentType) withObject:type];
-}
-
-- (int64_t) contentLength {
-  return (int64_t)
-      [AVFoundationGlue::AVAssetResourceLoadingContentInformationRequestClass()
-          performSelector:@selector(contentLength)];
-}
-
-- (void) setContentLength:(int64_t)length {
-  NSNumber* object = [NSNumber numberWithLong:length];
-  [AVFoundationGlue::AVAssetResourceLoadingContentInformationRequestClass()
-      performSelector:@selector(setContentLength) withObject:object];
-}
-
-- (void) setByteRangeAccessSupported:(bool)supported {
-  [AVFoundationGlue::AVAssetResourceLoadingContentInformationRequestClass()
-      performSelector:@selector(setByteRangeAccessSupported)
-           withObject:[NSNumber numberWithBool:supported]];
-}
-
-@end
-
-@implementation CrAVMutableAudioMixInputParameters
-
-- (void) setAudioTapProcessor:(MediaToolboxGlue::MTAudioProcessingTapRef)tap {
-  [AVFoundationGlue::AVMutableAudioMixInputParametersClass()
-      performSelector:@selector(setAudioTapProcessor)
-           withObject:[NSValue valueWithPointer:tap]];
-}
-
-@end
diff --git a/media/base/mac/coremedia_glue.h b/media/base/mac/coremedia_glue.h
index 0f0f1a1..9f69f96 100644
--- a/media/base/mac/coremedia_glue.h
+++ b/media/base/mac/coremedia_glue.h
@@ -12,12 +12,6 @@
 #include "base/macros.h"
 #include "media/base/media_export.h"
 
-// Must use the same packing as the original structures defined in the OS X SDK
-// to make sure data types are aligned the same way on different architectures.
-#pragma pack(push, 4)
-
-struct AudioFormatListItem;
-
 // CoreMedia API is only introduced in Mac OS X > 10.6, the (potential) linking
 // with it has to happen in runtime. If it succeeds, subsequent clients can use
 // CoreMedia via the class declared in this file, where the original naming has
@@ -36,15 +30,6 @@ class MEDIA_EXPORT CoreMediaGlue {
     CMTimeEpoch epoch;
   } CMTime;
 
-  static const CMTime kCMTimeZero;
-  static const CMTime kCMTimePositiveInfinity;
-
-  // Originally from CMTimeRange.h
-  typedef struct {
-    CMTime start;
-    CMTime duration;
-  } CMTimeRange;
-
   // Originally from CMBlockBuffer.h
   typedef uint32_t CMBlockBufferFlags;
   typedef struct OpaqueCMBlockBuffer* CMBlockBufferRef;
@@ -57,7 +42,6 @@ class MEDIA_EXPORT CoreMediaGlue {
 
   // Originally from CMFormatDescription.h.
   typedef const struct opaqueCMFormatDescription* CMFormatDescriptionRef;
-  typedef CMFormatDescriptionRef CMAudioFormatDescriptionRef;
   typedef CMFormatDescriptionRef CMVideoFormatDescriptionRef;
   typedef FourCharCode CMVideoCodecType;
   typedef struct {
@@ -77,32 +61,13 @@ class MEDIA_EXPORT CoreMediaGlue {
     kCMFormatDescriptionBridgeError_InvalidParameter = -12712,
   };
 
-  static const AudioFormatListItem*
-  CMAudioFormatDescriptionGetRichestDecodableFormat(
-      CMAudioFormatDescriptionRef desc);
-  static CGRect CMVideoFormatDescriptionGetCleanAperture(
-      CMVideoFormatDescriptionRef videoDesc,
-      Boolean originIsAtTopLeft);
-  static CGSize CMVideoFormatDescriptionGetPresentationDimensions(
-      CMVideoFormatDescriptionRef videoDesc,
-      Boolean usePixelAspectRatio,
-      Boolean useCleanAperture);
-
   // Originally from CMSampleBuffer.h.
   typedef struct OpaqueCMSampleBuffer* CMSampleBufferRef;
 
   // Originally from CMTime.h.
   static CMTime CMTimeMake(int64_t value, int32_t timescale);
-  static Float64 CMTimeGetSeconds(CMTime time);
-
-  // Originally from CMTimeRange.h
-  static CMTimeRange CMTimeRangeMake(CMTime start, CMTime duration);
 
   // Originally from CMBlockBuffer.h
-  static OSStatus CMBlockBufferCopyDataBytes(CMBlockBufferRef theSourceBuffer,
-                                             size_t offsetToData,
-                                             size_t dataLength,
-                                             void* destination);
   static OSStatus CMBlockBufferCreateContiguous(
       CFAllocatorRef structureAllocator,
       CMBlockBufferRef sourceBuffer,
@@ -124,7 +89,6 @@ class MEDIA_EXPORT CoreMediaGlue {
 
   // Originally from CMSampleBuffer.h.
   static CMBlockBufferRef CMSampleBufferGetDataBuffer(CMSampleBufferRef sbuf);
-  static CMTime CMSampleBufferGetDuration(CMSampleBufferRef sbuf);
   static CMFormatDescriptionRef CMSampleBufferGetFormatDescription(
       CMSampleBufferRef sbuf);
   static CVImageBufferRef CMSampleBufferGetImageBuffer(
@@ -153,6 +117,4 @@ class MEDIA_EXPORT CoreMediaGlue {
   DISALLOW_IMPLICIT_CONSTRUCTORS(CoreMediaGlue);
 };
 
-#pragma pack(pop)
-
 #endif  // MEDIA_BASE_MAC_COREMEDIA_GLUE_H_
diff --git a/media/base/mac/coremedia_glue.mm b/media/base/mac/coremedia_glue.mm
index c6787d5..23cfa09 100644
--- a/media/base/mac/coremedia_glue.mm
+++ b/media/base/mac/coremedia_glue.mm
@@ -19,10 +19,6 @@ namespace {
 class CoreMediaLibraryInternal {
  public:
   typedef CoreMediaGlue::CMTime (*CMTimeMakeMethod)(int64_t, int32_t);
-  typedef Float64 (*CMTimeGetSecondsMethod)(CoreMediaGlue::CMTime);
-
-  typedef CoreMediaGlue::CMTimeRange (
-      *CMTimeRangeMakeMethod)(CoreMediaGlue::CMTime, CoreMediaGlue::CMTime);
 
   typedef OSStatus (*CMBlockBufferCreateContiguousMethod)(
       CFAllocatorRef,
@@ -46,22 +42,13 @@ class CoreMediaLibraryInternal {
       size_t,
       size_t);
 
-  typedef OSStatus (*CMBlockBufferCopyDataBytesMethod)(
-      CoreMediaGlue::CMBlockBufferRef theSourceBuffer,
-      size_t offsetToData,
-      size_t dataLength,
-      void* destination);
   typedef CoreMediaGlue::CMBlockBufferRef (*CMSampleBufferGetDataBufferMethod)(
       CoreMediaGlue::CMSampleBufferRef);
-  typedef CoreMediaGlue::CMTime (*CMSampleBufferGetDurationMethod)(
-      CoreMediaGlue::CMSampleBufferRef);
   typedef CoreMediaGlue::CMFormatDescriptionRef (
       *CMSampleBufferGetFormatDescriptionMethod)(
       CoreMediaGlue::CMSampleBufferRef);
   typedef CVImageBufferRef (*CMSampleBufferGetImageBufferMethod)(
       CoreMediaGlue::CMSampleBufferRef);
-  typedef CoreMediaGlue::CMTime (*CMSampleBufferGetPresentationTimestampMethod)(
-      CoreMediaGlue::CMSampleBufferRef);
   typedef CFArrayRef (*CMSampleBufferGetSampleAttachmentsArrayMethod)(
       CoreMediaGlue::CMSampleBufferRef,
       Boolean);
@@ -73,16 +60,6 @@ class CoreMediaLibraryInternal {
   typedef CoreMediaGlue::CMVideoDimensions
       (*CMVideoFormatDescriptionGetDimensionsMethod)(
           CoreMediaGlue::CMVideoFormatDescriptionRef videoDesc);
-  typedef const AudioFormatListItem* (
-      *CMAudioFormatDescriptionGetRichestDecodableFormatMethod)(
-      CoreMediaGlue::CMAudioFormatDescriptionRef desc);
-  typedef CGRect (*CMVideoFormatDescriptionGetCleanApertureMethod)(
-      CoreMediaGlue::CMVideoFormatDescriptionRef videoDesc,
-      Boolean originIsAtTopLeft);
-  typedef CGSize (*CMVideoFormatDescriptionGetPresentationDimensionsMethod)(
-      CoreMediaGlue::CMVideoFormatDescriptionRef videoDesc,
-      Boolean usePixelAspectRatio,
-      Boolean useCleanAperture);
   typedef OSStatus (*CMVideoFormatDescriptionGetH264ParameterSetAtIndexMethod)(
       CoreMediaGlue::CMFormatDescriptionRef,
       size_t,
@@ -105,18 +82,6 @@ class CoreMediaLibraryInternal {
         dlsym(library_handle, "CMTimeMake"));
     CHECK(cm_time_make_) << dlerror();
 
-    cm_time_get_seconds_ = reinterpret_cast<CMTimeGetSecondsMethod>(
-        dlsym(library_handle, "CMTimeGetSeconds"));
-    CHECK(cm_time_get_seconds_) << dlerror();
-
-    cm_time_range_make_ = reinterpret_cast<CMTimeRangeMakeMethod>(
-        dlsym(library_handle, "CMTimeRangeMake"));
-    CHECK(cm_time_range_make_) << dlerror();
-
-    cm_block_buffer_copy_data_bytes_method_ =
-        reinterpret_cast<CMBlockBufferCopyDataBytesMethod>(
-            dlsym(library_handle, "CMBlockBufferCopyDataBytes"));
-    CHECK(cm_block_buffer_copy_data_bytes_method_) << dlerror();
     cm_block_buffer_create_contiguous_method_ =
         reinterpret_cast<CMBlockBufferCreateContiguousMethod>(
             dlsym(library_handle, "CMBlockBufferCreateContiguous"));
@@ -138,10 +103,6 @@ class CoreMediaLibraryInternal {
         reinterpret_cast<CMSampleBufferGetDataBufferMethod>(
             dlsym(library_handle, "CMSampleBufferGetDataBuffer"));
     CHECK(cm_sample_buffer_get_data_buffer_method_) << dlerror();
-    cm_sample_buffer_get_duration_method_ =
-        reinterpret_cast<CMSampleBufferGetDurationMethod>(
-            dlsym(library_handle, "CMSampleBufferGetDuration"));
-    CHECK(cm_sample_buffer_get_duration_method_) << dlerror();
     cm_sample_buffer_get_format_description_method_ =
         reinterpret_cast<CMSampleBufferGetFormatDescriptionMethod>(
             dlsym(library_handle, "CMSampleBufferGetFormatDescription"));
@@ -150,10 +111,6 @@ class CoreMediaLibraryInternal {
         reinterpret_cast<CMSampleBufferGetImageBufferMethod>(
             dlsym(library_handle, "CMSampleBufferGetImageBuffer"));
     CHECK(cm_sample_buffer_get_image_buffer_method_) << dlerror();
-    cm_sample_buffer_get_presentation_timestamp_method_ =
-        reinterpret_cast<CMSampleBufferGetPresentationTimestampMethod>(
-            dlsym(library_handle, "CMSampleBufferGetPresentationTimeStamp"));
-    CHECK(cm_sample_buffer_get_presentation_timestamp_method_) << dlerror();
     cm_sample_buffer_get_sample_attachments_array_method_ =
         reinterpret_cast<CMSampleBufferGetSampleAttachmentsArrayMethod>(
             dlsym(library_handle, "CMSampleBufferGetSampleAttachmentsArray"));
@@ -175,27 +132,6 @@ class CoreMediaLibraryInternal {
             dlsym(library_handle, "CMVideoFormatDescriptionGetDimensions"));
     CHECK(cm_video_format_description_get_dimensions_method_) << dlerror();
 
-    cm_audio_format_description_get_richest_decodable_format_method_ =
-        reinterpret_cast<
-            CMAudioFormatDescriptionGetRichestDecodableFormatMethod>(
-            dlsym(library_handle,
-                  "CMAudioFormatDescriptionGetRichestDecodableFormat"));
-    CHECK(cm_audio_format_description_get_richest_decodable_format_method_)
-        << dlerror();
-
-    cm_video_format_description_get_clean_aperture_method_ =
-        reinterpret_cast<CMVideoFormatDescriptionGetCleanApertureMethod>(
-            dlsym(library_handle, "CMVideoFormatDescriptionGetCleanAperture"));
-    CHECK(cm_video_format_description_get_clean_aperture_method_) << dlerror();
-
-    cm_video_format_description_get_presentation_dimensions_method_ =
-        reinterpret_cast<
-            CMVideoFormatDescriptionGetPresentationDimensionsMethod>(
-            dlsym(library_handle,
-                  "CMVideoFormatDescriptionGetPresentationDimensions"));
-    CHECK(cm_video_format_description_get_presentation_dimensions_method_)
-        << dlerror();
-
     // Available starting (OS X 10.9, iOS 7), allow to be null.
     cm_video_format_description_get_h264_parameter_set_at_index_method_ =
         reinterpret_cast<
@@ -205,18 +141,7 @@ class CoreMediaLibraryInternal {
   }
 
   const CMTimeMakeMethod& cm_time_make() const { return cm_time_make_; }
-  const CMTimeGetSecondsMethod& cm_time_get_seconds() const {
-    return cm_time_get_seconds_;
-  }
-
-  const CMTimeRangeMakeMethod& cm_time_range_make() const {
-    return cm_time_range_make_;
-  }
 
-  const CMBlockBufferCopyDataBytesMethod&
-  cm_block_buffer_copy_data_bytes_method() const {
-    return cm_block_buffer_copy_data_bytes_method_;
-  }
   const CMBlockBufferCreateContiguousMethod&
   cm_block_buffer_create_contiguous_method() const {
     return cm_block_buffer_create_contiguous_method_;
@@ -238,10 +163,6 @@ class CoreMediaLibraryInternal {
   cm_sample_buffer_get_data_buffer_method() const {
     return cm_sample_buffer_get_data_buffer_method_;
   }
-  const CMSampleBufferGetDurationMethod& cm_sample_buffer_get_duration_method()
-      const {
-    return cm_sample_buffer_get_duration_method_;
-  }
   const CMSampleBufferGetFormatDescriptionMethod&
   cm_sample_buffer_get_format_description_method() const {
     return cm_sample_buffer_get_format_description_method_;
@@ -270,18 +191,6 @@ class CoreMediaLibraryInternal {
       cm_video_format_description_get_dimensions_method() const {
     return cm_video_format_description_get_dimensions_method_;
   }
-  const CMAudioFormatDescriptionGetRichestDecodableFormatMethod&
-  cm_audio_format_description_get_richest_decodable_format_method() const {
-    return cm_audio_format_description_get_richest_decodable_format_method_;
-  }
-  const CMVideoFormatDescriptionGetCleanApertureMethod&
-      cm_video_format_description_get_clean_aperture_method() const {
-    return cm_video_format_description_get_clean_aperture_method_;
-  }
-  const CMVideoFormatDescriptionGetPresentationDimensionsMethod&
-      cm_video_format_description_get_presentation_dimensions_method() const {
-    return cm_video_format_description_get_presentation_dimensions_method_;
-  }
   const CMVideoFormatDescriptionGetH264ParameterSetAtIndexMethod&
   cm_video_format_description_get_h264_parameter_set_at_index_method() const {
     return cm_video_format_description_get_h264_parameter_set_at_index_method_;
@@ -289,11 +198,7 @@ class CoreMediaLibraryInternal {
 
  private:
   CMTimeMakeMethod cm_time_make_;
-  CMTimeGetSecondsMethod cm_time_get_seconds_;
 
-  CMTimeRangeMakeMethod cm_time_range_make_;
-
-  CMBlockBufferCopyDataBytesMethod cm_block_buffer_copy_data_bytes_method_;
   CMBlockBufferCreateContiguousMethod cm_block_buffer_create_contiguous_method_;
   CMBlockBufferGetDataLengthMethod cm_block_buffer_get_data_length_method_;
   CMBlockBufferGetDataPointerMethod cm_block_buffer_get_data_pointer_method_;
@@ -301,7 +206,6 @@ class CoreMediaLibraryInternal {
       cm_block_buffer_is_range_contiguous_method_;
 
   CMSampleBufferGetDataBufferMethod cm_sample_buffer_get_data_buffer_method_;
-  CMSampleBufferGetDurationMethod cm_sample_buffer_get_duration_method_;
   CMSampleBufferGetFormatDescriptionMethod
       cm_sample_buffer_get_format_description_method_;
   CMSampleBufferGetImageBufferMethod cm_sample_buffer_get_image_buffer_method_;
@@ -313,12 +217,6 @@ class CoreMediaLibraryInternal {
       cm_format_description_get_media_sub_type_method_;
   CMVideoFormatDescriptionGetDimensionsMethod
       cm_video_format_description_get_dimensions_method_;
-  CMAudioFormatDescriptionGetRichestDecodableFormatMethod
-      cm_audio_format_description_get_richest_decodable_format_method_;
-  CMVideoFormatDescriptionGetCleanApertureMethod
-      cm_video_format_description_get_clean_aperture_method_;
-  CMVideoFormatDescriptionGetPresentationDimensionsMethod
-      cm_video_format_description_get_presentation_dimensions_method_;
   CMVideoFormatDescriptionGetH264ParameterSetAtIndexMethod
       cm_video_format_description_get_h264_parameter_set_at_index_method_;
   CMSampleBufferGetPresentationTimeStampMethod
@@ -327,37 +225,18 @@ class CoreMediaLibraryInternal {
   DISALLOW_COPY_AND_ASSIGN(CoreMediaLibraryInternal);
 };
 
-const CoreMediaGlue::CMTimeFlags kCMTimeFlags_Valid = 1UL << 0;
-const CoreMediaGlue::CMTimeFlags kCMTimeFlags_PositiveInfinity = 1UL << 2;
-
 }  // namespace
 
 static base::LazyInstance<CoreMediaLibraryInternal> g_coremedia_handle =
     LAZY_INSTANCE_INITIALIZER;
 
 // static
-const CoreMediaGlue::CMTime CoreMediaGlue::kCMTimeZero = {0,
-                                                          1,
-                                                          kCMTimeFlags_Valid,
-                                                          0};
-
-// static
-const CoreMediaGlue::CMTime CoreMediaGlue::kCMTimePositiveInfinity =
-    {0, 0, kCMTimeFlags_Valid | kCMTimeFlags_PositiveInfinity, 0};
-
-// static
 CoreMediaGlue::CMTime CoreMediaGlue::CMTimeMake(int64_t value,
                                                 int32_t timescale) {
   return g_coremedia_handle.Get().cm_time_make()(value, timescale);
 }
 
 // static
-CoreMediaGlue::CMTimeRange CoreMediaGlue::CMTimeRangeMake(CMTime start,
-                                                          CMTime duration) {
-  return g_coremedia_handle.Get().cm_time_range_make()(start, duration);
-}
-
-// static
 OSStatus CoreMediaGlue::CMBlockBufferCreateContiguous(
     CFAllocatorRef structureAllocator,
     CMBlockBufferRef sourceBuffer,
@@ -404,16 +283,6 @@ Boolean CoreMediaGlue::CMBlockBufferIsRangeContiguous(
 }
 
 // static
-OSStatus CoreMediaGlue::CMBlockBufferCopyDataBytes(
-    CMBlockBufferRef theSourceBuffer,
-    size_t offsetToData,
-    size_t dataLength,
-    void* destination) {
-  return g_coremedia_handle.Get().cm_block_buffer_copy_data_bytes_method()(
-      theSourceBuffer, offsetToData, dataLength, destination);
-}
-
-// static
 CoreMediaGlue::CMBlockBufferRef CoreMediaGlue::CMSampleBufferGetDataBuffer(
     CMSampleBufferRef sbuf) {
   return g_coremedia_handle.Get().cm_sample_buffer_get_data_buffer_method()(
@@ -421,12 +290,6 @@ CoreMediaGlue::CMBlockBufferRef CoreMediaGlue::CMSampleBufferGetDataBuffer(
 }
 
 // static
-CoreMediaGlue::CMTime CoreMediaGlue::CMSampleBufferGetDuration(
-    CMSampleBufferRef sbuf) {
-  return g_coremedia_handle.Get().cm_sample_buffer_get_duration_method()(sbuf);
-}
-
-// static
 CoreMediaGlue::CMFormatDescriptionRef
 CoreMediaGlue::CMSampleBufferGetFormatDescription(
     CoreMediaGlue::CMSampleBufferRef sbuf) {
@@ -435,11 +298,6 @@ CoreMediaGlue::CMSampleBufferGetFormatDescription(
 }
 
 // static
-Float64 CoreMediaGlue::CMTimeGetSeconds(CoreMediaGlue::CMTime time) {
-  return g_coremedia_handle.Get().cm_time_get_seconds()(time);
-}
-
-// static
 CVImageBufferRef CoreMediaGlue::CMSampleBufferGetImageBuffer(
     CMSampleBufferRef buffer) {
   return g_coremedia_handle.Get().cm_sample_buffer_get_image_buffer_method()(
@@ -483,33 +341,6 @@ CoreMediaGlue::CMVideoDimensions
 }
 
 // static
-const AudioFormatListItem*
-CoreMediaGlue::CMAudioFormatDescriptionGetRichestDecodableFormat(
-    CMAudioFormatDescriptionRef desc) {
-  return g_coremedia_handle.Get()
-      .cm_audio_format_description_get_richest_decodable_format_method()(desc);
-}
-
-// static
-CGRect CoreMediaGlue::CMVideoFormatDescriptionGetCleanAperture(
-    CMVideoFormatDescriptionRef videoDesc,
-    Boolean originIsAtTopLeft) {
-  return g_coremedia_handle.Get()
-      .cm_video_format_description_get_clean_aperture_method()(
-          videoDesc, originIsAtTopLeft);
-}
-
-// static
-CGSize CoreMediaGlue::CMVideoFormatDescriptionGetPresentationDimensions(
-    CMVideoFormatDescriptionRef videoDesc,
-    Boolean usePixelAspectRatio,
-    Boolean useCleanAperture) {
-  return g_coremedia_handle.Get()
-      .cm_video_format_description_get_presentation_dimensions_method()(
-          videoDesc, usePixelAspectRatio, useCleanAperture);
-}
-
-// static
 OSStatus CoreMediaGlue::CMVideoFormatDescriptionGetH264ParameterSetAtIndex(
     CMFormatDescriptionRef videoDesc,
     size_t parameterSetIndex,
diff --git a/media/base/mac/framework_type_conversions.h b/media/base/mac/framework_type_conversions.h
deleted file mode 100644
index 2897900..0000000
--- a/media/base/mac/framework_type_conversions.h
+++ /dev/null
@@ -1,60 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_BASE_MAC_FRAMEWORK_TYPE_CONVERSIONS_H_
-#define MEDIA_BASE_MAC_FRAMEWORK_TYPE_CONVERSIONS_H_
-
-#import <CoreMedia/CoreMedia.h>
-
-#include "base/time/time.h"
-#include "media/base/channel_layout.h"
-#include "media/base/mac/coremedia_glue.h"
-#include "media/base/media_export.h"
-
-namespace media {
-
-inline const CMTime& CoreMediaGlueCMTimeToCMTime(
-    const CoreMediaGlue::CMTime& time) {
-  return reinterpret_cast<const CMTime&>(time);
-}
-
-inline const CoreMediaGlue::CMTime& CMTimeToCoreMediaGlueCMTime(
-    const CMTime& time) {
-  return reinterpret_cast<const CoreMediaGlue::CMTime&>(time);
-}
-
-inline base::TimeDelta CMTimeToTimeDelta(const CMTime& cm_time) {
-  CoreMediaGlue::CMTime time = CMTimeToCoreMediaGlueCMTime(cm_time);
-  return base::TimeDelta::FromSecondsD(CoreMediaGlue::CMTimeGetSeconds(time));
-}
-
-inline CoreMediaGlue::CMTime TimeDeltaToCoreMediaGlueCMTime(
-    const base::TimeDelta& time_delta) {
-  // To get the number of 1/600-of-a-second units in |time_delta|, divide the
-  // number of microseconds by 1000000 and multiply by 600.
-  return CoreMediaGlue::CMTimeMake(
-      static_cast<double>(time_delta.InMicroseconds()) * (600.0 / 1000000.0),
-      600);
-}
-
-inline CMTime TimeDeltaToCMTime(const base::TimeDelta& time_delta) {
-  return CoreMediaGlueCMTimeToCMTime(
-      TimeDeltaToCoreMediaGlueCMTime(time_delta));
-}
-
-inline const CMTimeRange& CoreMediaGlueCMTimeRangeToCMTimeRange(
-    const CoreMediaGlue::CMTimeRange time_range) {
-  return reinterpret_cast<const CMTimeRange&>(time_range);
-}
-
-MEDIA_EXPORT AudioChannelLayoutTag
-ChromeChannelLayoutToCoreAudioTag(ChannelLayout chrome_layout);
-
-std::string FourCCToString(uint32_t fourcc);
-
-}  // namespace media
-
-#endif  // MEDIA_BASE_MAC_FRAMEWORK_TYPE_CONVERSIONS_H_
diff --git a/media/base/mac/framework_type_conversions.mm b/media/base/mac/framework_type_conversions.mm
deleted file mode 100644
index 9dba25a..0000000
--- a/media/base/mac/framework_type_conversions.mm
+++ /dev/null
@@ -1,68 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/base/mac/framework_type_conversions.h"
-
-#include "base/logging.h"
-
-namespace media {
-
-AudioChannelLayoutTag ChromeChannelLayoutToCoreAudioTag(
-    ChannelLayout chrome_layout) {
-  // Cover usage in the MSE case by providing conversions for values from
-  // media::kADTSChannelLayoutTable.  Cover usage in the non-MSE case by
-  // providing conversions for values returned by GuessChannelLayout().
-  switch (chrome_layout) {
-    case CHANNEL_LAYOUT_MONO:
-      return kAudioChannelLayoutTag_Mono;
-
-    case CHANNEL_LAYOUT_STEREO:
-      return kAudioChannelLayoutTag_Stereo;
-
-    case CHANNEL_LAYOUT_SURROUND:
-      return kAudioChannelLayoutTag_MPEG_3_0_A;
-
-    case CHANNEL_LAYOUT_4_0:
-      return kAudioChannelLayoutTag_MPEG_4_0_A;
-
-    case CHANNEL_LAYOUT_QUAD:
-      return kAudioChannelLayoutTag_Quadraphonic;
-
-    // AudioChannelLayoutTag doesn't seem to distinguish between
-    // "Side Left/Right" and "Rear Left/Right" for 5.0 and 5.1 layouts.
-    case CHANNEL_LAYOUT_5_0:
-    case CHANNEL_LAYOUT_5_0_BACK:
-      return kAudioChannelLayoutTag_MPEG_5_0_A;
-
-    case CHANNEL_LAYOUT_5_1:
-    case CHANNEL_LAYOUT_5_1_BACK:
-      return kAudioChannelLayoutTag_MPEG_5_1_A;
-
-    case CHANNEL_LAYOUT_6_1:
-      return kAudioChannelLayoutTag_MPEG_6_1_A;
-
-    case CHANNEL_LAYOUT_7_1:
-      return kAudioChannelLayoutTag_MPEG_7_1_C;
-
-    default:
-      NOTREACHED() << "Unhandled kADTSChannelLayoutTable value, unhandled "
-                      "GuessChannelLayout()-returned value, or unexpected use "
-                      "of function";
-      return kAudioChannelLayoutTag_Unknown;
-  }
-}
-
-std::string FourCCToString(uint32_t fourcc) {
-  const char buffer[] = {
-      (fourcc >> 24) & 0xff,
-      (fourcc >> 16) & 0xff,
-      (fourcc >>  8) & 0xff,
-      (fourcc >>  0) & 0xff,
-  };
-  return std::string(buffer, arraysize(buffer));
-}
-
-}  // namespace media
diff --git a/media/base/mac/mediatoolbox_glue.h b/media/base/mac/mediatoolbox_glue.h
deleted file mode 100644
index 882f3b9..0000000
--- a/media/base/mac/mediatoolbox_glue.h
+++ /dev/null
@@ -1,98 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_BASE_MAC_MEDIATOOLBOX_GLUE_H_
-#define MEDIA_BASE_MAC_MEDIATOOLBOX_GLUE_H_
-
-#import <CoreFoundation/CoreFoundation.h>
-
-#include <stdint.h>
-
-#include "base/macros.h"
-#include "media/base/mac/coremedia_glue.h"
-#include "media/base/media_export.h"
-
-struct AudioStreamBasicDescription;
-struct AudioBufferList;
-
-// Must use the same packing as the original structures defined in the OS X SDK
-// to make sure data types are aligned the same way on different architectures.
-#pragma pack(push, 4)
-
-// MediaToolbox API is only introduced in Mac OS X 10.9, the (potential)
-// linking with it has to happen in runtime. If it succeeds, subsequent clients
-// can use MediaToolbox via the class declared in this file, where the original
-// naming has been kept as much as possible.
-class MEDIA_EXPORT MediaToolboxGlue {
- public:
-  // Originally in CMBase.h
-  typedef signed long CMItemCount;
-
-  // Orinally in MTAudioProcessingTap.h
-  typedef uint32_t MTAudioProcessingTapCreationFlags;
-  typedef uint32_t MTAudioProcessingTapFlags;
-  enum { kMTAudioProcessingTapCallbacksVersion_0 = 0 };
-  enum {
-    kMTAudioProcessingTapCreationFlag_PreEffects = 0x01,
-    kMTAudioProcessingTapCreationFlag_PostEffects = 0x02
-  };
-  enum {
-    kMTAudioProcessingTapFlag_StartOfStream = 0x100,
-    kMTAudioProcessingTapFlag_EndOfStream = 0x200
-  };
-  typedef const struct opaqueMTAudioProcessingTap* MTAudioProcessingTapRef;
-  typedef void (*MTAudioProcessingTapInitCallback)(MTAudioProcessingTapRef tap,
-                                                   void* clientInfo,
-                                                   void** tapStorageOut);
-  typedef void (*MTAudioProcessingTapFinalizeCallback)(
-      MTAudioProcessingTapRef tap);
-  typedef void (*MTAudioProcessingTapPrepareCallback)(
-      MTAudioProcessingTapRef tap,
-      CMItemCount maxFrames,
-      const AudioStreamBasicDescription* processingFormat);
-  typedef void (*MTAudioProcessingTapUnprepareCallback)(
-      MTAudioProcessingTapRef tap);
-  typedef void (*MTAudioProcessingTapProcessCallback)(
-      MTAudioProcessingTapRef tap,
-      CMItemCount numberFrames,
-      MTAudioProcessingTapFlags flags,
-      AudioBufferList* bufferListInOut,
-      CMItemCount* numberFramesOut,
-      MTAudioProcessingTapFlags* flagsOut);
-
-  typedef struct {
-    int version;
-    void* clientInfo;
-    MTAudioProcessingTapInitCallback init;
-    MTAudioProcessingTapFinalizeCallback finalize;
-    MTAudioProcessingTapPrepareCallback prepare;
-    MTAudioProcessingTapUnprepareCallback unprepare;
-    MTAudioProcessingTapProcessCallback process;
-  } MTAudioProcessingTapCallbacks;
-
-  static OSStatus MTAudioProcessingTapCreate(
-      CFAllocatorRef allocator,
-      const MediaToolboxGlue::MTAudioProcessingTapCallbacks* callbacks,
-      MediaToolboxGlue::MTAudioProcessingTapCreationFlags flags,
-      MediaToolboxGlue::MTAudioProcessingTapRef* tapOut);
-
-  static OSStatus MTAudioProcessingTapGetSourceAudio(
-      MTAudioProcessingTapRef tap,
-      CMItemCount numberFrames,
-      AudioBufferList* bufferListInOut,
-      MTAudioProcessingTapFlags* flagsOut,
-      CoreMediaGlue::CMTimeRange* timeRangeOut,
-      CMItemCount* numberFramesOut);
-
-  static void* MTAudioProcessingTapGetStorage(
-      MediaToolboxGlue::MTAudioProcessingTapRef tap);
- private:
-  DISALLOW_IMPLICIT_CONSTRUCTORS(MediaToolboxGlue);
-};
-
-#pragma pack(pop)
-
-#endif  // MEDIA_BASE_MAC_MEDIATOOLBOX_GLUE_H_
diff --git a/media/base/mac/mediatoolbox_glue.mm b/media/base/mac/mediatoolbox_glue.mm
deleted file mode 100644
index 20f720d..0000000
--- a/media/base/mac/mediatoolbox_glue.mm
+++ /dev/null
@@ -1,128 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/base/mac/mediatoolbox_glue.h"
-
-#import <Foundation/Foundation.h>
-
-#include <dlfcn.h>
-
-#include "base/logging.h"
-#include "base/lazy_instance.h"
-
-namespace {
-
-// This class is used to retrieve some MediaToolbox library functions. It must
-// be used as a LazyInstance so that it is initialised once and in a thread-safe
-// way. Normally no work is done in constructors: LazyInstance is an exception.
-class MediaToolboxLibraryInternal {
- public:
-  typedef OSStatus (*MTAudioProcessingTapCreateMethod)
-      (CFAllocatorRef allocator,
-      const MediaToolboxGlue::MTAudioProcessingTapCallbacks* callbacks,
-      MediaToolboxGlue::MTAudioProcessingTapCreationFlags flags,
-      MediaToolboxGlue::MTAudioProcessingTapRef* tapOut);
-
-  typedef OSStatus (*MTAudioProcessingTapGetSourceAudioMethod)(
-      MediaToolboxGlue::MTAudioProcessingTapRef tap,
-      MediaToolboxGlue::CMItemCount numberFrames,
-      AudioBufferList* bufferListInOut,
-      MediaToolboxGlue::MTAudioProcessingTapFlags* flagsOut,
-      CoreMediaGlue::CMTimeRange* timeRangeOut,
-      MediaToolboxGlue::CMItemCount* numberFramesOut);
-
-  typedef void* (*MTAudioProcessingTapGetStorageMethod)(
-      MediaToolboxGlue::MTAudioProcessingTapRef tap);
-
-  MediaToolboxLibraryInternal() {
-    NSBundle* bundle = [NSBundle
-        bundleWithPath:@"/System/Library/Frameworks/MediaToolbox.framework"];
-
-    const char* path = [[bundle executablePath] fileSystemRepresentation];
-    CHECK(path);
-    void* library_handle = dlopen(path, RTLD_LAZY | RTLD_LOCAL);
-    CHECK(library_handle) << dlerror();
-
-    // Now extract the methods.
-    mt_audio_processing_tap_create_method_ =
-        reinterpret_cast<MTAudioProcessingTapCreateMethod>(
-            dlsym(library_handle, "MTAudioProcessingTapCreate"));
-    CHECK(mt_audio_processing_tap_create_method_) << dlerror();
-
-    mt_audio_processing_tap_get_source_audio_method_ =
-        reinterpret_cast<MTAudioProcessingTapGetSourceAudioMethod>(
-            dlsym(library_handle, "MTAudioProcessingTapGetSourceAudio"));
-    CHECK(mt_audio_processing_tap_get_source_audio_method_) << dlerror();
-
-    mt_audio_processing_tap_get_storage_method_ =
-        reinterpret_cast<MTAudioProcessingTapGetStorageMethod>(
-            dlsym(library_handle, "MTAudioProcessingTapGetStorage"));
-    CHECK(mt_audio_processing_tap_get_storage_method_) << dlerror();
-  }
-
-  const MTAudioProcessingTapCreateMethod&
-      mt_audio_processing_tap_create_method() const {
-    return mt_audio_processing_tap_create_method_;
-  }
-
-  const MTAudioProcessingTapGetSourceAudioMethod&
-      mt_audio_processing_tap_get_source_audio_method() const {
-    return mt_audio_processing_tap_get_source_audio_method_;
-  }
-
-  const MTAudioProcessingTapGetStorageMethod&
-      mt_audio_processing_tap_get_storage_method() const {
-    return mt_audio_processing_tap_get_storage_method_;
-  }
-
- private:
-  MTAudioProcessingTapCreateMethod mt_audio_processing_tap_create_method_;
-  MTAudioProcessingTapGetSourceAudioMethod
-      mt_audio_processing_tap_get_source_audio_method_;
-  MTAudioProcessingTapGetStorageMethod
-      mt_audio_processing_tap_get_storage_method_;
-
-  DISALLOW_COPY_AND_ASSIGN(MediaToolboxLibraryInternal);
-};
-
-}  // namespace
-
-static base::LazyInstance<MediaToolboxLibraryInternal> g_mediatoolbox_handle =
-    LAZY_INSTANCE_INITIALIZER;
-
-// static
-OSStatus MediaToolboxGlue::MTAudioProcessingTapCreate(
-    CFAllocatorRef allocator,
-    const MTAudioProcessingTapCallbacks* callbacks,
-    MTAudioProcessingTapCreationFlags flags,
-    MTAudioProcessingTapRef* tapOut) {
-  return g_mediatoolbox_handle.Get().mt_audio_processing_tap_create_method()
-      (allocator, callbacks, flags, tapOut);
-}
-
-// static
-OSStatus MediaToolboxGlue::MTAudioProcessingTapGetSourceAudio(
-    MTAudioProcessingTapRef tap,
-    CMItemCount numberFrames,
-    AudioBufferList* bufferListInOut,
-    MTAudioProcessingTapFlags* flagsOut,
-    CoreMediaGlue::CMTimeRange* timeRangeOut,
-    CMItemCount* numberFramesOut) {
-  return g_mediatoolbox_handle.Get()
-      .mt_audio_processing_tap_get_source_audio_method()(tap,
-                                                         numberFrames,
-                                                         bufferListInOut,
-                                                         flagsOut,
-                                                         timeRangeOut,
-                                                         numberFramesOut);
-}
-
-//static
-void* MediaToolboxGlue::MTAudioProcessingTapGetStorage(
-    MTAudioProcessingTapRef tap) {
-  return g_mediatoolbox_handle.Get()
-      .mt_audio_processing_tap_get_storage_method()(tap);
-}
diff --git a/media/base/mac/scoped_audio_queue_ref.h b/media/base/mac/scoped_audio_queue_ref.h
deleted file mode 100644
index f70ce57..0000000
--- a/media/base/mac/scoped_audio_queue_ref.h
+++ /dev/null
@@ -1,30 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_BASE_MAC_SCOPED_AUDIO_QUEUE_REF_H_
-#define MEDIA_BASE_MAC_SCOPED_AUDIO_QUEUE_REF_H_
-
-#include <AudioToolbox/AudioQueue.h>
-
-#include "base/mac/scoped_typeref.h"
-
-namespace media {
-
-struct ScopedAudioQueueRefTraits {
-  static AudioQueueRef Retain(AudioQueueRef queue) {
-    NOTREACHED() << "Only compatible with ASSUME policy";
-    return queue;
-  }
-  static void Release(AudioQueueRef queue) { AudioQueueDispose(queue, true); }
-  static AudioQueueRef InvalidValue() { return nullptr; }
-};
-
-using ScopedAudioQueueRef =
-    base::ScopedTypeRef<AudioQueueRef, ScopedAudioQueueRefTraits>;
-
-}  // namespace media
-
-#endif  // MEDIA_BASE_MAC_SCOPED_AUDIO_QUEUE_REF_H_
diff --git a/media/base/media_file_checker_unittest.cc b/media/base/media_file_checker_unittest.cc
index 7569f71..63aad60 100644
--- a/media/base/media_file_checker_unittest.cc
+++ b/media/base/media_file_checker_unittest.cc
@@ -12,12 +12,6 @@
 #include "media/base/test_data_util.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-// This test assumes proprietary media support built into FFmpeg, which is not
-// the case when USE_SYSTEM_PROPRIETARY_CODECS is defined.
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#undef USE_PROPRIETARY_CODECS
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 namespace media {
 
 static void RunMediaFileChecker(const std::string& filename, bool expectation) {
diff --git a/media/base/mime_util.cc b/media/base/mime_util.cc
index c36cc5e..6eba4fc 100644
--- a/media/base/mime_util.cc
+++ b/media/base/mime_util.cc
@@ -7,10 +7,6 @@
 #include "base/lazy_instance.h"
 #include "media/base/mime_util_internal.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/base/platform_mime_util.h"
-#endif
-
 namespace media {
 
 // This variable is Leaky because it is accessed from WorkerPool threads.
@@ -34,16 +30,6 @@ SupportsType IsSupportedEncryptedMediaFormat(
                                                              true);
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-bool IsPartiallySupportedMediaMimeType(const std::string& mime_type) {
-#if defined(OS_MACOSX)
-  return mime_type == "video/quicktime";
-#else
-  return false;
-#endif
-}
-#endif
-
 void ParseCodecString(const std::string& codecs,
                       std::vector<std::string>* codecs_out,
                       bool strip) {
diff --git a/media/base/mime_util.h b/media/base/mime_util.h
index c65dae5..6a49eba 100644
--- a/media/base/mime_util.h
+++ b/media/base/mime_util.h
@@ -16,13 +16,6 @@ namespace media {
 // supported/recognized MIME types.
 MEDIA_EXPORT bool IsSupportedMediaMimeType(const std::string& mime_type);
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-// Check to see if a particular MIME type is in the list of partially
-// supported/recognized MIME types.
-MEDIA_EXPORT bool IsPartiallySupportedMediaMimeType(
-    const std::string& mime_type);
-#endif
-
 // Parses a codec string, populating |codecs_out| with the prefix of each codec
 // in the string |codecs_in|. For example, passed "aaa.b.c,dd.eee", if
 // |strip| == true |codecs_out| will contain {"aaa", "dd"}, if |strip| == false
diff --git a/media/base/mime_util_internal.cc b/media/base/mime_util_internal.cc
index 5641263..7a26254 100644
--- a/media/base/mime_util_internal.cc
+++ b/media/base/mime_util_internal.cc
@@ -233,11 +233,7 @@ SupportsType MimeUtil::AreSupportedCodecs(
 }
 
 void MimeUtil::InitializeMimeTypeMaps() {
-
-// Initialize the supported media types.
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  allow_proprietary_codecs_ = true;
-#elif defined(USE_PROPRIETARY_CODECS)
+#if defined(USE_PROPRIETARY_CODECS)
   allow_proprietary_codecs_ = true;
 #endif
 
diff --git a/media/base/mime_util_unittest.cc b/media/base/mime_util_unittest.cc
index fe554ab..4db5aa7 100644
--- a/media/base/mime_util_unittest.cc
+++ b/media/base/mime_util_unittest.cc
@@ -17,14 +17,6 @@
 #include "base/android/build_info.h"
 #endif
 
-#if defined(OS_MACOSX)
-#include "base/mac/mac_util.h"
-#endif
-
-#if defined(OS_WIN)
-#include "base/win/windows_version.h"
-#endif
-
 namespace media {
 namespace internal {
 
@@ -153,7 +145,6 @@ TEST(MimeUtilTest, CommonMediaMimeType) {
   EXPECT_EQ(kHlsSupported, IsSupportedMediaMimeType(
       "application/vnd.apple.mpegurl"));
 
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 #if defined(USE_PROPRIETARY_CODECS)
   EXPECT_TRUE(IsSupportedMediaMimeType("audio/mp4"));
   EXPECT_TRUE(IsSupportedMediaMimeType("audio/x-m4a"));
@@ -180,8 +171,7 @@ TEST(MimeUtilTest, CommonMediaMimeType) {
   EXPECT_FALSE(IsSupportedMediaMimeType("audio/x-mp3"));
   EXPECT_FALSE(IsSupportedMediaMimeType("audio/mpeg"));
   EXPECT_FALSE(IsSupportedMediaMimeType("audio/aac"));
-#endif  // !defined(OS_LINUX) && defined(USE_PROPRIETARY_CODECS)
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
+#endif  // USE_PROPRIETARY_CODECS
   EXPECT_FALSE(IsSupportedMediaMimeType("video/mp3"));
 
   EXPECT_FALSE(IsSupportedMediaMimeType("video/unknown"));
@@ -189,38 +179,6 @@ TEST(MimeUtilTest, CommonMediaMimeType) {
   EXPECT_FALSE(IsSupportedMediaMimeType("unknown/unknown"));
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-TEST(MimeUtilTest, CommonMediaMimeTypeSystemCodecs) {
-  bool proprietary_audio_supported = false;
-  bool proprietary_video_supported = false;
-#if defined(OS_MACOSX)
-  proprietary_audio_supported = true;
-  proprietary_video_supported = base::mac::IsOSMavericksOrLater();
-#elif defined(OS_WIN)
-  proprietary_audio_supported =
-      base::win::GetVersion() >= base::win::VERSION_WIN7;
-  proprietary_video_supported = proprietary_audio_supported;
-#endif
-
-#define EXPECT_AUDIO_SUPPORT(mime_type)             \
-  EXPECT_TRUE(IsSupportedMediaMimeType(mime_type) ^ \
-              !proprietary_audio_supported)
-#define EXPECT_VIDEO_SUPPORT(mime_type)             \
-  EXPECT_TRUE(IsSupportedMediaMimeType(mime_type) ^ \
-              !proprietary_video_supported)
-
-  EXPECT_AUDIO_SUPPORT("audio/mp4");
-  EXPECT_AUDIO_SUPPORT("audio/x-m4a");
-  EXPECT_VIDEO_SUPPORT("video/mp4");
-  EXPECT_VIDEO_SUPPORT("video/x-m4v");
-
-  EXPECT_AUDIO_SUPPORT("audio/mp3");
-  EXPECT_AUDIO_SUPPORT("audio/x-mp3");
-  EXPECT_AUDIO_SUPPORT("audio/mpeg");
-  EXPECT_AUDIO_SUPPORT("audio/aac");
-}
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 // Note: codecs should only be a list of 2 or fewer; hence the restriction of
 // results' length to 2.
 TEST(MimeUtilTest, ParseCodecString) {
diff --git a/media/base/pipeline_stats.cc b/media/base/pipeline_stats.cc
deleted file mode 100644
index aab6b5e..0000000
--- a/media/base/pipeline_stats.cc
+++ /dev/null
@@ -1,255 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/base/pipeline_stats.h"
-
-#include <map>
-#include <set>
-#include <vector>
-
-#include "base/lazy_instance.h"
-#include "base/metrics/histogram_macros.h"
-#include "media/base/demuxer_stream.h"
-#include "media/filters/platform_media_pipeline_types.h"
-
-namespace media {
-namespace pipeline_stats {
-
-namespace {
-
-const char kStatusListPath[] = "platform_pipeline_status_list";
-
-// Used in UMA histograms.  Don't remove or reorder values!
-enum PipelineStatus {
-  PIPELINE_INITIALIZED = 0,
-  PIPELINE_INITIALIZED_HW = 1,
-  PIPELINE_NOT_AVAILABLE = 2,
-  PIPELINE_NO_GPU_PROCESS = 3,
-  PIPELINE_INITIALIZE_ERROR = 4,
-  PIPELINE_INITIALIZE_ERROR_HW = 5,
-  PIPELINE_AUDIO_DECODE_ERROR = 6,
-  PIPELINE_VIDEO_DECODE_ERROR = 7,
-  PIPELINE_VIDEO_DECODE_ERROR_HW = 8,
-
-  DECODER_AUDIO_INITIALIZED = 9,
-  DECODER_AUDIO_INITIALIZE_ERROR = 10,
-  DECODER_AUDIO_DECODE_ERROR = 11,
-  DECODER_VIDEO_INITIALIZED = 12,
-  DECODER_VIDEO_INITIALIZE_ERROR = 13,
-  DECODER_VIDEO_DECODE_ERROR = 14,
-  DECODER_NO_GPU_PROCESS = 15,
-
-  PIPELINE_STATUS_COUNT
-};
-
-class StatusQueue {
- public:
-  static void Serialize(const StatusQueue& queue,
-                        base::DictionaryValue* dictionary);
-  static std::vector<PipelineStatus> Deserialize(
-      const base::DictionaryValue& dictionary);
-
-  void Push(PipelineStatus status) { queue_.push_back(status); }
-  void Clear() { queue_.clear(); }
-
- private:
-  std::vector<PipelineStatus> queue_;
-};
-
-// static
-void StatusQueue::Serialize(const StatusQueue& queue,
-                            base::DictionaryValue* dictionary) {
-  if (queue.queue_.empty())
-    return;
-
-  auto list = make_scoped_ptr(new base::ListValue);
-  for (const auto value : queue.queue_)
-    list->AppendInteger(value);
-
-  dictionary->SetWithoutPathExpansion(kStatusListPath, std::move(list));
-}
-
-// static
-std::vector<PipelineStatus> StatusQueue::Deserialize(
-    const base::DictionaryValue& dictionary) {
-  std::vector<PipelineStatus> result;
-
-  const base::ListValue* list;
-  if (!dictionary.GetListWithoutPathExpansion(kStatusListPath, &list))
-    return result;
-
-  for (const auto value : *list) {
-    int int_value;
-    if (value->GetAsInteger(&int_value) && 0 <= int_value &&
-        int_value < PIPELINE_STATUS_COUNT) {
-      result.push_back(static_cast<PipelineStatus>(int_value));
-    }
-  }
-
-  return result;
-}
-
-// Maps DemuxerStream instances to decoding mode.
-base::LazyInstance<std::map<const DemuxerStream*, PlatformMediaDecodingMode>>
-    g_pipeline_streams = LAZY_INSTANCE_INITIALIZER;
-
-// A registry of decoder class names.
-base::LazyInstance<std::set<std::string>> g_decoder_class_names =
-    LAZY_INSTANCE_INITIALIZER;
-
-// DemuxerStream instances associated with decoders (rather than the whole
-// pipeline).
-base::LazyInstance<std::set<const DemuxerStream*>> g_decoder_streams =
-    LAZY_INSTANCE_INITIALIZER;
-
-// A queue of PipelineStatus values.  Used in a child process to collect stats
-// before sending them to the browser process.
-base::LazyInstance<StatusQueue> g_status_queue = LAZY_INSTANCE_INITIALIZER;
-
-void Enqueue(PipelineStatus status) {
-  g_status_queue.Get().Push(status);
-}
-
-void ReportDecoderStreamError(const DemuxerStream* stream) {
-  switch (stream->type()) {
-    case DemuxerStream::AUDIO:
-      Enqueue(DECODER_AUDIO_DECODE_ERROR);
-      break;
-
-    case DemuxerStream::VIDEO:
-      Enqueue(DECODER_VIDEO_DECODE_ERROR);
-      break;
-
-    default:
-      NOTREACHED();
-      break;
-  }
-}
-
-void ReportPipelineStreamError(const DemuxerStream* stream,
-                               PlatformMediaDecodingMode decoding_mode) {
-  switch (stream->type()) {
-    case DemuxerStream::AUDIO:
-      Enqueue(PIPELINE_AUDIO_DECODE_ERROR);
-      break;
-
-    case DemuxerStream::VIDEO: {
-      Enqueue(decoding_mode == PlatformMediaDecodingMode::HARDWARE
-                  ? PIPELINE_VIDEO_DECODE_ERROR_HW
-                  : PIPELINE_VIDEO_DECODE_ERROR);
-      break;
-    }
-
-    default:
-      NOTREACHED();
-      break;
-  }
-}
-
-}  // namespace
-
-void ReportNoPlatformSupport() {
-  Enqueue(PIPELINE_NOT_AVAILABLE);
-}
-
-void ReportNoGpuProcess() {
-  Enqueue(PIPELINE_NO_GPU_PROCESS);
-}
-
-void ReportNoGpuProcessForDecoder() {
-  Enqueue(DECODER_NO_GPU_PROCESS);
-}
-
-void ReportStartResult(
-    bool success,
-    PlatformMediaDecodingMode attempted_video_decoding_mode) {
-  if (success) {
-    Enqueue(attempted_video_decoding_mode == PlatformMediaDecodingMode::HARDWARE
-                ? PIPELINE_INITIALIZED_HW
-                : PIPELINE_INITIALIZED);
-    return;
-  }
-
-  Enqueue(attempted_video_decoding_mode == PlatformMediaDecodingMode::HARDWARE
-              ? PIPELINE_INITIALIZE_ERROR_HW
-              : PIPELINE_INITIALIZE_ERROR);
-}
-
-void ReportAudioDecoderInitResult(bool success) {
-  Enqueue(success ? DECODER_AUDIO_INITIALIZED : DECODER_AUDIO_INITIALIZE_ERROR);
-}
-
-void ReportVideoDecoderInitResult(bool success) {
-  Enqueue(success ? DECODER_VIDEO_INITIALIZED : DECODER_VIDEO_INITIALIZE_ERROR);
-}
-
-void AddStream(const DemuxerStream* stream,
-               PlatformMediaDecodingMode decoding_mode) {
-  DCHECK_EQ(0u, g_pipeline_streams.Get().count(stream));
-  g_pipeline_streams.Get()[stream] = decoding_mode;
-}
-
-void RemoveStream(const DemuxerStream* stream) {
-  DCHECK_EQ(1u, g_pipeline_streams.Get().count(stream));
-  g_pipeline_streams.Get().erase(stream);
-}
-
-void AddDecoderClass(const std::string& decoder_class_name) {
-  g_decoder_class_names.Get().insert(decoder_class_name);
-}
-
-void AddStreamForDecoderClass(const DemuxerStream* stream,
-                              const std::string& decoder_class_name) {
-  if (g_decoder_class_names.Get().count(decoder_class_name) < 1)
-    // Unknown decoder name -- no one claimed it by calling AddDecoderClass().
-    return;
-
-  const auto result = g_decoder_streams.Get().insert(stream);
-  DCHECK(result.second);
-}
-
-void RemoveStreamForDecoderClass(const DemuxerStream* stream,
-                                 const std::string& decoder_class_name) {
-  if (g_decoder_class_names.Get().count(decoder_class_name) < 1)
-    // Unknown decoder name -- no one claimed it by calling AddDecoderClass().
-    return;
-
-  const auto erased_count = g_decoder_streams.Get().erase(stream);
-  DCHECK_EQ(1u, erased_count);
-}
-
-void ReportStreamError(const DemuxerStream* stream) {
-  if (g_decoder_streams.Get().count(stream) > 0) {
-    ReportDecoderStreamError(stream);
-    return;
-  }
-
-  const auto it = g_pipeline_streams.Get().find(stream);
-  if (it != g_pipeline_streams.Get().end()) {
-    ReportPipelineStreamError(stream, it->second);
-    return;
-  }
-
-  // Unknown DemuxerStream -- no one claimed it either by calling AddStream()
-  // or AddStreamForDecoderClass().
-}
-
-void SerializeInto(base::DictionaryValue* dictionary) {
-  StatusQueue::Serialize(g_status_queue.Get(), dictionary);
-  g_status_queue.Get().Clear();
-}
-
-void DeserializeAndReport(const base::DictionaryValue& dictionary) {
-  const auto values = StatusQueue::Deserialize(dictionary);
-
-  for (const auto value : values) {
-    UMA_HISTOGRAM_ENUMERATION("Opera.DSK.Media.PlatformPipelineStatus", value,
-                              PIPELINE_STATUS_COUNT);
-  }
-}
-
-}  // namespace pipeline_stats
-}  // namespace media
diff --git a/media/base/pipeline_stats.h b/media/base/pipeline_stats.h
deleted file mode 100644
index f9afa19..0000000
--- a/media/base/pipeline_stats.h
+++ /dev/null
@@ -1,86 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_BASE_PIPELINE_STATS_H_
-#define MEDIA_BASE_PIPELINE_STATS_H_
-
-#include <string>
-
-#include "media/base/media_export.h"
-
-namespace base {
-class DictionaryValue;
-}
-
-namespace media {
-
-class DemuxerStream;
-enum class PlatformMediaDecodingMode;
-
-// Use these functions to report about events concerning the whole media
-// pipeline so that we can gather some statistics.
-namespace pipeline_stats {
-
-// A Demuxer was chosen to handle the content type, but could not be used due
-// to missing system libraries.
-MEDIA_EXPORT void ReportNoPlatformSupport();
-
-// A Demuxer was chosen to handle the content type, but could not be used
-// because there was no GPU process.
-MEDIA_EXPORT void ReportNoGpuProcess();
-
-// HW-accelerated decoders won't be available.
-void ReportNoGpuProcessForDecoder();
-
-// Demuxer initialization has completed.
-void ReportStartResult(bool success,
-                       PlatformMediaDecodingMode attempted_video_decoding_mode);
-
-// AudioDecoder initialization has completed.
-void ReportAudioDecoderInitResult(bool success);
-
-// VideoDecoder initialization has completed.
-void ReportVideoDecoderInitResult(bool success);
-
-// Register a DemuxerStream to be used in ReportStreamError() later on.
-void AddStream(const DemuxerStream* stream,
-               PlatformMediaDecodingMode decoding_mode);
-
-// Remove stream registration.
-void RemoveStream(const DemuxerStream* stream);
-
-// Register a decoder class name.  Only streams associated with decoders whose
-// class names have been registered will actually be registered by
-// AddStreamForDecoderClass().
-void AddDecoderClass(const std::string& decoder_class_name);
-
-// Register a DemuxerStream to be used in ReportStreamError() later on, but
-// only if the class name of the associated decoder has been registered (see
-// AddDecoderClass()).  This allows us to register streams from generic code
-// and yet only collect data on streams associated with certain decoders.
-void AddStreamForDecoderClass(const DemuxerStream* stream,
-                              const std::string& decoder_class_name);
-
-// Remove stream registration.
-void RemoveStreamForDecoderClass(const DemuxerStream* stream,
-                                 const std::string& decoder_class_name);
-
-// There was an error related to |stream| after the pipeline had been
-// initialized.
-void ReportStreamError(const DemuxerStream* stream);
-
-// Called in a child process to serialize the stats collected since startup or
-// the last call to this function.
-MEDIA_EXPORT void SerializeInto(base::DictionaryValue* dictionary);
-
-// Called in the browser process to deserialize stats previously serialized
-// using SerializeInto(), and report them to the metrics system.
-MEDIA_EXPORT void DeserializeAndReport(const base::DictionaryValue& dictionary);
-
-}  // namespace pipeline_stats
-}  // namespace media
-
-#endif  // MEDIA_BASE_PIPELINE_STATS_H_
diff --git a/media/base/platform_mime_util.h b/media/base/platform_mime_util.h
deleted file mode 100644
index 274ef27..0000000
--- a/media/base/platform_mime_util.h
+++ /dev/null
@@ -1,44 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_BASE_PLATFORM_MIME_UTIL_H_
-#define MEDIA_BASE_PLATFORM_MIME_UTIL_H_
-
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#error Should only be built with USE_SYSTEM_PROPRIETARY_CODECS
-#endif
-
-#include "media/base/audio_decoder_config.h"
-#include "media/base/media_export.h"
-
-namespace media {
-
-enum class PlatformMediaCheckType {
-  // Instructs to perform basic availability checks.  The result should be
-  // close to the |FULL| result in most cases, but it's allowed to be overly
-  // optimistic.  This type is intended for callers with restricted privileges,
-  // e.g., those running in the renderer process.
-  BASIC,
-  // Instructs to perform full availability checks.
-  FULL,
-};
-
-// Returns true iff the system is able to demux media files and return decoded
-// audio and video streams using system libraries.
-MEDIA_EXPORT bool IsPlatformMediaPipelineAvailable(
-    PlatformMediaCheckType check_type);
-
-// Returns true iff the system is able to decode audio streams using system
-// libraries.
-bool IsPlatformAudioDecoderAvailable(AudioCodec codec);
-
-// Returns true iff the system is able to decode video streams using system
-// libraries.
-bool IsPlatformVideoDecoderAvailable();
-
-}  // namespace media
-
-#endif  // MEDIA_BASE_PLATFORM_MIME_UTIL_H_
diff --git a/media/base/platform_mime_util_mac.mm b/media/base/platform_mime_util_mac.mm
deleted file mode 100644
index 83c5d59..0000000
--- a/media/base/platform_mime_util_mac.mm
+++ /dev/null
@@ -1,27 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/base/platform_mime_util.h"
-
-#include "base/mac/mac_util.h"
-
-namespace media {
-
-bool IsPlatformMediaPipelineAvailable(PlatformMediaCheckType /* check_type */) {
-  // AVAssetResourceLoaderDelegate is required.
-  return base::mac::IsOSMavericksOrLater();
-}
-
-bool IsPlatformAudioDecoderAvailable(AudioCodec /* codec */) {
-  return true;
-}
-
-bool IsPlatformVideoDecoderAvailable() {
-  // VTVideoDecodeAccelerator currently requires 10.9.
-  return base::mac::IsOSMavericksOrLater();
-}
-
-}  // namespace media
diff --git a/media/base/platform_mime_util_win.cc b/media/base/platform_mime_util_win.cc
deleted file mode 100644
index 4056ff9..0000000
--- a/media/base/platform_mime_util_win.cc
+++ /dev/null
@@ -1,32 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/base/platform_mime_util.h"
-
-#include "media/base/win/mf_util.h"
-
-namespace media {
-
-bool IsPlatformMediaPipelineAvailable(PlatformMediaCheckType check_type) {
-  if (!LoadMFCommonLibraries())
-    return false;
-
-  if (check_type == PlatformMediaCheckType::FULL &&
-      !LoadMFSourceReaderLibraries())
-    return false;
-
-  return true;
-}
-
-bool IsPlatformAudioDecoderAvailable(AudioCodec codec) {
-  return LoadMFCommonLibraries() && LoadMFAudioDecoderLibrary(codec);
-}
-
-bool IsPlatformVideoDecoderAvailable() {
-  return LoadMFCommonLibraries() && LoadMFVideoDecoderLibraries();
-}
-
-}  // namespace media
diff --git a/media/base/renderer_factory.h b/media/base/renderer_factory.h
index c8d5712..65c5cbe 100644
--- a/media/base/renderer_factory.h
+++ b/media/base/renderer_factory.h
@@ -38,9 +38,7 @@ class MEDIA_EXPORT RendererFactory {
       const scoped_refptr<base::TaskRunner>& worker_task_runner,
       AudioRendererSink* audio_renderer_sink,
       VideoRendererSink* video_renderer_sink,
-      const RequestSurfaceCB& request_surface_cb,
-      bool use_platform_media_pipeline,
-      bool platform_pipeline_enlarges_buffers_on_underflow) = 0;
+      const RequestSurfaceCB& request_surface_cb) = 0;
 
  private:
   DISALLOW_COPY_AND_ASSIGN(RendererFactory);
diff --git a/media/base/win/mf_initializer.cc b/media/base/win/mf_initializer.cc
index ae54eed..ff62a45 100644
--- a/media/base/win/mf_initializer.cc
+++ b/media/base/win/mf_initializer.cc
@@ -8,25 +8,16 @@
 
 #include "base/lazy_instance.h"
 #include "base/macros.h"
-#include "base/win/windows_version.h"
 
 namespace media {
 
 namespace {
 
-// Media Foundation version number has last changed with Windows 7, see
-// mfapi.h.
-const int kMFVersionVista = (0x0001 << 16 | MF_API_VERSION);
-const int kMFVersionWin7 = (0x0002 << 16 | MF_API_VERSION);
-
 // LazyInstance to initialize the Media Foundation Library.
 class MFInitializer {
  public:
   MFInitializer()
-      : mf_started_(MFStartup(base::win::GetVersion() >= base::win::VERSION_WIN7
-                                  ? kMFVersionWin7
-                                  : kMFVersionVista,
-                              MFSTARTUP_LITE) == S_OK) {}
+      : mf_started_(MFStartup(MF_VERSION, MFSTARTUP_LITE) == S_OK) {}
 
   ~MFInitializer() {
     if (mf_started_)
diff --git a/media/base/win/mf_util.cc b/media/base/win/mf_util.cc
deleted file mode 100644
index b53e588..0000000
--- a/media/base/win/mf_util.cc
+++ /dev/null
@@ -1,200 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/base/win/mf_util.h"
-
-#include <map>
-
-#include "base/features/features.h"
-#include "base/lazy_instance.h"
-#include "base/logging.h"
-#include "base/metrics/histogram_macros.h"
-#include "base/win/windows_version.h"
-
-namespace media {
-
-namespace {
-
-// Used in UMA histograms.  Don't remove or reorder values!
-enum MFStatus {
-  MF_NOT_SUPPORTED = 0,
-  MF_PLAT_AVAILABLE = 1,
-  MF_PLAT_NOT_AVAILABLE = 2,
-  MF_VIDEO_DECODER_AVAILABLE = 3,
-  MF_VIDEO_DECODER_NOT_AVAILABLE = 4,
-  MF_AAC_DECODER_AVAILABLE = 5,
-  MF_AAC_DECODER_NOT_AVAILABLE = 6,
-  MF_STATUS_COUNT
-};
-
-void ReportMFStatus(MFStatus status) {
-  UMA_HISTOGRAM_ENUMERATION("Opera.DSK.Media.MFStatus", status,
-                            MF_STATUS_COUNT);
-}
-
-bool CheckOSVersion() {
-  if (base::win::GetVersion() < base::win::VERSION_VISTA) {
-    DLOG(WARNING)
-        << "We don't support proprietary media codecs in this Windows version";
-    return false;
-  }
-
-  return true;
-}
-
-bool LoadMFLibrary(const char* library_name) {
-  if (!CheckOSVersion())
-    return false;
-
-  if (::GetModuleHandleA(library_name) == NULL &&
-      ::LoadLibraryA(library_name) == NULL) {
-    DLOG(WARNING) << "Failed to load " << library_name
-                  << ". Some media features will not be available.";
-    return false;
-  }
-
-  return true;
-}
-
-// LazyInstance to have a lazily evaluated, cached result available to multiple
-// threads in a safe manner.
-class PrimaryLoader {
- public:
-  PrimaryLoader();
-
-  bool is_media_foundation_available() const {
-    return media_foundation_available_;
-  }
-  bool is_audio_decoder_available(AudioCodec codec) const {
-    DCHECK_EQ(1u, audio_decoder_available_.count(codec));
-    return audio_decoder_available_.find(codec)->second;
-  }
-  bool is_video_decoder_available() const { return video_decoder_available_; }
-
- private:
-  void ReportLoadResults();
-
-  bool media_foundation_available_;
-  std::map<AudioCodec, bool> audio_decoder_available_;
-  bool video_decoder_available_;
-};
-
-PrimaryLoader::PrimaryLoader()
-    : media_foundation_available_(LoadMFLibrary("mfplat.dll")),
-      video_decoder_available_(
-          LoadMFLibrary(GetMFVideoDecoderLibraryName().c_str()) &&
-          LoadMFLibrary("evr.dll")) {
-  audio_decoder_available_[kCodecMP3] =
-      base::IsFeatureEnabled(base::kFeatureMseAudioMpegAac)
-          ? LoadMFLibrary(GetMFAudioDecoderLibraryName(kCodecMP3).c_str())
-          : false;
-  audio_decoder_available_[kCodecAAC] =
-      LoadMFLibrary(GetMFAudioDecoderLibraryName(kCodecAAC).c_str());
-
-  ReportLoadResults();
-}
-
-void PrimaryLoader::ReportLoadResults() {
-  if (!CheckOSVersion()) {
-    ReportMFStatus(MF_NOT_SUPPORTED);
-    return;
-  }
-
-  ReportMFStatus(media_foundation_available_ ? MF_PLAT_AVAILABLE
-                                             : MF_PLAT_NOT_AVAILABLE);
-  ReportMFStatus(video_decoder_available_ ? MF_VIDEO_DECODER_AVAILABLE
-                                          : MF_VIDEO_DECODER_NOT_AVAILABLE);
-  // TODO(wdzierzanowski): Start reporting MP3 decoder status once the feature
-  // is stable.
-  ReportMFStatus(audio_decoder_available_[kCodecAAC]
-                     ? MF_AAC_DECODER_AVAILABLE
-                     : MF_AAC_DECODER_NOT_AVAILABLE);
-}
-
-class SecondaryLoader {
- public:
-  SecondaryLoader()
-      : source_reader_available_(LoadMFLibrary("mfreadwrite.dll") &&
-                                 LoadMFLibrary("evr.dll")) {}
-
-  bool is_source_reader_available() const { return source_reader_available_; }
-
- private:
-  bool source_reader_available_;
-};
-
-// Provide two separate loaders, one for the common mfplat.dll library plus
-// decoder libraries, and another one for mfreadwrite.dll.  The latter provides
-// IMFSourceReader, which is only necessary when decoding _and_ demuxing using
-// system libraries.
-base::LazyInstance<PrimaryLoader> g_primary_loader = LAZY_INSTANCE_INITIALIZER;
-base::LazyInstance<SecondaryLoader> g_secondary_loader =
-    LAZY_INSTANCE_INITIALIZER;
-
-}  // namespace
-
-bool LoadMFCommonLibraries() {
-  return g_primary_loader.Get().is_media_foundation_available();
-}
-
-bool LoadMFSourceReaderLibraries() {
-  return g_secondary_loader.Get().is_source_reader_available();
-}
-
-void LoadMFAudioDecoderLibraries() {
-  g_primary_loader.Get();
-}
-
-bool LoadMFAudioDecoderLibrary(AudioCodec codec) {
-  return g_primary_loader.Get().is_audio_decoder_available(codec);
-}
-
-bool LoadMFVideoDecoderLibraries() {
-  return g_primary_loader.Get().is_video_decoder_available();
-}
-
-std::string GetMFAudioDecoderLibraryName(AudioCodec codec) {
-  if (codec == kCodecMP3)
-    return "mp3dmod.dll";
-
-  std::string name;
-  const base::win::Version version = base::win::GetVersion();
-  if (version >= base::win::VERSION_WIN8)
-    name = "msauddecmft.dll";
-  else if (version == base::win::VERSION_WIN7)
-    name = "msmpeg2adec.dll";
-  else if (version == base::win::VERSION_VISTA)
-    name = "mfheaacdec.dll";
-  else
-    NOTREACHED() << "Unexpected Windows version";
-
-  return name;
-}
-
-std::string GetMFVideoDecoderLibraryName() {
-  std::string name;
-  const base::win::Version version = base::win::GetVersion();
-  if (version >= base::win::VERSION_WIN7)
-    name = "msmpeg2vdec.dll";
-  else if (version == base::win::VERSION_VISTA)
-    name = "mfh264dec.dll";
-  else
-    NOTREACHED() << "Unexpected Windows version";
-
-  return name;
-}
-
-FARPROC GetFunctionFromLibrary(const char* function_name,
-                               const char* library_name) {
-  HMODULE library = ::GetModuleHandleA(library_name);
-  if (!library)
-    library = ::LoadLibraryA(library_name);
-  if (!library)
-    return nullptr;
-  return ::GetProcAddress(library, function_name);
-}
-
-}  // namespace media
diff --git a/media/base/win/mf_util.h b/media/base/win/mf_util.h
deleted file mode 100644
index 2df7add..0000000
--- a/media/base/win/mf_util.h
+++ /dev/null
@@ -1,41 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_BASE_WIN_MF_UTIL_H_
-#define MEDIA_BASE_WIN_MF_UTIL_H_
-
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#error Should only be built with USE_SYSTEM_PROPRIETARY_CODECS
-#endif
-
-#include <windows.h>
-
-#include <string>
-
-#include "media/base/audio_decoder_config.h"
-#include "media/base/media_export.h"
-
-namespace media {
-
-// Utility functions for loading different subsets of the Media Foundation
-// libraries.  In each case, the library name appropriate for the current
-// Windows version is chosen.  The functions can be called many times per
-// process and return the same value throughout the lifetime of the process.
-MEDIA_EXPORT bool LoadMFCommonLibraries();
-MEDIA_EXPORT void LoadMFAudioDecoderLibraries();
-bool LoadMFAudioDecoderLibrary(AudioCodec codec);
-MEDIA_EXPORT bool LoadMFVideoDecoderLibraries();
-bool LoadMFSourceReaderLibraries();
-
-std::string GetMFAudioDecoderLibraryName(AudioCodec codec);
-std::string GetMFVideoDecoderLibraryName();
-
-MEDIA_EXPORT FARPROC
-GetFunctionFromLibrary(const char* function_name, const char* library_name);
-
-}  // namespace media
-
-#endif  // MEDIA_BASE_WIN_MF_UTIL_H_
diff --git a/media/blink/buffered_data_source.cc b/media/blink/buffered_data_source.cc
index 011efd8..432655d 100644
--- a/media/blink/buffered_data_source.cc
+++ b/media/blink/buffered_data_source.cc
@@ -147,12 +147,14 @@ BufferedResourceLoader* BufferedDataSource::CreateResourceLoader(
       BufferedResourceLoader::kReadThenDefer :
       BufferedResourceLoader::kCapacityDefer;
 
-  auto* loader = new BufferedResourceLoader(
-      url_, cors_mode_, first_byte_position, last_byte_position, strategy,
-      bitrate_, playback_rate_, media_log_.get());
-  loader->SetTargetBufferDuration(target_buffer_duration_behind_,
-                                  target_buffer_duration_ahead_);
-  return loader;
+  return new BufferedResourceLoader(url_,
+                                    cors_mode_,
+                                    first_byte_position,
+                                    last_byte_position,
+                                    strategy,
+                                    bitrate_,
+                                    playback_rate_,
+                                    media_log_.get());
 }
 
 void BufferedDataSource::Initialize(const InitializeCB& init_cb) {
@@ -232,14 +234,6 @@ void BufferedDataSource::MediaIsPlaying() {
   UpdateDeferStrategy();
 }
 
-void BufferedDataSource::SetTargetBufferDuration(base::TimeDelta behind,
-                                                 base::TimeDelta ahead) {
-  DCHECK(render_task_runner_->BelongsToCurrentThread());
-  target_buffer_duration_behind_ = behind;
-  target_buffer_duration_ahead_ = ahead;
-  loader_->SetTargetBufferDuration(behind, ahead);
-}
-
 /////////////////////////////////////////////////////////////////////////////
 // DataSource implementation.
 void BufferedDataSource::Stop() {
@@ -415,7 +409,6 @@ void BufferedDataSource::StartCallback(
 
   if (success) {
     total_bytes_ = loader_->instance_size();
-    mime_type_ = loader_->mime_type();
     streaming_ =
         !assume_fully_buffered() &&
         (total_bytes_ == kPositionNotSpecified || !loader_->range_supported());
diff --git a/media/blink/buffered_data_source.h b/media/blink/buffered_data_source.h
index 3bec92e..57c2b00 100644
--- a/media/blink/buffered_data_source.h
+++ b/media/blink/buffered_data_source.h
@@ -177,10 +177,6 @@ class MEDIA_BLINK_EXPORT BufferedDataSource
   void MediaIsPlaying() override;
   bool media_has_played() const override;
 
-  // Sets the target buffer capacity in both the backward and forward
-  // directions. Pass base::TimeDelta() to use default values.
-  void SetTargetBufferDuration(base::TimeDelta behind, base::TimeDelta ahead);
-
   // Returns true if the resource is local.
   bool assume_fully_buffered() override;
 
@@ -206,9 +202,6 @@ class MEDIA_BLINK_EXPORT BufferedDataSource
   bool IsStreaming() override;
   void SetBitrate(int bitrate) override;
 
-  const GURL& url() const { return url_; }
-  const std::string& mime_type() const { return mime_type_; }
-
  protected:
   // A factory method to create a BufferedResourceLoader based on the read
   // parameters. We can override this file to object a mock
@@ -265,10 +258,6 @@ class MEDIA_BLINK_EXPORT BufferedDataSource
   // determined by reaching EOF.
   int64_t total_bytes_;
 
-  // The mime type of the resource.  Set during StartCallback() if the type is
-  // known, otherwise it will remain empty.
-  std::string mime_type_;
-
   // This value will be true if this data source can only support streaming.
   // i.e. range request is not supported.
   bool streaming_;
@@ -325,10 +314,6 @@ class MEDIA_BLINK_EXPORT BufferedDataSource
   // Current playback rate.
   double playback_rate_;
 
-  // Target buffer capacity in both the backward and forward directions.
-  base::TimeDelta target_buffer_duration_behind_;
-  base::TimeDelta target_buffer_duration_ahead_;
-
   scoped_refptr<MediaLog> media_log_;
 
   // Host object to report buffered byte range changes to.
diff --git a/media/blink/buffered_resource_loader.cc b/media/blink/buffered_resource_loader.cc
index bbc881c..01427a1 100644
--- a/media/blink/buffered_resource_loader.cc
+++ b/media/blink/buffered_resource_loader.cc
@@ -12,7 +12,6 @@
 #include "base/bits.h"
 #include "base/callback_helpers.h"
 #include "base/metrics/histogram.h"
-#include "base/numerics/safe_conversions.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
 #include "media/base/media_log.h"
@@ -60,13 +59,9 @@ static const int kForwardWaitThreshold = 2 * kMegabyte;
 // Computes the suggested backward and forward capacity for the buffer
 // if one wants to play at |playback_rate| * the natural playback speed.
 // Use a value of 0 for |bitrate| if it is unknown.
-static void ComputeTargetBufferWindow(
-    double playback_rate,
-    int bitrate,
-    base::TimeDelta target_buffer_duration_behind,
-    base::TimeDelta target_buffer_duration_ahead,
-    int* out_backward_capacity,
-    int* out_forward_capacity) {
+static void ComputeTargetBufferWindow(double playback_rate, int bitrate,
+                                      int* out_backward_capacity,
+                                      int* out_forward_capacity) {
   static const int kDefaultBitrate = 200 * 1024 * 8;  // 200 Kbps.
   static const int kMaxBitrate = 20 * kMegabyte * 8;  // 20 Mbps.
   static const double kMaxPlaybackRate = 25.0;
@@ -97,19 +92,6 @@ static void ComputeTargetBufferWindow(
   *out_backward_capacity = std::max(
       kTargetSecondsBufferedBehind * bytes_per_second, kMinBufferCapacity);
 
-  if (target_buffer_duration_ahead != base::TimeDelta()) {
-    *out_forward_capacity = std::max(
-        base::saturated_cast<int>(target_buffer_duration_ahead.InSecondsF() *
-                                  bytes_per_second),
-        kMinBufferCapacity);
-  }
-  if (target_buffer_duration_behind != base::TimeDelta()) {
-    *out_backward_capacity = std::max(
-        base::saturated_cast<int>(target_buffer_duration_behind.InSecondsF() *
-                                  bytes_per_second),
-        kMinBufferCapacity);
-  }
-
   *out_forward_capacity = std::min(*out_forward_capacity, kMaxBufferCapacity);
   *out_backward_capacity = std::min(*out_backward_capacity, kMaxBufferCapacity);
 
@@ -340,10 +322,6 @@ int64_t BufferedResourceLoader::instance_size() {
   return instance_size_;
 }
 
-const std::string& BufferedResourceLoader::mime_type() {
-  return mime_type_;
-}
-
 bool BufferedResourceLoader::range_supported() {
   return range_supported_;
 }
@@ -423,7 +401,6 @@ void BufferedResourceLoader::didReceiveResponse(
   // Expected content length can be |kPositionNotSpecified|, in that case
   // |content_length_| is not specified and this is a streaming response.
   content_length_ = response.expectedContentLength();
-  mime_type_ = response.mimeType().latin1();
 
   // We make a strong assumption that when we reach here we have either
   // received a response from HTTP/HTTPS protocol or the request was
@@ -637,18 +614,6 @@ void BufferedResourceLoader::SetBitrate(int bitrate) {
   UpdateBufferWindow();
 }
 
-void BufferedResourceLoader::SetTargetBufferDuration(base::TimeDelta behind,
-                                                     base::TimeDelta ahead) {
-  if (behind == target_buffer_duration_behind_ &&
-      ahead == target_buffer_duration_ahead_)
-    return;
-
-  target_buffer_duration_behind_ = behind;
-  target_buffer_duration_ahead_ = ahead;
-
-  UpdateBufferWindow();
-}
-
 /////////////////////////////////////////////////////////////////////////////
 // Helper methods.
 
@@ -656,8 +621,7 @@ void BufferedResourceLoader::UpdateBufferWindow() {
   int backward_capacity;
   int forward_capacity;
   ComputeTargetBufferWindow(
-      playback_rate_, bitrate_, target_buffer_duration_behind_,
-      target_buffer_duration_ahead_, &backward_capacity, &forward_capacity);
+      playback_rate_, bitrate_, &backward_capacity, &forward_capacity);
 
   // This does not evict data from the buffer if the new capacities are less
   // than the current capacities; the new limits will be enforced after the
diff --git a/media/blink/buffered_resource_loader.h b/media/blink/buffered_resource_loader.h
index f9cc823..6cc1aa6 100644
--- a/media/blink/buffered_resource_loader.h
+++ b/media/blink/buffered_resource_loader.h
@@ -131,10 +131,6 @@ class MEDIA_BLINK_EXPORT BufferedResourceLoader
   // |kPositionNotSpecified|, then the size is unknown.
   int64_t instance_size();
 
-  // Gets the mime type of the file requested. If this value is
-  // empty, then the mime type is unknown.
-  const std::string& mime_type();
-
   // Returns true if the server supports byte range requests.
   bool range_supported();
 
@@ -191,11 +187,6 @@ class MEDIA_BLINK_EXPORT BufferedResourceLoader
   // accordingly.
   void SetBitrate(int bitrate);
 
-  // Sets the target buffer capacity in both the backward and forward
-  // directions, and updates the buffer window. Pass base::TimeDelta() to use
-  // default values.
-  void SetTargetBufferDuration(base::TimeDelta behind, base::TimeDelta ahead);
-
   // Return the |first_byte_position| passed into the ctor.
   int64_t first_byte_position() const;
 
@@ -297,7 +288,6 @@ class MEDIA_BLINK_EXPORT BufferedResourceLoader
   int saved_forward_capacity_;
 
   GURL url_;
-  std::string mime_type_;
   CORSMode cors_mode_;
   const int64_t first_byte_position_;
   const int64_t last_byte_position_;
@@ -337,10 +327,6 @@ class MEDIA_BLINK_EXPORT BufferedResourceLoader
   // Playback rate of the media.
   double playback_rate_;
 
-  // Target buffer capacity in both the backward and forward directions.
-  base::TimeDelta target_buffer_duration_behind_;
-  base::TimeDelta target_buffer_duration_ahead_;
-
   GURL response_original_url_;
 
   scoped_refptr<MediaLog> media_log_;
diff --git a/media/blink/webmediaplayer_impl.cc b/media/blink/webmediaplayer_impl.cc
index 6f7c227..67ba20c 100644
--- a/media/blink/webmediaplayer_impl.cc
+++ b/media/blink/webmediaplayer_impl.cc
@@ -58,18 +58,6 @@
 #include "third_party/WebKit/public/web/WebLocalFrame.h"
 #include "third_party/WebKit/public/web/WebView.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/base/pipeline_stats.h"
-#include "media/base/platform_mime_util.h"
-#include "media/filters/ipc_demuxer.h"
-#include "media/filters/pass_through_audio_decoder.h"
-#include "media/filters/pass_through_video_decoder.h"
-#endif
-
-#if defined(OS_MACOSX)
-#include "media/filters/core_audio_demuxer.h"
-#endif
-
 using blink::WebCanvas;
 using blink::WebMediaPlayer;
 using blink::WebRect;
@@ -197,14 +185,8 @@ WebMediaPlayerImpl::WebMediaPlayerImpl(
       context_3d_cb_(params.context_3d_cb()),
       adjust_allocated_memory_cb_(params.adjust_allocated_memory_cb()),
       last_reported_memory_usage_(0),
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-      ipc_media_pipeline_host_creator_(
-          params.ipc_media_pipeline_host_creator()),
-      ipc_demuxer_(NULL),
-#endif
       supports_save_(true),
       chunk_demuxer_(NULL),
-      data_source2_(NULL),
       url_index_(url_index),
       // Threaded compositing isn't enabled universally yet.
       compositor_task_runner_(
@@ -290,7 +272,7 @@ WebMediaPlayerImpl::~WebMediaPlayerImpl() {
 
 void WebMediaPlayerImpl::load(LoadType load_type, const blink::WebURL& url,
                               CORSMode cors_mode) {
-  DVLOG(1) << __FUNCTION__ << "(" << load_type << ", " << url.string().utf8() << ", "
+  DVLOG(1) << __FUNCTION__ << "(" << load_type << ", " << url << ", "
            << cors_mode << ")";
   if (!defer_load_cb_.is_null()) {
     defer_load_cb_.Run(base::Bind(
@@ -362,7 +344,6 @@ void WebMediaPlayerImpl::DoLoad(LoadType load_type,
     // we have enough data to support the primacy of the new media cache.
     // See http://crbug.com/514719 for details.
     // Otherwise it's a regular request which requires resolving the URL first.
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
     if (base::FeatureList::IsEnabled(kUseNewMediaCache)) {
       // Remove this when MultiBufferDataSource becomes default.
       LOG(WARNING) << "Using MultibufferDataSource";
@@ -370,11 +351,8 @@ void WebMediaPlayerImpl::DoLoad(LoadType load_type,
           url, static_cast<UrlData::CORSMode>(cors_mode), main_task_runner_,
           url_index_, frame_, media_log_.get(), &buffered_data_source_host_,
           base::Bind(&WebMediaPlayerImpl::NotifyDownloading, AsWeakPtr())));
-      data_source2_ = NULL;
-    } 
-#endif // !USE_SYSTEM_PROPRIETARY_CODECS
-    else {
-      data_source_.reset(data_source2_ = new BufferedDataSource(
+    } else {
+      data_source_.reset(new BufferedDataSource(
           url, static_cast<BufferedResourceLoader::CORSMode>(cors_mode),
           main_task_runner_, frame_, media_log_.get(),
           &buffered_data_source_host_,
@@ -500,11 +478,6 @@ void WebMediaPlayerImpl::DoSeek(base::TimeDelta time, bool time_updated) {
     paused_time_ = time;
   pipeline_controller_.Seek(time, time_updated);
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (ipc_demuxer_)
-    ipc_demuxer_->StartWaitingForSeek(seek_time_);
-#endif
-
   // This needs to be called after Seek() so that if a resume is triggered, it
   // is to the correct time.
   UpdatePlayState();
@@ -1221,18 +1194,7 @@ void WebMediaPlayerImpl::DataSourceInitialized(bool success) {
     return;
   }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (data_source2_ &&
-      ProtocolSniffer::ShouldSniffProtocol(data_source2_->mime_type())) {
-    // PostTask is needed to free BufferedDataSource lock as recursive ones
-    // are not allowed.
-    main_task_runner_->PostTask(
-        FROM_HERE, base::Bind(&WebMediaPlayerImpl::SniffProtocol, AsWeakPtr()));
-  } else
-#endif  // USE_SYSTEM_PROPRIETARY_CODECS
-  {
-    StartPipeline();
-  }
+  StartPipeline();
 }
 
 void WebMediaPlayerImpl::NotifyDownloading(bool is_downloading) {
@@ -1282,22 +1244,9 @@ scoped_ptr<Renderer> WebMediaPlayerImpl::CreateRenderer() {
   request_surface_cb =
       BIND_TO_RENDER_LOOP(&WebMediaPlayerImpl::OnSurfaceRequested);
 #endif
-  bool use_platform_media_pipeline = false;
-  bool platform_pipeline_enlarges_buffers_on_underflow = false;
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  use_platform_media_pipeline = media::IPCDemuxer::CanPlayType(
-      content_type_, data_source2_ ? data_source2_->url() : GURL());
-
-  if (use_platform_media_pipeline &&
-      !IsPlatformMediaPipelineAvailable(PlatformMediaCheckType::BASIC)) {
-    use_platform_media_pipeline = false;
-  }
-#endif
   return renderer_factory_->CreateRenderer(
       media_task_runner_, worker_task_runner_, audio_source_provider_.get(),
-      compositor_, request_surface_cb,
-      use_platform_media_pipeline,
-      platform_pipeline_enlarges_buffers_on_underflow);
+      compositor_, request_surface_cb);
 }
 
 void WebMediaPlayerImpl::StartPipeline() {
@@ -1307,60 +1256,10 @@ void WebMediaPlayerImpl::StartPipeline() {
       BIND_TO_RENDER_LOOP(&WebMediaPlayerImpl::OnEncryptedMediaInitData);
 
   // Figure out which demuxer to use.
-  bool use_platform_media_pipeline = false;
-  bool platform_pipeline_enlarges_buffers_on_underflow = false;
   if (load_type_ != LoadTypeMediaSource) {
     DCHECK(!chunk_demuxer_);
     DCHECK(data_source_);
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    // Update the content type here as it may not have been set when the
-    // media player was asked to load the content.
-    if (content_type_.empty() && data_source2_)
-      content_type_ = data_source2_->mime_type();
-
-    use_platform_media_pipeline =
-        media::IPCDemuxer::CanPlayType(content_type_,
-            data_source2_ ? data_source2_->url() : GURL());
-
-    if (use_platform_media_pipeline &&
-        !IsPlatformMediaPipelineAvailable(PlatformMediaCheckType::BASIC)) {
-      pipeline_stats::ReportNoPlatformSupport();
-      use_platform_media_pipeline = false;
-    }
-
-    scoped_ptr<media::IPCMediaPipelineHost> ipc_media_pipeline_host;
-    if (use_platform_media_pipeline) {
-      ipc_media_pipeline_host =
-          ipc_media_pipeline_host_creator_.Run(media_task_runner_,
-                                               data_source_.get());
-      use_platform_media_pipeline = (ipc_media_pipeline_host.get() != NULL);
-      if (ipc_media_pipeline_host) {
-        platform_pipeline_enlarges_buffers_on_underflow =
-            ipc_media_pipeline_host->PlatformEnlargesBuffersOnUnderflow();
-      } else {
-        pipeline_stats::ReportNoGpuProcess();
-        use_platform_media_pipeline = false;
-      }
-    }
-
-    if (use_platform_media_pipeline) {
-      if (data_source2_)
-        data_source2_->SetTargetBufferDuration(
-          ipc_media_pipeline_host->GetTargetBufferDurationBehind(),
-          ipc_media_pipeline_host->GetTargetBufferDurationAhead());
-      ipc_demuxer_ = new media::IPCDemuxer(
-          media_task_runner_, data_source_.get(),
-          std::move(ipc_media_pipeline_host), content_type_,
-          data_source2_ ? data_source2_->url() : GURL(), media_log_);
-      demuxer_.reset(ipc_demuxer_);
-#if defined(OS_MACOSX)
-    } else if (media::CoreAudioDemuxer::IsSupported(content_type_,
-          data_source2_ ? data_source2_->url() : GURL())) {
-      demuxer_.reset(new media::CoreAudioDemuxer(data_source_.get()));
-#endif  // defined(OS_MACOSX)
-    } else {
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
 #if !defined(MEDIA_DISABLE_FFMPEG)
     Demuxer::MediaTracksUpdatedCB media_tracks_updated_cb =
         BIND_TO_RENDER_LOOP(&WebMediaPlayerImpl::OnFFmpegMediaTracksUpdated);
@@ -1372,10 +1271,6 @@ void WebMediaPlayerImpl::StartPipeline() {
     OnPipelineError(PipelineStatus::DEMUXER_ERROR_COULD_NOT_OPEN);
     return;
 #endif
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    }
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
   } else {
     DCHECK(!chunk_demuxer_);
     DCHECK(!data_source_);
@@ -1481,22 +1376,6 @@ void WebMediaPlayerImpl::OnOpacityChanged(bool opaque) {
     video_weblayer_->layer()->SetContentsOpaque(opaque_);
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-void WebMediaPlayerImpl::SniffProtocol() {
-  protocol_sniffer_.SniffProtocol(
-      data_source_.get(),
-      base::Bind(&WebMediaPlayerImpl::ProtocolSniffed, AsWeakPtr()));
-}
-
-void WebMediaPlayerImpl::ProtocolSniffed(const std::string& mime_type) {
-  DVLOG(1) << __FUNCTION__ << "(" << mime_type << ")";
-  if (!mime_type.empty())
-    content_type_ = mime_type;
-
-  StartPipeline();
-}
-#endif
-
 static void GetCurrentFrameAndSignal(
     VideoFrameCompositor* compositor,
     scoped_refptr<VideoFrame>* video_frame_out,
diff --git a/media/blink/webmediaplayer_impl.h b/media/blink/webmediaplayer_impl.h
index 7f61f0d..f9c66f4 100644
--- a/media/blink/webmediaplayer_impl.h
+++ b/media/blink/webmediaplayer_impl.h
@@ -43,11 +43,6 @@
 #include "media/blink/webmediaplayer_cast_android.h"
 #endif
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/filters/ipc_media_pipeline_host.h"
-#include "media/filters/protocol_sniffer.h"
-#endif
-
 namespace blink {
 class WebLocalFrame;
 class WebMediaPlayerClient;
@@ -73,7 +68,6 @@ namespace media {
 class AudioHardwareConfig;
 class ChunkDemuxer;
 class GpuVideoAcceleratorFactories;
-class IPCDemuxer;
 class MediaLog;
 class UrlIndex;
 class VideoFrameCompositor;
@@ -282,11 +276,6 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl
   // painted.
   void FrameReady(const scoped_refptr<VideoFrame>& frame);
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  void SniffProtocol();
-  void ProtocolSniffed(const std::string& mime_type);
-#endif
-
   // Returns the current video frame from |compositor_|. Blocks until the
   // compositor can return the frame.
   scoped_refptr<VideoFrame> GetCurrentFrameFromCompositor();
@@ -453,16 +442,6 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl
   WebMediaPlayerParams::AdjustAllocatedMemoryCB adjust_allocated_memory_cb_;
   int64_t last_reported_memory_usage_;
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  // Creates object used for decoding media files with platform
-  // frameworks.
-  IPCMediaPipelineHost::Creator ipc_media_pipeline_host_creator_;
-
-  IPCDemuxer* ipc_demuxer_;
-
-  ProtocolSniffer protocol_sniffer_;
-#endif
-
   // Routes audio playback to either AudioRendererSink or WebAudio.
   scoped_refptr<WebAudioSourceProviderImpl> audio_source_provider_;
 
@@ -477,7 +456,6 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl
   scoped_ptr<BufferedDataSourceInterface> data_source_;
   scoped_ptr<Demuxer> demuxer_;
   ChunkDemuxer* chunk_demuxer_;
-  BufferedDataSource* data_source2_;
 
   BufferedDataSourceHostImpl buffered_data_source_host_;
   linked_ptr<UrlIndex> url_index_;
@@ -491,8 +469,6 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl
   // playback.
   scoped_ptr<cc_blink::WebLayerImpl> video_weblayer_;
 
-  std::string content_type_;
-
   scoped_ptr<blink::WebContentDecryptionModuleResult> set_cdm_result_;
 
   // Whether a CDM has been successfully attached.
diff --git a/media/blink/webmediaplayer_params.cc b/media/blink/webmediaplayer_params.cc
index 43d2e57..9ad3ba2 100644
--- a/media/blink/webmediaplayer_params.cc
+++ b/media/blink/webmediaplayer_params.cc
@@ -15,9 +15,6 @@ WebMediaPlayerParams::WebMediaPlayerParams(
     const DeferLoadCB& defer_load_cb,
     const scoped_refptr<SwitchableAudioRendererSink>& audio_renderer_sink,
     const scoped_refptr<MediaLog>& media_log,
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    const IPCMediaPipelineHost::Creator& ipc_media_pipeline_host_creator,
-#endif
     const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner,
     const scoped_refptr<base::TaskRunner>& worker_task_runner,
     const scoped_refptr<base::SingleThreadTaskRunner>& compositor_task_runner,
@@ -29,9 +26,6 @@ WebMediaPlayerParams::WebMediaPlayerParams(
     : defer_load_cb_(defer_load_cb),
       audio_renderer_sink_(audio_renderer_sink),
       media_log_(media_log),
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-      ipc_media_pipeline_host_creator_(ipc_media_pipeline_host_creator),
-#endif
       media_task_runner_(media_task_runner),
       worker_task_runner_(worker_task_runner),
       compositor_task_runner_(compositor_task_runner),
diff --git a/media/blink/webmediaplayer_params.h b/media/blink/webmediaplayer_params.h
index 9e164e5..4041301 100644
--- a/media/blink/webmediaplayer_params.h
+++ b/media/blink/webmediaplayer_params.h
@@ -13,10 +13,6 @@
 #include "media/blink/media_blink_export.h"
 #include "media/filters/context_3d.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/filters/ipc_media_pipeline_host.h"
-#endif
-
 namespace base {
 class SingleThreadTaskRunner;
 class TaskRunner;
@@ -54,9 +50,6 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerParams {
       const DeferLoadCB& defer_load_cb,
       const scoped_refptr<SwitchableAudioRendererSink>& audio_renderer_sink,
       const scoped_refptr<MediaLog>& media_log,
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-      const IPCMediaPipelineHost::Creator& ipc_media_pipeline_host_creator,
-#endif
       const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner,
       const scoped_refptr<base::TaskRunner>& worker_task_runner,
       const scoped_refptr<base::SingleThreadTaskRunner>& compositor_task_runner,
@@ -79,12 +72,6 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerParams {
     return media_log_;
   }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  media::IPCMediaPipelineHost::Creator ipc_media_pipeline_host_creator() const {
-    return ipc_media_pipeline_host_creator_;
-  }
-#endif
-
   const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner() const {
     return media_task_runner_;
   }
@@ -116,9 +103,6 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerParams {
   DeferLoadCB defer_load_cb_;
   scoped_refptr<SwitchableAudioRendererSink> audio_renderer_sink_;
   scoped_refptr<MediaLog> media_log_;
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  IPCMediaPipelineHost::Creator ipc_media_pipeline_host_creator_;
-#endif
   scoped_refptr<base::SingleThreadTaskRunner> media_task_runner_;
   scoped_refptr<base::TaskRunner> worker_task_runner_;
   scoped_refptr<base::SingleThreadTaskRunner> compositor_task_runner_;
diff --git a/media/filters/at_aac_helper.cc b/media/filters/at_aac_helper.cc
deleted file mode 100644
index 512cc8b..0000000
--- a/media/filters/at_aac_helper.cc
+++ /dev/null
@@ -1,316 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/filters/at_aac_helper.h"
-
-#include <AudioToolbox/AudioFileStream.h>
-#include <AudioToolbox/AudioFormat.h>
-
-#include <algorithm>
-#include <deque>
-
-#include "base/mac/mac_logging.h"
-#include "base/mac/scoped_typeref.h"
-#include "media/base/audio_decoder_config.h"
-#include "media/base/decoder_buffer.h"
-#include "media/base/mac/framework_type_conversions.h"
-#include "media/formats/mpeg/adts_constants.h"
-
-namespace media {
-
-namespace {
-
-using ScopedAudioChannelLayoutPtr = ATCodecHelper::ScopedAudioChannelLayoutPtr;
-
-ScopedAudioChannelLayoutPtr GetInputChannelLayoutFromChromeChannelLayout(
-    const AudioDecoderConfig& config) {
-  ScopedAudioChannelLayoutPtr layout(
-      static_cast<AudioChannelLayout*>(malloc(sizeof(AudioChannelLayout))));
-  memset(layout.get(), 0, sizeof(AudioChannelLayout));
-  layout->mChannelLayoutTag =
-      ChromeChannelLayoutToCoreAudioTag(config.channel_layout());
-
-  return layout;
-}
-
-ScopedAudioChannelLayoutPtr ReadInputChannelLayoutFromEsds(
-    const AudioDecoderConfig& config) {
-  UInt32 channel_layout_size = 0;
-  OSStatus status = AudioFormatGetPropertyInfo(
-      kAudioFormatProperty_ChannelLayoutFromESDS, config.extra_data().size(),
-      &config.extra_data()[0], &channel_layout_size);
-  if (status != noErr) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to get channel layout info";
-    return nullptr;
-  }
-
-  ScopedAudioChannelLayoutPtr layout(
-      static_cast<AudioChannelLayout*>(malloc(channel_layout_size)));
-  status = AudioFormatGetProperty(kAudioFormatProperty_ChannelLayoutFromESDS,
-                                  config.extra_data().size(),
-                                  &config.extra_data()[0],
-                                  &channel_layout_size, layout.get());
-  if (status != noErr) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to get channel layout";
-    return nullptr;
-  }
-
-  return layout;
-}
-
-struct ScopedAudioFileStreamIDTraits {
-  static AudioFileStreamID Retain(AudioFileStreamID  stream_id) {
-    NOTREACHED() << "Only compatible with ASSUME policy";
-    return stream_id;
-  }
-  static void Release(AudioFileStreamID stream_id) {
-    AudioFileStreamClose(stream_id);
-  }
-  static AudioFileStreamID InvalidValue() { return nullptr; }
-};
-
-using ScopedAudioFileStreamID =
-    base::ScopedTypeRef<AudioFileStreamID, ScopedAudioFileStreamIDTraits>;
-
-}  // namespace
-
-// A helper class for reading audio format information from a sequence of audio
-// buffers by feeding them into an AudioFileStream.
-class ATAACHelper::AudioFormatReader {
- public:
-  AudioFormatReader() { memset(&format_, 0, sizeof(format_)); }
-
-  // Feeds data from |buffer| into |stream_| in order to let AudioToolbox
-  // determine the input format for us.  The input format arrives via the
-  // property-listener OnAudioFileStreamProperty().
-  bool ParseAndQueueBuffer(const scoped_refptr<DecoderBuffer>& buffer);
-
-  bool is_finished() const { return format_.mFormatID != 0; }
-
-  AudioStreamBasicDescription audio_format() const {
-    DCHECK(is_finished());
-    return format_;
-  }
-
-  scoped_refptr<DecoderBuffer> ReclaimQueuedBuffer();
-
- private:
-  // Used as the property-listener callback for AudioFileStreamOpen().  Upon
-  // encountering the format list property, picks the most appropriate format
-  // and stores it in |format_|.
-  static void OnAudioFileStreamProperty(void* inClientData,
-                                        AudioFileStreamID inAudioFileStream,
-                                        AudioFileStreamPropertyID inPropertyID,
-                                        UInt32* ioFlags);
-  // Used as the audio-data callback for AudioFileStreamOpen().
-  static void OnAudioFileStreamData(
-      void* inClientData,
-      UInt32 inNumberBytes,
-      UInt32 inNumberPackets,
-      const void* inInputData,
-      AudioStreamPacketDescription* inPacketDescriptions);
-
-  bool ReadFormatList();
-  bool error() const { return !stream_; }
-
-  ScopedAudioFileStreamID stream_;
-  AudioStreamBasicDescription format_;
-  std::deque<scoped_refptr<DecoderBuffer>> buffers_;
-
-  DISALLOW_COPY_AND_ASSIGN(AudioFormatReader);
-};
-
-bool ATAACHelper::AudioFormatReader::ParseAndQueueBuffer(
-    const scoped_refptr<DecoderBuffer>& buffer) {
-  DVLOG(1) << __func__;
-
-  buffers_.push_back(buffer);
-
-  if (!stream_) {
-    const OSStatus status = AudioFileStreamOpen(
-        this, &OnAudioFileStreamProperty, &OnAudioFileStreamData,
-        kAudioFileAAC_ADTSType, stream_.InitializeInto());
-    if (status != noErr) {
-      OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                                << ": Failed to open audio file stream";
-      return false;
-    }
-  }
-
-  DCHECK(stream_);
-  const OSStatus status = AudioFileStreamParseBytes(
-      stream_, buffer->data_size(), buffer->data(), 0);
-  if (status != noErr) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to parse audio file stream";
-    return false;
-  }
-
-  return !error();
-}
-
-scoped_refptr<DecoderBuffer>
-ATAACHelper::AudioFormatReader::ReclaimQueuedBuffer() {
-  DVLOG(1) << __func__;
-
-  if (buffers_.empty())
-    return nullptr;
-
-  auto result = buffers_.front();
-  buffers_.pop_front();
-  return result;
-}
-
-// static
-void ATAACHelper::AudioFormatReader::OnAudioFileStreamProperty(
-    void* inClientData,
-    AudioFileStreamID inAudioFileStream,
-    AudioFileStreamPropertyID inPropertyID,
-    UInt32* ioFlags) {
-  DVLOG(1) << __func__ << "(" << FourCCToString(inPropertyID) << ")";
-
-  if (inPropertyID != kAudioFileStreamProperty_FormatList)
-    return;
-
-  auto* format_reader = static_cast<AudioFormatReader*>(inClientData);
-  DCHECK_EQ(inAudioFileStream, format_reader->stream_.get());
-
-  if (!format_reader->ReadFormatList())
-    format_reader->stream_.reset();
-}
-
-// static
-void ATAACHelper::AudioFormatReader::OnAudioFileStreamData(
-    void* inClientData,
-    UInt32 inNumberBytes,
-    UInt32 inNumberPackets,
-    const void* inInputData,
-    AudioStreamPacketDescription* inPacketDescriptions) {
-  DVLOG(1) << __func__ << ", ignoring";
-}
-
-bool ATAACHelper::AudioFormatReader::ReadFormatList() {
-  DVLOG(1) << __func__;
-
-  UInt32 format_list_size = 0;
-  OSStatus status = AudioFileStreamGetPropertyInfo(
-      stream_, kAudioFileStreamProperty_FormatList, &format_list_size, nullptr);
-  if (status != noErr || format_list_size % sizeof(AudioFormatListItem) != 0) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to get format list count";
-    return false;
-  }
-
-  const size_t format_count = format_list_size / sizeof(AudioFormatListItem);
-  DVLOG(1) << "Found " << format_count << " formats";
-
-  scoped_ptr<AudioFormatListItem[]> format_list(
-      new AudioFormatListItem[format_count]);
-  status =
-      AudioFileStreamGetProperty(stream_, kAudioFileStreamProperty_FormatList,
-                                 &format_list_size, format_list.get());
-  if (status != noErr ||
-      format_list_size != format_count * sizeof(AudioFormatListItem)) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to get format list";
-    return false;
-  }
-
-  UInt32 format_index = 0;
-  UInt32 format_index_size = sizeof(format_index);
-  status = AudioFormatGetProperty(
-      kAudioFormatProperty_FirstPlayableFormatFromList, format_list_size,
-      format_list.get(), &format_index_size, &format_index);
-  if (status != noErr) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to get format from list";
-    return false;
-  }
-
-  format_ = format_list[format_index].mASBD;
-
-  if (format_.mFormatID != 0) {
-    DVLOG(1) << "mSampleRate = " << format_.mSampleRate;
-    DVLOG(1) << "mFormatID = " << FourCCToString(format_.mFormatID);
-    DVLOG(1) << "mFormatFlags = " << format_.mFormatFlags;
-    DVLOG(1) << "mChannelsPerFrame = " << format_.mChannelsPerFrame;
-  }
-
-  return true;
-}
-
-ATAACHelper::ATAACHelper() : input_format_reader_(new AudioFormatReader) {}
-
-ATAACHelper::~ATAACHelper() = default;
-
-bool ATAACHelper::Initialize(const AudioDecoderConfig& config,
-                             const InputFormatKnownCB& input_format_known_cb,
-                             const ConvertAudioCB& convert_audio_cb) {
-  DCHECK_EQ(0, config.codec_delay());
-
-  input_format_known_cb_ = input_format_known_cb;
-  convert_audio_cb_ = convert_audio_cb;
-
-  // Prefer to let Audio Toolbox figure out the channel layout from the ESDS
-  // itself.  Fall back to the layout specified by AudioDecoderConfig.
-  input_channel_layout_ = ReadInputChannelLayoutFromEsds(config);
-  if (!input_channel_layout_) {
-    input_channel_layout_ =
-        GetInputChannelLayoutFromChromeChannelLayout(config);
-  }
-
-  // We are not fully initialized yet, because the input format is still not
-  // known.  We will figure it out from the audio stream itself in
-  // ProcessBuffer() and only then invoke |input_format_known_cb_|.
-
-  return true;
-}
-
-bool ATAACHelper::ProcessBuffer(const scoped_refptr<DecoderBuffer>& buffer) {
-  if (!is_input_format_known())
-    return !buffer->end_of_stream() ? ReadInputFormat(buffer) : true;
-
-  return ConvertAudio(buffer);
-}
-
-bool ATAACHelper::ReadInputFormat(const scoped_refptr<DecoderBuffer>& buffer) {
-  if (!input_format_reader_->ParseAndQueueBuffer(buffer))
-    return false;
-
-  if (!input_format_reader_->is_finished())
-    // Must parse more audio stream bytes.  Try again with the next call to
-    // ProcessBuffer().
-    return true;
-
-  if (!input_format_known_cb_.Run(input_format_reader_->audio_format(),
-                                  std::move(input_channel_layout_)))
-    return false;
-
-  // Consume any input buffers queued in |input_format_reader_|.
-  while (const scoped_refptr<DecoderBuffer> queued_buffer =
-             input_format_reader_->ReclaimQueuedBuffer()) {
-    if (!ConvertAudio(queued_buffer))
-      return false;
-  }
-
-  input_format_reader_.reset();
-  return true;
-}
-
-bool ATAACHelper::ConvertAudio(const scoped_refptr<DecoderBuffer>& buffer) {
-  // The actual frame count is supposed to be 1024, or 960 in rare cases.
-  // Prepare for twice as much to allow for SBR: With Spectral Band
-  // Replication, the output sampling rate is twice the input sapmling rate,
-  // leading to twice as much output data.
-  const size_t kMaxOutputFrameCount = kSamplesPerAACFrame * 2;
-
-  return convert_audio_cb_.Run(buffer, kADTSHeaderMinSize,
-                               kMaxOutputFrameCount);
-}
-
-}  // namespace media
diff --git a/media/filters/at_aac_helper.h b/media/filters/at_aac_helper.h
deleted file mode 100644
index cd33cc2..0000000
--- a/media/filters/at_aac_helper.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_FILTERS_AT_AAC_HELPER_H_
-#define MEDIA_FILTERS_AT_AAC_HELPER_H_
-
-#include "media/filters/at_codec_helper.h"
-
-namespace media {
-
-class ATAACHelper final : public ATCodecHelper {
- public:
-  ATAACHelper();
-  ~ATAACHelper() override;
-
-  bool Initialize(const AudioDecoderConfig& config,
-                  const InputFormatKnownCB& input_format_known_cb,
-                  const ConvertAudioCB& convert_audio_cb) override;
-  bool ProcessBuffer(const scoped_refptr<DecoderBuffer>& buffer) override;
-
- private:
-  class AudioFormatReader;
-
-  bool ReadInputFormat(const scoped_refptr<DecoderBuffer>& buffer);
-  bool ConvertAudio(const scoped_refptr<DecoderBuffer>& buffer);
-
-  bool is_input_format_known() const { return input_format_reader_ == nullptr; }
-
-  ConvertAudioCB convert_audio_cb_;
-  InputFormatKnownCB input_format_known_cb_;
-  ScopedAudioChannelLayoutPtr input_channel_layout_;
-  scoped_ptr<AudioFormatReader> input_format_reader_;
-
-  DISALLOW_COPY_AND_ASSIGN(ATAACHelper);
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_AT_AAC_HELPER_H_
diff --git a/media/filters/at_audio_decoder.cc b/media/filters/at_audio_decoder.cc
deleted file mode 100644
index bddec8d..0000000
--- a/media/filters/at_audio_decoder.cc
+++ /dev/null
@@ -1,435 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/filters/at_audio_decoder.h"
-
-#include <algorithm>
-#include <AudioToolbox/AudioToolbox.h>
-
-#include "base/bind.h"
-#include "base/features/features.h"
-#include "base/location.h"
-#include "base/mac/mac_logging.h"
-#include "base/mac/mac_util.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/single_thread_task_runner.h"
-#include "media/base/audio_buffer.h"
-#include "media/base/audio_discard_helper.h"
-#include "media/base/demuxer_stream.h"
-#include "media/base/mac/framework_type_conversions.h"
-#include "media/base/pipeline_stats.h"
-#include "media/base/platform_mime_util.h"
-#include "media/filters/at_aac_helper.h"
-#include "media/filters/at_mp3_helper.h"
-
-namespace media {
-
-namespace {
-
-const SampleFormat kOutputSampleFormat = kSampleFormatF32;
-
-// Custom error codes returned from ProvideData() and passed on to the caller
-// of AudioConverterFillComplexBuffer().
-const OSStatus kDataConsumed = 'CNSM';   // No more input data currently.
-const OSStatus kInvalidArgs = 'IVLD';    // Unexpected callback arguments.
-
-struct ScopedAudioFileStreamIDTraits {
-  static AudioFileStreamID Retain(AudioFileStreamID stream_id) {
-    NOTREACHED() << "Only compatible with ASSUME policy";
-    return stream_id;
-  }
-  static void Release(AudioFileStreamID stream_id) {
-    AudioFileStreamClose(stream_id);
-  }
-  static AudioFileStreamID InvalidValue() { return nullptr; }
-};
-
-using ScopedAudioFileStreamID =
-    base::ScopedTypeRef<AudioFileStreamID, ScopedAudioFileStreamIDTraits>;
-
-// Wraps an input buffer and some metadata.  Used as the type of the user data
-// passed between the caller of AudioConverterFillComplexBuffer() and the
-// ProvideData() callback.
-struct InputData {
-  // Strip the ADTS header from the buffer.  Required for AudioConverter to
-  // accept the input data.
-  InputData(const DecoderBuffer& buffer, int channel_count, size_t header_size)
-      : data(buffer.data() + header_size),
-        data_size(buffer.data_size() - header_size),
-        channel_count(channel_count),
-        packet_description({0}),
-        consumed(false) {
-    DCHECK_GE((int) buffer.data_size(), base::checked_cast<int>(header_size));
-    packet_description.mDataByteSize = data_size;
-  }
-
-  // Constructs an InputData object representing "no data".
-  InputData()
-      : data(nullptr),
-        data_size(0),
-        channel_count(0),
-        packet_description({0}),
-        consumed(false) {}
-
-  const void* data;
-  size_t data_size;
-  int channel_count;
-  AudioStreamPacketDescription packet_description;
-  bool consumed;
-};
-
-// Used as the data-supply callback for AudioConverterFillComplexBuffer().
-OSStatus ProvideData(AudioConverterRef inAudioConverter,
-                     UInt32* ioNumberDataPackets,
-                     AudioBufferList* ioData,
-                     AudioStreamPacketDescription** outDataPacketDescription,
-                     void* inUserData) {
-  DVLOG(5) << "AudioConverter wants " << *ioNumberDataPackets
-           << " input frames";
-
-  InputData* const input_data = reinterpret_cast<InputData*>(inUserData);
-  DCHECK(input_data);
-  if (input_data->consumed) {
-    DVLOG(5) << "But there is no more input data";
-    *ioNumberDataPackets = 0;
-    return kDataConsumed;
-  }
-
-  if (ioData->mNumberBuffers != 1u) {
-    DVLOG(1) << "Expected 1 output buffer, got " << ioData->mNumberBuffers;
-    return kInvalidArgs;
-  }
-
-  DVLOG(5) << "Providing " << input_data->data_size << " bytes";
-
-  ioData->mBuffers[0].mNumberChannels = input_data->channel_count;
-  ioData->mBuffers[0].mDataByteSize = input_data->data_size;
-  ioData->mBuffers[0].mData = const_cast<void*>(input_data->data);
-
-  if (outDataPacketDescription)
-    *outDataPacketDescription = &input_data->packet_description;
-
-  input_data->consumed = true;
-  return noErr;
-}
-
-scoped_ptr<ATCodecHelper> CreateCodecHelper(AudioCodec codec) {
-  switch (codec) {
-    case kCodecAAC:
-      return make_scoped_ptr(new ATAACHelper);
-    case kCodecMP3:
-      return base::IsFeatureEnabled(base::kFeatureMseAudioMpegAac)
-                 ? make_scoped_ptr(new ATMP3Helper)
-                 : nullptr;
-    default:
-      return nullptr;
-  }
-}
-
-// Fills out the output format to meet Chrome pipeline requirements.
-void GetOutputFormat(const AudioStreamBasicDescription& input_format,
-                     AudioStreamBasicDescription* output_format) {
-  DVLOG(1) << __func__;
-
-  memset(output_format, 0, sizeof(*output_format));
-  output_format->mFormatID = kAudioFormatLinearPCM;
-  output_format->mFormatFlags = kLinearPCMFormatFlagIsFloat;
-  output_format->mSampleRate = input_format.mSampleRate;
-  output_format->mChannelsPerFrame = input_format.mChannelsPerFrame;
-  output_format->mBitsPerChannel = 32;
-  output_format->mBytesPerFrame =
-      output_format->mChannelsPerFrame * output_format->mBitsPerChannel / 8;
-  output_format->mFramesPerPacket = 1;
-  output_format->mBytesPerPacket = output_format->mBytesPerFrame;
-}
-
-// Adds |padding_frame_count| frames of silence to the front of |buffer| and
-// returns the resulting buffer.  This is used when we need to "fix" the
-// behavior of AudioConverter wrt codec delay handling.  If AudioConverter
-// strips the codec delay internally, it's all fine unless we are decoding
-// audio appended via MSE.  In this case, only the initial delay gets stripped,
-// and the one after the append is not.  AudioDiscardHelper can do the
-// stripping for us, using discard information from FrameProcessor, but then
-// the codec delay must be present in the initial output buffer too, hence the
-// padding that we're adding.
-scoped_refptr<AudioBuffer> AddFrontPadding(
-    const scoped_refptr<AudioBuffer>& buffer,
-    size_t padding_frame_count) {
-  DVLOG(1) << __func__;
-
-  const scoped_refptr<AudioBuffer> result = AudioBuffer::CreateBuffer(
-      kOutputSampleFormat, buffer->channel_layout(), buffer->channel_count(),
-      buffer->sample_rate(), padding_frame_count + buffer->frame_count());
-
-  const size_t padding_size =
-      padding_frame_count * buffer->channel_count() *
-      SampleFormatToBytesPerChannel(kOutputSampleFormat);
-  uint8_t* const result_data = result->channel_data()[0];
-  std::fill(result_data, result_data + padding_size, 0);
-
-  uint8_t* const buffer_data = buffer->channel_data()[0];
-  const size_t buffer_size = buffer->frame_count() * buffer->channel_count() *
-                             SampleFormatToBytesPerChannel(kOutputSampleFormat);
-  std::copy(buffer_data, buffer_data + buffer_size, result_data + padding_size);
-
-  return result;
-}
-
-}  // namespace
-
-
-// static
-AudioConverterRef ATAudioDecoder::ScopedAudioConverterRefTraits::Retain(
-    AudioConverterRef converter) {
-  NOTREACHED() << "Only compatible with ASSUME policy";
-  return converter;
-}
-
-// static
-void ATAudioDecoder::ScopedAudioConverterRefTraits::Release(
-    AudioConverterRef converter) {
-  const OSStatus status = AudioConverterDispose(converter);
-  if (status != noErr)
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to dispose of AudioConverter";
-}
-
-AudioConverterRef ATAudioDecoder::ScopedAudioConverterRefTraits::InvalidValue() {
-  return nullptr;
-}
-
-ATAudioDecoder::ATAudioDecoder(
-    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner)
-    : task_runner_(task_runner),
-      needs_eos_workaround_(base::mac::IsOSMavericksOrEarlier()) {}
-
-ATAudioDecoder::~ATAudioDecoder() = default;
-
-std::string ATAudioDecoder::GetDisplayName() const {
-  return "ATAudioDecoder";
-}
-
-void ATAudioDecoder::Initialize(const AudioDecoderConfig& config,
-                                CdmContext* cdm_context,
-                                const InitCB& init_cb,
-                                const OutputCB& output_cb) {
-  DVLOG(1) << __func__;
-  DCHECK(task_runner_->BelongsToCurrentThread());
-  DCHECK(config.IsValidConfig());
-
-  pipeline_stats::AddDecoderClass(GetDisplayName());
-
-  codec_helper_ = CreateCodecHelper(config.codec());
-  if (!codec_helper_) {
-    DVLOG(1) << "Unsupported codec: " << config.codec();
-    task_runner_->PostTask(FROM_HERE, base::Bind(init_cb, false));
-    return;
-  }
-
-  if (!IsPlatformAudioDecoderAvailable(config.codec())) {
-    task_runner_->PostTask(FROM_HERE, base::Bind(init_cb, false));
-    return;
-  }
-
-  // This decoder supports re-initialization.
-  converter_.reset();
-
-  config_ = config;
-  output_cb_ = output_cb;
-
-  ResetTimestampState();
-
-  // Unretained() is safe, because ATCodecHelper is required to invoke the
-  // callbacks synchronously.
-  if (!codec_helper_->Initialize(
-          config, base::Bind(&ATAudioDecoder::InitializeConverter,
-                             base::Unretained(this)),
-          base::Bind(&ATAudioDecoder::ConvertAudio, base::Unretained(this)))) {
-    pipeline_stats::ReportAudioDecoderInitResult(false);
-    task_runner_->PostTask(FROM_HERE, base::Bind(init_cb, false));
-    return;
-  }
-
-  pipeline_stats::ReportAudioDecoderInitResult(true);
-  task_runner_->PostTask(FROM_HERE, base::Bind(init_cb, true));
-}
-
-void ATAudioDecoder::Decode(const scoped_refptr<DecoderBuffer>& buffer,
-                            const DecodeCB& decode_cb) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  const media::DecodeStatus status =
-      codec_helper_->ProcessBuffer(buffer) ? media::DecodeStatus::OK : media::DecodeStatus::DECODE_ERROR;
-
-  task_runner_->PostTask(FROM_HERE, base::Bind(decode_cb, status));
-}
-
-void ATAudioDecoder::Reset(const base::Closure& closure) {
-  DVLOG(1) << __func__;
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  // There is no |converter_| if Reset() is called before Decode(), which is
-  // legal.
-  if (converter_) {
-    const OSStatus status = AudioConverterReset(converter_);
-    if (status != noErr)
-      OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                                << ": Failed to reset AudioConverter";
-  }
-
-  ResetTimestampState();
-
-  task_runner_->PostTask(FROM_HERE, closure);
-}
-
-bool ATAudioDecoder::InitializeConverter(
-    const AudioStreamBasicDescription& input_format,
-    ScopedAudioChannelLayoutPtr input_channel_layout) {
-  DVLOG(1) << __func__;
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  AudioStreamBasicDescription output_format;
-  GetOutputFormat(input_format, &output_format);
-
-  OSStatus status = AudioConverterNew(&input_format, &output_format,
-                                      converter_.InitializeInto());
-  if (status != noErr) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to create AudioConverter";
-    return false;
-  }
-
-  status = AudioConverterSetProperty(
-      converter_, kAudioConverterInputChannelLayout,
-      sizeof(*input_channel_layout), input_channel_layout.get());
-  if (status != noErr) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to set input channel layout";
-    return false;
-  }
-
-  AudioChannelLayout output_channel_layout = {0};
-  output_channel_layout.mChannelLayoutTag =
-      ChromeChannelLayoutToCoreAudioTag(config_.channel_layout());
-  status = AudioConverterSetProperty(
-      converter_, kAudioConverterOutputChannelLayout,
-      sizeof(output_channel_layout), &output_channel_layout);
-  if (status != noErr) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to set output channel layout";
-    return false;
-  }
-
-  return true;
-}
-
-bool ATAudioDecoder::ConvertAudio(const scoped_refptr<DecoderBuffer>& input,
-                                  size_t header_size,
-                                  size_t max_output_frame_count) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-  DCHECK(converter_);
-
-  UInt32 output_frame_count = max_output_frame_count;
-
-  // Pre-allocate a buffer for the maximum expected frame count.  We will let
-  // the AudioConverter fill it with decoded audio, through |output_buffers|
-  // defined below.
-  scoped_refptr<AudioBuffer> output = AudioBuffer::CreateBuffer(
-      kOutputSampleFormat, config_.channel_layout(),
-      ChannelLayoutToChannelCount(config_.channel_layout()),
-      config_.samples_per_second(), output_frame_count);
-
-  InputData input_data =
-      input->end_of_stream()
-          // No more input data, but we must flush AudioConverter.
-          ? InputData()
-          // Will provide data from |input| to AudioConverter in ProvideData().
-          : InputData(*input, output->channel_count(), header_size);
-
-  AudioBufferList output_buffers;
-  output_buffers.mNumberBuffers = 1;
-  output_buffers.mBuffers[0].mNumberChannels = output->channel_count();
-  output_buffers.mBuffers[0].mDataByteSize =
-      output->frame_count() * output->channel_count() *
-      SampleFormatToBytesPerChannel(kOutputSampleFormat);
-  // Will put decoded data in the |output| media::AudioBuffer directly.
-  output_buffers.mBuffers[0].mData = output->channel_data()[0];
-
-  AudioStreamPacketDescription
-      output_packet_descriptions[max_output_frame_count];
-
-  OSStatus status = noErr;
-  if (ApplyEOSWorkaround(input, &output_buffers)) {
-    DVLOG(1)
-        << "Couldn't flush AudioConverter properly on this system. Faking it";
-  } else {
-    status = AudioConverterFillComplexBuffer(
-        converter_, &ProvideData, &input_data, &output_frame_count,
-        &output_buffers, output_packet_descriptions);
-  }
-
-  if (status != noErr && status != kDataConsumed) {
-    OSSTATUS_DVLOG(1, status) << FourCCToString(status)
-                              << ": Failed to convert audio";
-    return false;
-  }
-
-  if (output_frame_count > max_output_frame_count) {
-    DVLOG(1) << "Unexpected output sample count: " << output_frame_count;
-    return false;
-  }
-
-  if (!input->end_of_stream())
-    queued_input_.push_back(input);
-
-  if (output_frame_count > 0 && !queued_input_.empty()) {
-    output->TrimEnd(max_output_frame_count - output_frame_count);
-
-    const scoped_refptr<DecoderBuffer> dequeued_input = queued_input_.front();
-    queued_input_.pop_front();
-
-    const bool first_output_buffer = !discard_helper_->initialized();
-    if (first_output_buffer)
-      output = AddFrontPadding(output, config_.codec_delay());
-
-    DVLOG(5) << "Decoded " << output_frame_count << " frames @"
-             << dequeued_input->timestamp();
-
-    // ProcessBuffers() computes and sets the timestamp on |output|.
-    if (discard_helper_->ProcessBuffers(dequeued_input, output))
-      task_runner_->PostTask(FROM_HERE, base::Bind(output_cb_, output));
-  }
-
-  return true;
-}
-
-bool ATAudioDecoder::ApplyEOSWorkaround(
-    const scoped_refptr<DecoderBuffer>& input,
-    AudioBufferList* output_buffers) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  if (!needs_eos_workaround_ || !input->end_of_stream())
-    return false;
-
-  uint8_t* const data =
-      reinterpret_cast<uint8_t*>(output_buffers->mBuffers[0].mData);
-  const size_t data_size = output_buffers->mBuffers[0].mDataByteSize;
-  std::fill(data, data + data_size, 0);
-
-  return true;
-}
-
-void ATAudioDecoder::ResetTimestampState() {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  discard_helper_.reset(new AudioDiscardHelper(config_.samples_per_second(),
-                                               config_.codec_delay()));
-  discard_helper_->Reset(config_.codec_delay());
-
-  queued_input_.clear();
-}
-
-}  // namespace media
diff --git a/media/filters/at_audio_decoder.h b/media/filters/at_audio_decoder.h
deleted file mode 100644
index 7a140a5..0000000
--- a/media/filters/at_audio_decoder.h
+++ /dev/null
@@ -1,91 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_FILTERS_AT_AUDIO_DECODER_H_
-#define MEDIA_FILTERS_AT_AUDIO_DECODER_H_
-
-#include <AudioToolbox/AudioConverter.h>
-
-#include <deque>
-#include <string>
-
-#include "base/mac/scoped_typeref.h"
-#include "media/base/audio_decoder.h"
-#include "media/filters/at_codec_helper.h"
-
-namespace base {
-class SingleThreadTaskRunner;
-}
-
-namespace media {
-
-class AudioDiscardHelper;
-
-// An AudioDecoder that uses Apple's AudioToolbox to decode audio.
-//
-// Once initialized, the decoding can proceed in the same manner for all
-// currently supported codecs.  The initialization part is highly
-// codec-dependent, though.  That's why this part of the decoder is moved to
-// dedicated implementations of ATCodecHelper.
-class MEDIA_EXPORT ATAudioDecoder : public AudioDecoder {
- public:
-  explicit ATAudioDecoder(
-      const scoped_refptr<base::SingleThreadTaskRunner>& task_runner);
-  ~ATAudioDecoder() override;
-
-  // AudioDecoder implementation.
-  std::string GetDisplayName() const override;
-  void Initialize(const AudioDecoderConfig& config,
-                  CdmContext* cdm_context,
-                  const InitCB& init_cb,
-                  const OutputCB& output_cb) override;
-  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
-              const DecodeCB& decode_cb) override;
-  void Reset(const base::Closure& closure) override;
-
- private:
-  using ScopedAudioChannelLayoutPtr =
-      ATCodecHelper::ScopedAudioChannelLayoutPtr;
-
-  struct ScopedAudioConverterRefTraits {
-    static AudioConverterRef Retain(AudioConverterRef converter);
-    static void Release(AudioConverterRef converter);
-    static AudioConverterRef InvalidValue();
-  };
-  using ScopedAudioConverterRef =
-      base::ScopedTypeRef<AudioConverterRef, ScopedAudioConverterRefTraits>;
-
-  bool InitializeConverter(const AudioStreamBasicDescription& input_format,
-                           ScopedAudioChannelLayoutPtr input_channel_layout);
-
-  bool ConvertAudio(const scoped_refptr<DecoderBuffer>& input,
-                    size_t header_size,
-                    size_t max_output_frame_count);
-
-  // On older systems, we don't know how to flush AudioConverter properly, so
-  // we fake it by generating a trailing silent buffer.  Returns true if the
-  // workaround has been applied.
-  bool ApplyEOSWorkaround(const scoped_refptr<DecoderBuffer>& input,
-                          AudioBufferList* output_buffers);
-
-  void ResetTimestampState();
-
-  const scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-
-  AudioDecoderConfig config_;
-  scoped_ptr<ATCodecHelper> codec_helper_;
-  ScopedAudioConverterRef converter_;
-  std::deque<scoped_refptr<DecoderBuffer>> queued_input_;
-  scoped_ptr<AudioDiscardHelper> discard_helper_;
-  const bool needs_eos_workaround_;
-  OutputCB output_cb_;
-
-  DISALLOW_COPY_AND_ASSIGN(ATAudioDecoder);
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_AT_AUDIO_DECODER_H_
diff --git a/media/filters/at_codec_helper.h b/media/filters/at_codec_helper.h
deleted file mode 100644
index 6ee739e..0000000
--- a/media/filters/at_codec_helper.h
+++ /dev/null
@@ -1,59 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_FILTERS_AT_CODEC_HELPER_H_
-#define MEDIA_FILTERS_AT_CODEC_HELPER_H_
-
-#include "base/callback.h"
-#include "base/memory/free_deleter.h"
-#include "base/memory/scoped_ptr.h"
-
-struct AudioChannelLayout;
-struct AudioStreamBasicDescription;
-
-namespace media {
-
-class AudioDecoderConfig;
-class DecoderBuffer;
-
-// Responsible for codec-specific tasks of an audio decoder based on Apple's
-// AudioToolbox.
-class ATCodecHelper {
- public:
-  using ScopedAudioChannelLayoutPtr =
-      scoped_ptr<AudioChannelLayout, base::FreeDeleter>;
-
-  // Invoked when there is enough information about the audio stream to
-  // determine the exact format.  Returns false on failure.
-  using InputFormatKnownCB =
-      base::Callback<bool(const AudioStreamBasicDescription& format,
-                          ScopedAudioChannelLayoutPtr input_channel_layout)>;
-
-  // Invoked every time a DecoderBuffer should be converted to an AudioBuffer.
-  // |header_size| is the number of bytes to be discarded from the beginning of
-  // |input|.  |max_output_frame_count| specifies the maximum expected number
-  // of frames of decoded audio.  Returns false on failure.
-  using ConvertAudioCB =
-      base::Callback<bool(const scoped_refptr<DecoderBuffer>& input,
-                          size_t header_size,
-                          size_t max_output_frame_count)>;
-
-  virtual ~ATCodecHelper() {}
-
-  // The callbacks must be invoked synchronously either within Initialize() or
-  // ProcessBuffer().  In particular, |input_format_known_cb| is _not_ required
-  // to be invoked within Initialize() -- some codecs require some parsing of
-  // the actual audio stream to determine the exact input format.
-  virtual bool Initialize(const AudioDecoderConfig& config,
-                          const InputFormatKnownCB& input_format_known_cb,
-                          const ConvertAudioCB& convert_audio_cb) = 0;
-
-  virtual bool ProcessBuffer(const scoped_refptr<DecoderBuffer>& buffer) = 0;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_AT_CODEC_HELPER_H_
diff --git a/media/filters/at_mp3_helper.cc b/media/filters/at_mp3_helper.cc
deleted file mode 100644
index c266995..0000000
--- a/media/filters/at_mp3_helper.cc
+++ /dev/null
@@ -1,47 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/filters/at_mp3_helper.h"
-
-#include <CoreAudio/CoreAudio.h>
-
-#include "media/base/audio_decoder_config.h"
-#include "media/base/mac/framework_type_conversions.h"
-
-namespace media {
-
-ATMP3Helper::ATMP3Helper() = default;
-
-ATMP3Helper::~ATMP3Helper() = default;
-
-bool ATMP3Helper::Initialize(const AudioDecoderConfig& config,
-                             const InputFormatKnownCB& input_format_known_cb,
-                             const ConvertAudioCB& convert_audio_cb) {
-  convert_audio_cb_ = convert_audio_cb;
-
-  AudioStreamBasicDescription format = {0};
-  format.mSampleRate = config.input_samples_per_second();
-  format.mFormatID = kAudioFormatMPEGLayer3;
-  format.mChannelsPerFrame =
-      ChannelLayoutToChannelCount(config.channel_layout());
-
-  ScopedAudioChannelLayoutPtr channel_layout(
-      static_cast<AudioChannelLayout*>(malloc(sizeof(AudioChannelLayout))));
-  memset(channel_layout.get(), 0, sizeof(AudioChannelLayout));
-  channel_layout->mChannelLayoutTag =
-      ChromeChannelLayoutToCoreAudioTag(config.channel_layout());
-
-  return input_format_known_cb.Run(format, std::move(channel_layout));
-}
-
-bool ATMP3Helper::ProcessBuffer(const scoped_refptr<DecoderBuffer>& buffer) {
-  // http://teslabs.com/openplayer/docs/docs/specs/mp3_structure2.pdf
-  const size_t kMaxOutputFrameCount = 1152;
-
-  return convert_audio_cb_.Run(buffer, 0, kMaxOutputFrameCount);
-}
-
-}  // namespace media
diff --git a/media/filters/at_mp3_helper.h b/media/filters/at_mp3_helper.h
deleted file mode 100644
index ec53da7..0000000
--- a/media/filters/at_mp3_helper.h
+++ /dev/null
@@ -1,32 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_FILTERS_AT_MP3_HELPER_H_
-#define MEDIA_FILTERS_AT_MP3_HELPER_H_
-
-#include "media/filters/at_codec_helper.h"
-
-namespace media {
-
-class ATMP3Helper final : public ATCodecHelper {
- public:
-  ATMP3Helper();
-  ~ATMP3Helper() override;
-
-  bool Initialize(const AudioDecoderConfig& config,
-                  const InputFormatKnownCB& input_format_known_cb,
-                  const ConvertAudioCB& convert_audio_cb) override;
-  bool ProcessBuffer(const scoped_refptr<DecoderBuffer>& buffer) override;
-
- private:
-  ConvertAudioCB convert_audio_cb_;
-
-  DISALLOW_COPY_AND_ASSIGN(ATMP3Helper);
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_AT_MP3_HELPER_H_
diff --git a/media/filters/audio_decoder_unittest.cc b/media/filters/audio_decoder_unittest.cc
index 62edaae8..ec19b80 100644
--- a/media/filters/audio_decoder_unittest.cc
+++ b/media/filters/audio_decoder_unittest.cc
@@ -2,12 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-// USE_SYSTEM_PROPRIETARY_CODECS requires a different test setup, see
-// PlatformMediaPipelineIntegrationTest.
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#undef USE_PROPRIETARY_CODECS
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 #include <stddef.h>
 #include <stdint.h>
 
diff --git a/media/filters/audio_file_reader.cc b/media/filters/audio_file_reader.cc
index 160615d..978f3b7 100644
--- a/media/filters/audio_file_reader.cc
+++ b/media/filters/audio_file_reader.cc
@@ -13,10 +13,6 @@
 #include "media/base/audio_bus.h"
 #include "media/ffmpeg/ffmpeg_common.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/filters/ipc_audio_decoder.h"
-#endif
-
 namespace media {
 
 AudioFileReader::AudioFileReader(FFmpegURLProtocol* protocol)
@@ -33,25 +29,9 @@ AudioFileReader::~AudioFileReader() {
 }
 
 bool AudioFileReader::Open() {
-  if (!(OpenDemuxer() && OpenDecoder())) {
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    if (!media::IPCAudioDecoder::IsAvailable())
-      return false;
-
-    ipc_audio_decoder_.reset(new IPCAudioDecoder(protocol_));
-    if (!ipc_audio_decoder_->Initialize()) {
-      ipc_audio_decoder_.reset();
-      return false;
-    }
-
-    channels_ = ipc_audio_decoder_->channels();
-    sample_rate_ = ipc_audio_decoder_->sample_rate();
-#else
+  if (!OpenDemuxer())
     return false;
-#endif  // USE_SYSTEM_PROPRIETARY_CODECS
-  }
-
-  return true;
+  return OpenDecoder();
 }
 
 bool AudioFileReader::OpenDemuxer() {
@@ -138,10 +118,6 @@ void AudioFileReader::Close() {
 }
 
 int AudioFileReader::Read(AudioBus* audio_bus) {
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (ipc_audio_decoder_)
-    return ipc_audio_decoder_->Read(audio_bus);
-#endif  // USE_SYSTEM_PROPRIETARY_CODECS
   DCHECK(glue_.get() && codec_context_) <<
       "AudioFileReader::Read() : reader is not opened!";
 
@@ -271,10 +247,6 @@ base::TimeDelta AudioFileReader::GetDuration() const {
 }
 
 int AudioFileReader::GetNumberOfFrames() const {
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (ipc_audio_decoder_)
-    return ipc_audio_decoder_->number_of_frames();
-#endif  // USE_SYSTEM_PROPRIETARY_CODECS
   return static_cast<int>(ceil(GetDuration().InSecondsF() * sample_rate()));
 }
 
diff --git a/media/filters/audio_file_reader.h b/media/filters/audio_file_reader.h
index 6470e7e..818f8c4 100644
--- a/media/filters/audio_file_reader.h
+++ b/media/filters/audio_file_reader.h
@@ -20,9 +20,6 @@ namespace media {
 
 class AudioBus;
 class FFmpegURLProtocol;
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-class IPCAudioDecoder;
-#endif  // USE_SYSTEM_PROPRIETARY_CODECS
 
 class MEDIA_EXPORT AudioFileReader {
  public:
@@ -94,10 +91,6 @@ class MEDIA_EXPORT AudioFileReader {
   // AVSampleFormat initially requested; not Chrome's SampleFormat.
   int av_sample_format_;
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  scoped_ptr<IPCAudioDecoder> ipc_audio_decoder_;
-#endif  // USE_SYSTEM_PROPRIETARY_CODECS
-
   DISALLOW_COPY_AND_ASSIGN(AudioFileReader);
 };
 
diff --git a/media/filters/audio_file_reader_unittest.cc b/media/filters/audio_file_reader_unittest.cc
index bd09751..a560379 100644
--- a/media/filters/audio_file_reader_unittest.cc
+++ b/media/filters/audio_file_reader_unittest.cc
@@ -16,14 +16,6 @@
 #include "media/filters/in_memory_url_protocol.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-// This test assumes proprietary media support built into FFmpeg, which is not
-// the case when USE_SYSTEM_PROPRIETARY_CODECS is defined.
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#undef USE_PROPRIETARY_CODECS
-
-#include "media/filters/ipc_audio_decoder.h"
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 namespace media {
 
 class AudioFileReaderTest : public testing::Test {
@@ -125,9 +117,6 @@ class AudioFileReaderTest : public testing::Test {
   }
 
  protected:
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  IPCAudioDecoder::ScopedDisableForTesting ipc_audio_decoder_disabler_;
-#endif
   scoped_refptr<DecoderBuffer> data_;
   scoped_ptr<InMemoryUrlProtocol> protocol_;
   scoped_ptr<AudioFileReader> reader_;
diff --git a/media/filters/core_audio_demuxer.cc b/media/filters/core_audio_demuxer.cc
deleted file mode 100644
index 94e8824..0000000
--- a/media/filters/core_audio_demuxer.cc
+++ /dev/null
@@ -1,317 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/core_audio_demuxer.h"
-
-#include <string>
-
-#include "base/logging.h"
-#include "base/strings/string_util.h"
-#include "base/task_runner_util.h"
-#include "media/base/bind_to_current_loop.h"
-#include "media/base/mac/scoped_audio_queue_ref.h"
-#include "media/filters/blocking_url_protocol.h"
-#include "media/filters/core_audio_demuxer_stream.h"
-#include "net/base/mime_util.h"
-#include "url/gurl.h"
-
-namespace {
-
-static const char* kSupportedMimeTypes[] = {
-    "audio/aac",
-    "audio/aacp",
-    "audio/3gpp",
-    "audio/3gpp2",
-    "audio/mp3",
-    "audio/mp4",
-    "audio/mpeg",
-    "audio/mpeg3"
-};
-
-}  // namespace
-
-namespace media {
-
-CoreAudioDemuxer::CoreAudioDemuxer(DataSource* data_source)
-    : host_(NULL),
-      data_source_(data_source),
-      blocking_thread_("CoreAudioDemuxer"),
-      bit_rate_(0),
-      input_format_found_(false),
-      weak_factory_(this) {
-  DCHECK(data_source_);
-
-  url_protocol_.reset(new BlockingUrlProtocol(
-      data_source_,
-      BindToCurrentLoop(base::Bind(&CoreAudioDemuxer::OnDataSourceError,
-                                   base::Unretained(this)))));
-}
-
-CoreAudioDemuxer::~CoreAudioDemuxer() {
-}
-
-std::string CoreAudioDemuxer::GetDisplayName() const {
-  return "CoreAudioDemuxer";
-}
-
-void CoreAudioDemuxer::Initialize(DemuxerHost* host,
-                                  const PipelineStatusCB& status_cb,
-                                  bool enable_text_tracks) {
-  host_ = host;
-
-  CHECK(blocking_thread_.Start());
-  ReadAudioFormatInfo(status_cb);
-}
-
-CoreAudioDemuxerStream* CoreAudioDemuxer::CreateAudioDemuxerStream() {
-  return new CoreAudioDemuxerStream(
-      this, input_format_info_, bit_rate_, CoreAudioDemuxerStream::AUDIO);
-}
-
-void CoreAudioDemuxer::StartWaitingForSeek(base::TimeDelta seek_time) {
-}
-
-void CoreAudioDemuxer::CancelPendingSeek(base::TimeDelta seek_time) {
-}
-
-void CoreAudioDemuxer::Seek(base::TimeDelta time,
-                            const PipelineStatusCB& status_cb) {
-  if (audio_stream_->Seek(time)) {
-    status_cb.Run(PIPELINE_OK);
-    return;
-  }
-  status_cb.Run(PIPELINE_ERROR_ABORT);
-}
-
-void CoreAudioDemuxer::Stop() {
-  url_protocol_->Abort();
-
-  data_source_->Stop();
-
-  if (audio_stream_.get()) {
-    audio_stream_->Stop();
-  }
-
-  // This will block until all tasks complete.
-  blocking_thread_.Stop();
-
-  data_source_ = NULL;
-}
-
-DemuxerStream* CoreAudioDemuxer::GetStream(DemuxerStream::Type type) {
-  switch (type) {
-    case DemuxerStream::AUDIO:
-      return audio_stream_.get();
-
-    default:
-      return NULL;
-  }
-}
-
-base::TimeDelta CoreAudioDemuxer::GetStartTime() const {
-  // TODO(wdzierzanowski): Fetch actual start time from media file (DNA-27693).
-  return base::TimeDelta();
-}
-
-base::Time CoreAudioDemuxer::GetTimelineOffset() const {
-  return base::Time();
-}
-
-int64_t CoreAudioDemuxer::GetMemoryUsage() const {
-  // TODO(ckulakowski): Implement me. DNA-45936
-  return 0;
-}
-
-
-void CoreAudioDemuxer::SetAudioDuration(int64_t duration) {
-  host_->SetDuration(base::TimeDelta::FromMilliseconds(duration));
-}
-
-void CoreAudioDemuxer::ReadDataSourceWithCallback(
-    const DataSource::ReadCB& read_cb) {
-  base::PostTaskAndReplyWithResult(
-      blocking_thread_.task_runner().get(),
-      FROM_HERE,
-      base::Bind(&CoreAudioDemuxer::ReadDataSource, base::Unretained(this)),
-      read_cb);
-}
-
-void CoreAudioDemuxer::ReadAudioFormatInfo(const PipelineStatusCB& status_cb) {
-  ReadDataSourceWithCallback(
-      base::Bind(&CoreAudioDemuxer::OnReadAudioFormatInfoDone,
-                 weak_factory_.GetWeakPtr(),
-                 status_cb));
-}
-
-void CoreAudioDemuxer::OnReadAudioFormatInfoDone(
-    const PipelineStatusCB& status_cb,
-    int read_size) {
-  if (!blocking_thread_.IsRunning()) {
-    status_cb.Run(PIPELINE_ERROR_ABORT);
-    return;
-  }
-
-  if (read_size <= 0) {
-    status_cb.Run(DEMUXER_ERROR_COULD_NOT_OPEN);
-    return;
-  }
-
-  OSStatus err =
-      AudioFileStreamOpen(this,
-                          CoreAudioDemuxer::AudioPropertyListenerProc,
-                          CoreAudioDemuxer::AudioPacketsProc,
-                          kAudioFileMP3Type,
-                          &audio_stream_id_);
-  if (err == noErr) {
-    err = AudioFileStreamParseBytes(audio_stream_id_, read_size, buffer_, 0);
-    AudioFileStreamClose(audio_stream_id_);
-
-    // If audio format is not known yet, demuxer must read more data to figure
-    // it out.
-    if (!input_format_found_) {
-      ReadAudioFormatInfo(status_cb);
-      return;
-    }
-  }
-
-  if (err != noErr)
-    status_cb.Run(PIPELINE_ERROR_ABORT);
-
-  if (input_format_found_) {
-    audio_stream_.reset(CreateAudioDemuxerStream());
-    if (!audio_stream_->audio_decoder_config().IsValidConfig()) {
-      audio_stream_.reset();
-      status_cb.Run(DEMUXER_ERROR_NO_SUPPORTED_STREAMS);
-      return;
-    }
-
-    // Reset read offset to the beginning.
-    ResetDataSourceOffset();
-    status_cb.Run(PIPELINE_OK);
-  }
-}
-
-void CoreAudioDemuxer::OnDataSourceError() {
-  host_->OnDemuxerError(PIPELINE_ERROR_READ);
-}
-
-void CoreAudioDemuxer::AudioPacketsProc(
-    void* client_data,
-    UInt32 number_bytes,
-    UInt32 number_packets,
-    const void* input_data,
-    AudioStreamPacketDescription* packet_descriptions) {
-  CoreAudioDemuxer* demuxer = reinterpret_cast<CoreAudioDemuxer*>(client_data);
-  if (!demuxer->input_format_found_)
-      return;
-
-  UInt32 bit_rate_size = sizeof(UInt32);
-  OSStatus err = AudioFileStreamGetProperty(demuxer->audio_stream_id_,
-                                            kAudioFileStreamProperty_BitRate,
-                                            &bit_rate_size,
-                                            &demuxer->bit_rate_);
-  if (err == noErr) {
-    int64_t duration = 0;
-    int64_t ds_size = 0;
-    demuxer->data_source_->GetSize(&ds_size);
-    if (demuxer->bit_rate_ > 0) {
-      // some audio files gives bit_rate in 1000*bits/s, but others gives bits/s
-      // According to the ISO standard, decoders are only required to be able
-      // to decode streams up to 320, so it should be safe to calculate like
-      // below
-      if (demuxer->bit_rate_ >= 320)
-        demuxer->bit_rate_ /= 1000;
-      duration = (ds_size * 8) / demuxer->bit_rate_;
-      demuxer->bit_rate_ *= 1024;
-      demuxer->data_source_->SetBitrate(demuxer->bit_rate_);
-    }
-
-    VLOG(3) << "Audio bit rate: " << demuxer->bit_rate_
-            << ", Duration: " << duration
-            << ", Audio data source size: " << ds_size;
-    demuxer->SetAudioDuration(duration);
-  } else {
-    // We are unable to find audio length. User will be still able to play,
-    // but there is impossible to seek or display audio length in html control
-    DLOG(WARNING) << "Cannot calculate audio duration";
-  }
-}
-
-void CoreAudioDemuxer::AudioPropertyListenerProc(
-    void* client_data,
-    AudioFileStreamID audio_file_stream,
-    AudioFileStreamPropertyID property_id,
-    UInt32* io_flags) {
-  // This is called by audio file stream when it finds property values.
-  CoreAudioDemuxer* demuxer = reinterpret_cast<CoreAudioDemuxer*>(client_data);
-  OSStatus err = noErr;
-
-  char buf[] = {(static_cast<char>(property_id >> 24) & 255),
-                (static_cast<char>(property_id >> 16) & 255),
-                (static_cast<char>(property_id >> 8) & 255),
-                (static_cast<char>(property_id & 255)), 0};
-  VLOG(1) << "Found stream property " << buf;
-
-  switch (property_id) {
-    case kAudioFileStreamProperty_ReadyToProducePackets: {
-      VLOG(3) << "Ready to produce packets";
-      UInt32 asbd_size = sizeof(demuxer->input_format_info_);
-      err = AudioFileStreamGetProperty(audio_file_stream,
-                                       kAudioFileStreamProperty_DataFormat,
-                                       &asbd_size,
-                                       &demuxer->input_format_info_);
-      if (err)
-        LOG(ERROR) << "Get kAudioFileStreamProperty_DataFormat " << err;
-
-      demuxer->input_format_found_ = true;
-      break;
-    }
-  }
-}
-
-int CoreAudioDemuxer::ReadDataSource() {
-  int64_t offset = 0;
-  url_protocol_->GetPosition(&offset);
-  VLOG(1) << "ReadDataSource: at offset: " << offset;
-  return url_protocol_->Read(kStreamInfoBufferSize, buffer_);
-}
-
-void CoreAudioDemuxer::ResetDataSourceOffset() {
-  url_protocol_->SetPosition(0);
-}
-
-void CoreAudioDemuxer::ReadDataSourceIfNeeded() {
-  // Make sure we have work to do before reading.
-  if (!blocking_thread_.IsRunning()) {
-    audio_stream_->Abort();
-    return;
-  }
-
-  ReadDataSourceWithCallback(base::Bind(&CoreAudioDemuxer::OnReadDataSourceDone,
-                                        weak_factory_.GetWeakPtr()));
-}
-
-void CoreAudioDemuxer::OnReadDataSourceDone(int read_size) {
-  audio_stream_->ReadCompleted(buffer_, read_size);
-}
-
-// static
-bool CoreAudioDemuxer::IsSupported(const std::string& content_type,
-                                   const GURL& url) {
-  std::string mime_type = base::ToLowerASCII(content_type);
-  if (mime_type.empty()) {
-    base::FilePath file(url.ExtractFileName());
-    if (!net::GetMimeTypeFromFile(file, &mime_type))
-      return false;
-  }
-  for (size_t i = 0; i < arraysize(kSupportedMimeTypes); i++) {
-    if (!mime_type.compare(kSupportedMimeTypes[i]))
-      return true;
-  }
-  return false;
-}
-
-}  // namespace media
diff --git a/media/filters/core_audio_demuxer.h b/media/filters/core_audio_demuxer.h
deleted file mode 100644
index e9b2990..0000000
--- a/media/filters/core_audio_demuxer.h
+++ /dev/null
@@ -1,99 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_CORE_AUDIO_DEMUXER_H_
-#define MEDIA_FILTERS_CORE_AUDIO_DEMUXER_H_
-
-#include <AudioToolbox/AudioFileStream.h>
-
-#include <string>
-
-#include "base/memory/scoped_ptr.h"
-#include "base/memory/weak_ptr.h"
-#include "base/threading/thread.h"
-#include "media/base/data_source.h"
-#include "media/base/demuxer.h"
-
-class GURL;
-
-namespace media {
-
-class BlockingUrlProtocol;
-class CoreAudioDemuxerStream;
-
-class MEDIA_EXPORT CoreAudioDemuxer : public Demuxer {
- public:
-  enum { kStreamInfoBufferSize = 64 * 1024 };
-
-  explicit CoreAudioDemuxer(DataSource* data_source);
-  ~CoreAudioDemuxer() override;
-
-  // Demuxer implementation.
-  std::string GetDisplayName() const override;
-  void Initialize(DemuxerHost* host,
-                  const PipelineStatusCB& status_cb,
-                  bool enable_text_tracks) override;
-  void Seek(base::TimeDelta time,
-            const PipelineStatusCB& status_cb) override;
-  void Stop() override;
-  DemuxerStream* GetStream(DemuxerStream::Type type) override;
-  base::TimeDelta GetStartTime() const override;
-  base::Time GetTimelineOffset() const override;
-  int64_t GetMemoryUsage() const override;
-
-  void ResetDataSourceOffset();
-  void ReadDataSourceIfNeeded();
-
-  static bool IsSupported(const std::string& content_type, const GURL& url);
-
-  void StartWaitingForSeek(base::TimeDelta seek_time) override;
-  void CancelPendingSeek(base::TimeDelta seek_time) override;
-
- private:
-  // Creates and configures DemuxerStream with Audio stream if it is possible.
-  CoreAudioDemuxerStream* CreateAudioDemuxerStream();
-
-  void OnReadAudioFormatInfoDone(const PipelineStatusCB& status_cb,
-                                 int read_size);
-  void OnReadDataSourceDone(int read_size);
-  void OnDataSourceError();
-
-  static void AudioPropertyListenerProc(void* client_data,
-                                        AudioFileStreamID audio_file_stream,
-                                        AudioFileStreamPropertyID property_id,
-                                        UInt32* io_flags);
-  static void AudioPacketsProc(
-      void* client_data,
-      UInt32 number_bytes,
-      UInt32 number_packets,
-      const void* input_data,
-      AudioStreamPacketDescription* packet_descriptions);
-  void SetAudioDuration(int64_t duration);
-
-  void ReadDataSourceWithCallback(const DataSource::ReadCB& read_cb);
-  void ReadAudioFormatInfo(const PipelineStatusCB& status_cb);
-  int ReadDataSource();
-
-  DemuxerHost* host_;         // Weak, owned by WebMediaPlayerImpl
-  DataSource* data_source_;   // Weak, owned by WebMediaPlayerImpl
-
-  scoped_ptr<CoreAudioDemuxerStream> audio_stream_;
-
-  // Thread on which all blocking operations are executed.
-  base::Thread blocking_thread_;
-  scoped_ptr<BlockingUrlProtocol> url_protocol_;
-  AudioStreamBasicDescription input_format_info_;
-  AudioFileStreamID audio_stream_id_;
-  uint8_t buffer_[kStreamInfoBufferSize];
-  UInt32 bit_rate_;
-  bool input_format_found_;
-
-  base::WeakPtrFactory<CoreAudioDemuxer> weak_factory_;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_CORE_AUDIO_DEMUXER_H_
diff --git a/media/filters/core_audio_demuxer_stream.cc b/media/filters/core_audio_demuxer_stream.cc
deleted file mode 100644
index 7e2bf15..0000000
--- a/media/filters/core_audio_demuxer_stream.cc
+++ /dev/null
@@ -1,436 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/core_audio_demuxer_stream.h"
-
-#include <vector>
-
-#include "base/callback_helpers.h"
-#include "base/logging.h"
-#include "base/mac/mac_util.h"
-#include "media/base/decoder_buffer.h"
-#include "media/base/media_util.h"
-#include "media/base/video_decoder_config.h"
-#include "media/filters/core_audio_demuxer.h"
-
-namespace media {
-
-namespace {
-
-const size_t kAudioQueueMaxPacketDescs = 512;  // Number of packet descriptions.
-const size_t kAudioQueueBufSize = 8 * CoreAudioDemuxer::kStreamInfoBufferSize;
-
-const char* StringFromAudioError(OSStatus err) {
-  switch (err) {
-    case kAudioFileStreamError_UnsupportedFileType:
-      return "The specified file type is not supported.";
-
-    case kAudioFileStreamError_UnsupportedDataFormat:
-      return "The data format is not supported by the specified file type.";
-
-    case kAudioFileStreamError_UnsupportedProperty:
-      return "The property is not supported.";
-
-    case kAudioFileStreamError_BadPropertySize:
-      return "The size of the buffer you provided for property data was not "
-             "correct.";
-
-    case kAudioFileStreamError_NotOptimized:
-      return "It is not possible to produce output packets because the streamed"
-             " audio file's packet table or other defining information is not "
-             "present or appears after the audio data.";
-
-    case kAudioFileStreamError_InvalidPacketOffset:
-      return "A packet offset was less than 0, or past the end of the file, or "
-             "a corrupt packet size was read when building the packet table.";
-
-    case kAudioFileStreamError_InvalidFile:
-      return "The file is malformed, not a valid instance of an audio file of "
-             "its type, or not recognized as an audio file.";
-
-    case kAudioFileStreamError_ValueUnknown:
-      return "The property value is not present in this file before the audio "
-             "data.";
-
-    case kAudioFileStreamError_DataUnavailable:
-      return "The amount of data provided to the parser was insufficient to "
-             "produce any result.";
-
-    case kAudioFileStreamError_IllegalOperation:
-      return "An illegal operation was attempted.";
-
-    case kAudioFileStreamError_UnspecifiedError:
-      return "An unspecified error has occurred.";
-
-    case kAudioFileStreamError_DiscontinuityCantRecover:
-      return "A discontinuity has occurred in the audio data, and Audio File "
-             "Stream Services cannot recover.";
-
-    case kAudioQueueErr_InvalidBuffer:
-      return "The specified audio queue buffer does not belong to the specified"
-             " audio queue.";
-
-    case kAudioQueueErr_BufferEmpty:
-      return "The audio queue buffer is empty (that is, the mAudioDataByteSize "
-             "field = 0).";
-
-    case kAudioQueueErr_DisposalPending:
-      return "The function cannot act on the audio queue because it is being "
-             "asynchronously disposed of.";
-
-    case kAudioQueueErr_InvalidProperty:
-      return "The specified property ID is invalid.";
-
-    case kAudioQueueErr_InvalidPropertySize:
-      return "The size of the specified property is invalid.";
-
-    case kAudioQueueErr_InvalidParameter:
-      return "The specified parameter ID is invalid.";
-
-    default:
-      return "Unknown";
-  }
-}
-
-}  //  namespace
-
-CoreAudioDemuxerStream::CoreAudioDemuxerStream(
-    CoreAudioDemuxer* demuxer,
-    AudioStreamBasicDescription input_format,
-    UInt32 bit_rate,
-    Type type)
-    : demuxer_(demuxer),
-      reading_audio_data_(false),
-      is_enqueue_running_(false),
-      output_buffer_(NULL),
-      input_format_(input_format),
-      audio_file_stream_(NULL),
-      audio_queue_buffer_(NULL),
-      bytes_filled_(0),
-      packets_filled_(0),
-      frames_decoded_(0),
-      decoded_data_buffer_size_(0),
-      bit_rate_(bit_rate),
-      pending_seek_(false) {
-  DCHECK_EQ(type, AUDIO);
-  DCHECK(demuxer_);
-
-  packet_descs_.reset(
-      new std::vector<AudioStreamPacketDescription>(kAudioQueueMaxPacketDescs));
-
-  memset(&output_format_, 0, sizeof(output_format_));
-
-  time_stamp_.mFlags = kAudioTimeStampSampleTimeValid;
-  time_stamp_.mSampleTime = 0;
-
-  InitializeAudioDecoderConfig();
-
-  OSStatus err = AudioFileStreamOpen(
-      this, &CoreAudioDemuxerStream::AudioPropertyListenerProc,
-      &CoreAudioDemuxerStream::AudioPacketsProc, kAudioFileMP3Type,
-      &audio_file_stream_);
-  CHECK(!err);
-
-  err = AudioQueueNewOutput(
-      &input_format_, CoreAudioDemuxerStream::AudioQueueOutputCallback, NULL,
-      NULL, kCFRunLoopCommonModes, 0, audio_queue_.InitializeInto());
-
-  if (err) {
-    LOG(ERROR) << "AudioQueueNewOutput, error = " << StringFromAudioError(err);
-    audio_queue_.reset();
-    return;
-  }
-
-  err = AudioQueueAllocateBuffer(audio_queue_, kAudioQueueBufSize,
-                                 &audio_queue_buffer_);
-  if (err) {
-    LOG(ERROR) << "AudioQueueAllocateBuffer, error = "
-               << StringFromAudioError(err);
-    audio_queue_.reset();
-  }
-}
-
-CoreAudioDemuxerStream::~CoreAudioDemuxerStream() {
-  DCHECK(read_cb_.is_null());
-
-  AudioFileStreamClose(audio_file_stream_);
-
-  if (audio_queue_) {
-    AudioQueueStop(audio_queue_, true);
-    AudioQueueFlush(audio_queue_);
-  }
-}
-
-void CoreAudioDemuxerStream::InitializeAudioDecoderConfig() {
-  ChannelLayout channel_layout = CHANNEL_LAYOUT_STEREO;
-  if (input_format_.mChannelsPerFrame == 1)
-    channel_layout = CHANNEL_LAYOUT_MONO;
-
-  std::vector<uint8> extra_data;
-  audio_config_.Initialize(kCodecPCM,
-                           kSampleFormatS16,
-                           channel_layout,
-                           input_format_.mSampleRate,
-                           extra_data,
-                           Unencrypted(),
-                           base::TimeDelta(),
-                           0);
-}
-
-void CoreAudioDemuxerStream::Read(const ReadCB& read_cb) {
-  CHECK(read_cb_.is_null()) << "Overlapping reads are not supported";
-  read_cb_ = read_cb;
-
-  if (!audio_queue_) {
-    base::ResetAndReturn(&read_cb_).Run(kAborted, NULL);
-    return;
-  }
-
-  demuxer_->ReadDataSourceIfNeeded();
-}
-
-void CoreAudioDemuxerStream::ReadCompleted(uint8_t* read_data, int read_size) {
-  if (read_cb_.is_null())
-    return;
-
-  if (read_size <= 0) {
-    Stop();
-    return;
-  }
-
-  int flags = pending_seek_ ? kAudioFileStreamParseFlag_Discontinuity : 0;
-  OSStatus err = AudioFileStreamParseBytes(
-      audio_file_stream_, read_size, read_data, flags);
-  pending_seek_ = false;
-  if (err != noErr) {
-    LOG(ERROR) << "AudioFileStreamParseBytes error: " << err;
-    base::ResetAndReturn(&read_cb_).Run(kAborted, NULL);
-    return;
-  }
-
-  if (!reading_audio_data_) {
-    // The parser has not parsed up to the beginning of the audio data yet,
-    // i.e., it is still reading tags, cover art, etc.  We ignore the non-audio
-    // data and return an empty buffer.  We will continue parsing with the next
-    // call to |Read()|.
-    base::ResetAndReturn(&read_cb_).Run(kOk, new DecoderBuffer(0));
-    return;
-  }
-
-  if (EnqueueBuffer() != noErr) {
-    base::ResetAndReturn(&read_cb_).Run(kAborted, NULL);
-    return;
-  }
-
-  base::ResetAndReturn(&read_cb_)
-      .Run(kOk, DecoderBuffer::CopyFrom(
-                    reinterpret_cast<uint8_t*>(output_buffer_->mAudioData),
-                    frames_decoded_));
-}
-
-AudioDecoderConfig CoreAudioDemuxerStream::audio_decoder_config() {
-  if (!audio_config_.IsValidConfig())
-    InitializeAudioDecoderConfig();
-
-  return audio_config_;
-}
-
-VideoDecoderConfig CoreAudioDemuxerStream::video_decoder_config() {
-  NOTREACHED();
-  return VideoDecoderConfig();
-}
-
-VideoRotation CoreAudioDemuxerStream::video_rotation() {
-  return VIDEO_ROTATION_0;
-}
-
-DemuxerStream::Type CoreAudioDemuxerStream::type() const {
-  return AUDIO;
-}
-
-void CoreAudioDemuxerStream::EnableBitstreamConverter() {}
-
-bool CoreAudioDemuxerStream::SupportsConfigChanges() { return false; }
-
-void CoreAudioDemuxerStream::Stop() {
-  if (!read_cb_.is_null()) {
-    base::ResetAndReturn(&read_cb_)
-        .Run(DemuxerStream::kOk, DecoderBuffer::CreateEOSBuffer());
-  }
-
-  demuxer_->ResetDataSourceOffset();
-}
-
-void CoreAudioDemuxerStream::Abort() {
-  if (!read_cb_.is_null()) {
-    base::ResetAndReturn(&read_cb_).Run(kAborted, NULL);
-  }
-}
-
-bool CoreAudioDemuxerStream::Seek(base::TimeDelta time) {
-  // Timestamps calcuations and seek is done mainly by Pipeline::SeekTask and
-  // Pipeline::DoSeek.
-  // Offset is calculated from begining of data source stream, not current
-  // position. If data_source_offset is not reset, then demuxer will be moved
-  // to (current position + seek time) instead of (seek time).
-  demuxer_->ResetDataSourceOffset();
-  pending_seek_ = true;
-  return true;
-}
-
-OSStatus CoreAudioDemuxerStream::EnqueueBuffer() {
-  OSStatus err = noErr;
-  AudioQueueBufferRef fill_buf = audio_queue_buffer_;
-  fill_buf->mAudioDataByteSize = bytes_filled_;
-
-  if (!is_enqueue_running_) {
-    is_enqueue_running_ = true;
-    // |output_format_| should be something similar to |input_format_|.
-    FillOutASBDForLPCM(output_format_,
-                       input_format_.mSampleRate,
-                       input_format_.mChannelsPerFrame,
-                       16,
-                       16,
-                       false,
-                       false,
-                       false);
-
-    AudioChannelLayout acl = {0};
-    acl.mChannelLayoutTag = kAudioChannelLayoutTag_Stereo;
-    if (input_format_.mChannelsPerFrame == 1)
-      acl.mChannelLayoutTag = kAudioChannelLayoutTag_Mono;
-    acl.mNumberChannelDescriptions = 0;
-    acl.mChannelBitmap = 0;
-
-    err = AudioQueueSetOfflineRenderFormat(audio_queue_, &output_format_, &acl);
-    if (err) {
-      LOG(ERROR) << "AudioQueueSetOfflineRenderFormat, error = "
-                 << StringFromAudioError(err);
-      return err;
-    }
-
-    // Value '16' in below calculation should be bits/sample, but very often
-    // this value is 0 in input_format_.mBitsPerChannel.
-    if (bit_rate_) {
-      float ratio =
-          (input_format_.mSampleRate * input_format_.mChannelsPerFrame * 16) /
-          bit_rate_;
-      decoded_data_buffer_size_ =
-          CoreAudioDemuxer::kStreamInfoBufferSize * (ratio + 1);
-    }
-    if (!bit_rate_ || !decoded_data_buffer_size_) {
-      // according to ISO bit rate must be at least 32kbps, which leads us for
-      // compression ratio of 44.1. Buffer of this size should be enough for
-      // any compressed audio data.
-      decoded_data_buffer_size_ = 45 * CoreAudioDemuxer::kStreamInfoBufferSize;
-    }
-
-    err = AudioQueueAllocateBuffer(
-        audio_queue_, decoded_data_buffer_size_, &output_buffer_);
-    if (err) {
-      LOG(ERROR) << "AudioQueueAllocateBuffer, error = "
-                 << StringFromAudioError(err);
-      return err;
-    }
-
-    err = AudioQueueStart(audio_queue_, NULL);
-    if (err) {
-      LOG(ERROR) << "AudioQueueStart, error = " << StringFromAudioError(err);
-      return err;
-    }
-
-    // This is requirement!
-    err =
-        AudioQueueOfflineRender(audio_queue_, &time_stamp_, output_buffer_, 0);
-    if (err) {
-      LOG(ERROR) << "AudioQueueOfflineRender, error = "
-                 << StringFromAudioError(err);
-      return err;
-    }
-  }
-
-  err = AudioQueueEnqueueBuffer(
-        audio_queue_, fill_buf, packets_filled_, packet_descs_->data());
-  if (err) {
-    LOG(ERROR) << "AudioQueueEnqueueBuffer, error = "
-               << StringFromAudioError(err);
-    return err;
-  }
-
-  UInt32 req_frames = decoded_data_buffer_size_ / output_format_.mBytesPerFrame;
-
-  err = AudioQueueOfflineRender(
-      audio_queue_, &time_stamp_, output_buffer_, req_frames);
-
-  if (err) {
-    LOG(ERROR) << "AudioQueueOfflineRender, error = "
-               << StringFromAudioError(err);
-    return err;
-  }
-
-  frames_decoded_ = output_buffer_->mAudioDataByteSize;
-  bytes_filled_ = 0;
-  packets_filled_ = 0;
-
-  return err;
-}
-
-void CoreAudioDemuxerStream::AudioPropertyListenerProc(
-    void* client_data,
-    AudioFileStreamID audio_file_stream,
-    AudioFileStreamPropertyID property_id,
-    UInt32* io_flags) {
-  if (property_id == kAudioFileStreamProperty_ReadyToProducePackets) {
-    CoreAudioDemuxerStream* stream =
-        reinterpret_cast<CoreAudioDemuxerStream*>(client_data);
-    stream->reading_audio_data_ = true;
-  }
-}
-
-void CoreAudioDemuxerStream::AudioPacketsProc(
-    void* client_data,
-    UInt32 number_bytes,
-    UInt32 number_packets,
-    const void* input_data,
-    AudioStreamPacketDescription* packet_descriptions) {
-  CoreAudioDemuxerStream* stream =
-      reinterpret_cast<CoreAudioDemuxerStream*>(client_data);
-  if (!stream->audio_queue_)
-    return;
-
-  // the following code assumes we're streaming VBR data.
-  for (UInt32 i = 0; i < number_packets; ++i) {
-    SInt64 packet_offset = packet_descriptions[i].mStartOffset;
-    SInt64 packet_size = packet_descriptions[i].mDataByteSize;
-
-    // copy data to the audio queue buffer
-    AudioQueueBufferRef fill_buf = stream->audio_queue_buffer_;
-    memcpy(
-        reinterpret_cast<char*>(fill_buf->mAudioData) + stream->bytes_filled_,
-        (const char*)input_data + packet_offset,
-        packet_size);
-
-    // fill out packet description
-    stream->packet_descs_->data()[stream->packets_filled_] =
-        packet_descriptions[i];
-    stream->packet_descs_->data()[stream->packets_filled_].mStartOffset =
-        stream->bytes_filled_;
-    stream->bytes_filled_ += packet_size;
-    stream->packets_filled_++;
-  }
-}
-
-void CoreAudioDemuxerStream::AudioQueueOutputCallback(
-    void* client_data,
-    AudioQueueRef audio_queue,
-    AudioQueueBufferRef buffer) {
-  // This is called by the audio queue when it has finished decoding our data.
-  // The buffer is now free to be reused. Don't need to do anything here, since
-  // overlapping reads are not supported. All data should be decoded before
-  // new data from Read are available, and those data are not needed anymore.
-}
-
-}  // namespace media
diff --git a/media/filters/core_audio_demuxer_stream.h b/media/filters/core_audio_demuxer_stream.h
deleted file mode 100644
index cd319fe..0000000
--- a/media/filters/core_audio_demuxer_stream.h
+++ /dev/null
@@ -1,95 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_CORE_AUDIO_DEMUXER_STREAM_H_
-#define MEDIA_FILTERS_CORE_AUDIO_DEMUXER_STREAM_H_
-
-#include <AudioToolbox/AudioFileStream.h>
-
-#include <vector>
-
-#include "base/memory/scoped_ptr.h"
-#include "media/base/audio_decoder_config.h"
-#include "media/base/demuxer_stream.h"
-#include "media/base/mac/scoped_audio_queue_ref.h"
-
-namespace media {
-
-class CoreAudioDemuxer;
-
-class CoreAudioDemuxerStream : public DemuxerStream {
- public:
-  CoreAudioDemuxerStream(CoreAudioDemuxer* demuxer,
-                         AudioStreamBasicDescription input_format,
-                         UInt32 bit_rate,
-                         Type type);
-  ~CoreAudioDemuxerStream() override;
-
-  // DemuxerStream implementation.
-  void Read(const ReadCB& read_cb) override;
-  AudioDecoderConfig audio_decoder_config() override;
-  VideoDecoderConfig video_decoder_config() override;
-  VideoRotation video_rotation() override;
-  Type type() const override;
-  void EnableBitstreamConverter() override;
-  bool SupportsConfigChanges() override;
-
-  void Stop();
-  void Abort();
-  void ReadCompleted(uint8_t* read_data, int size);
-
-  bool Seek(base::TimeDelta time);
-
- private:
-  static void AudioPropertyListenerProc(void* client_data,
-                                        AudioFileStreamID audio_file_stream,
-                                        AudioFileStreamPropertyID property_id,
-                                        UInt32* io_flags);
-  static void AudioPacketsProc(
-      void* client_data,
-      UInt32 number_bytes,
-      UInt32 number_packets,
-      const void* input_data,
-      AudioStreamPacketDescription* packet_descriptions);
-  static void AudioQueueOutputCallback(void* client_data,
-                                       AudioQueueRef audio_queue,
-                                       AudioQueueBufferRef buffer);
-
-  void InitializeAudioDecoderConfig();
-  OSStatus EnqueueBuffer();
-
-  CoreAudioDemuxer* demuxer_;  // Owns us.
-
-  AudioDecoderConfig audio_config_;
-
-  AudioTimeStamp time_stamp_;
-
-  ReadCB read_cb_;
-
-  bool reading_audio_data_;
-  bool is_enqueue_running_;
-
-  AudioQueueBufferRef output_buffer_;
-  AudioStreamBasicDescription input_format_;
-  AudioStreamBasicDescription output_format_;
-
-  AudioFileStreamID audio_file_stream_;
-  ScopedAudioQueueRef audio_queue_;
-  AudioQueueBufferRef audio_queue_buffer_;
-
-  scoped_ptr<std::vector<AudioStreamPacketDescription>> packet_descs_;
-
-  size_t bytes_filled_;    // how many bytes have been filled
-  size_t packets_filled_;  // how many packets have been filled
-  UInt32 frames_decoded_;
-  UInt32 decoded_data_buffer_size_;
-  UInt32 bit_rate_;
-  bool pending_seek_;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_CORE_AUDIO_DEMUXER_STREAM_H_
diff --git a/media/filters/decoder_stream.cc b/media/filters/decoder_stream.cc
index 9dd6229..19ae054 100644
--- a/media/filters/decoder_stream.cc
+++ b/media/filters/decoder_stream.cc
@@ -22,10 +22,6 @@
 #include "media/base/video_frame.h"
 #include "media/filters/decrypting_demuxer_stream.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/base/pipeline_stats.h"
-#endif
-
 namespace media {
 
 // TODO(rileya): Devise a better way of specifying trace/UMA/etc strings for
@@ -70,12 +66,6 @@ DecoderStream<StreamType>::~DecoderStream() {
   FUNCTION_DVLOG(2);
   DCHECK(task_runner_->BelongsToCurrentThread());
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (decoder_)
-    pipeline_stats::RemoveStreamForDecoderClass(stream_,
-                                                decoder_->GetDisplayName());
-#endif
-
   decoder_selector_.reset();
 
   if (!init_cb_.is_null()) {
@@ -263,13 +253,6 @@ void DecoderStream<StreamType>::OnDecoderSelected(
     DCHECK(decoder_);
   }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (decoder_) {
-    pipeline_stats::RemoveStreamForDecoderClass(stream_,
-                                                decoder_->GetDisplayName());
-  }
-#endif
-
   previous_decoder_ = std::move(decoder_);
   decoded_frames_since_fallback_ = 0;
   decoder_ = std::move(selected_decoder);
@@ -278,13 +261,6 @@ void DecoderStream<StreamType>::OnDecoderSelected(
     stream_ = decrypting_demuxer_stream_.get();
   }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (decoder_) {
-    pipeline_stats::AddStreamForDecoderClass(stream_,
-                                             decoder_->GetDisplayName());
-  }
-#endif
-
   if (!decoder_) {
     if (state_ == STATE_INITIALIZING) {
       state_ = STATE_UNINITIALIZED;
diff --git a/media/filters/ffmpeg_demuxer_unittest.cc b/media/filters/ffmpeg_demuxer_unittest.cc
index 1d79e28..01f57a1 100644
--- a/media/filters/ffmpeg_demuxer_unittest.cc
+++ b/media/filters/ffmpeg_demuxer_unittest.cc
@@ -28,12 +28,6 @@
 #include "media/media_features.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-// USE_SYSTEM_PROPRIETARY_CODECS requires a different test setup, see
-// PlatformMediaPipelineIntegrationTest.
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#undef USE_PROPRIETARY_CODECS
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 using ::testing::AnyNumber;
 using ::testing::DoAll;
 using ::testing::Exactly;
diff --git a/media/filters/gpu_video_decoder.cc b/media/filters/gpu_video_decoder.cc
index 69fe132..84f70b4 100644
--- a/media/filters/gpu_video_decoder.cc
+++ b/media/filters/gpu_video_decoder.cc
@@ -27,10 +27,6 @@
 #include "media/renderers/gpu_video_accelerator_factories.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/base/pipeline_stats.h"
-#endif
-
 namespace media {
 
 const char GpuVideoDecoder::kDecoderName[] = "GpuVideoDecoder";
@@ -161,10 +157,6 @@ void GpuVideoDecoder::Initialize(const VideoDecoderConfig& config,
   DCheckGpuVideoAcceleratorFactoriesTaskRunnerIsCurrent();
   DCHECK(config.IsValidConfig());
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS) && defined(OS_MACOSX)
-  pipeline_stats::AddDecoderClass(GetDisplayName());
-#endif
-
   InitCB bound_init_cb =
       base::Bind(&ReportGpuVideoDecoderInitializeStatusToUMAAndRunCB,
                  BindToCurrentLoop(init_cb));
@@ -231,9 +223,6 @@ void GpuVideoDecoder::Initialize(const VideoDecoderConfig& config,
   vda_ = factories_->CreateVideoDecodeAccelerator();
   if (!vda_) {
     DVLOG(1) << "Failed to create a VDA.";
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS) && defined(OS_MACOSX)
-    pipeline_stats::ReportVideoDecoderInitResult(false);
-#endif
     bound_init_cb.Run(false);
     return;
   }
@@ -267,9 +256,6 @@ void GpuVideoDecoder::Initialize(const VideoDecoderConfig& config,
   // If we don't have to wait for a surface complete initialization with a null
   // surface.
   CompleteInitialization(cdm_id, SurfaceManager::kNoSurfaceID);
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS) && defined(OS_MACOSX)
-  pipeline_stats::ReportVideoDecoderInitResult(true);
-#endif
 }
 
 void GpuVideoDecoder::CompleteInitialization(int cdm_id, int surface_id) {
diff --git a/media/filters/ipc_audio_decoder.cc b/media/filters/ipc_audio_decoder.cc
deleted file mode 100644
index f2b3189..0000000
--- a/media/filters/ipc_audio_decoder.cc
+++ /dev/null
@@ -1,331 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/ipc_audio_decoder.h"
-
-#include <algorithm>
-#include <string>
-
-#include "base/bind.h"
-#include "base/command_line.h"
-#include "base/location.h"
-#include "media/base/audio_bus.h"
-#include "media/base/data_source.h"
-#include "media/base/decoder_buffer.h"
-#include "media/base/demuxer_stream.h"
-#include "media/base/media_switches.h"
-#include "media/base/platform_mime_util.h"
-#include "media/base/sample_format.h"
-#include "media/filters/ffmpeg_glue.h"
-#include "media/filters/platform_media_pipeline_types.h"
-#include "media/filters/protocol_sniffer.h"
-
-#if defined(OS_MACOSX)
-#include "base/mac/mac_util.h"
-#endif
-
-namespace media {
-
-namespace {
-
-bool g_enabled = true;
-
-base::LazyInstance<media::IPCMediaPipelineHost::Creator>::Leaky
-    g_ipc_media_pipeline_host_creator = LAZY_INSTANCE_INITIALIZER;
-base::LazyInstance<scoped_refptr<base::SequencedTaskRunner>>
-    g_main_task_runner = LAZY_INSTANCE_INITIALIZER;
-base::LazyInstance<scoped_refptr<base::SequencedTaskRunner>>
-    g_media_task_runner = LAZY_INSTANCE_INITIALIZER;
-
-void RunCreatorOnMainThread(
-    DataSource* data_source,
-    scoped_ptr<IPCMediaPipelineHost>* ipc_media_pipeline_host) {
-  *ipc_media_pipeline_host = g_ipc_media_pipeline_host_creator.Get()
-                                .Run(g_media_task_runner.Get(), data_source);
-}
-
-void RunAndSignal(const base::Closure& task, base::WaitableEvent* done) {
-  task.Run();
-  done->Signal();
-}
-
-void PostTaskAndWait(
-    const scoped_refptr<base::SequencedTaskRunner>& task_runner,
-    const tracked_objects::Location& from_here,
-    const base::Closure& task) {
-  base::WaitableEvent done(false, false);
-  task_runner->PostTask(from_here, base::Bind(&RunAndSignal, task, &done));
-  done.Wait();
-}
-
-}  // namespace
-
-IPCAudioDecoder::ScopedDisableForTesting::ScopedDisableForTesting() {
-  g_enabled = false;
-}
-
-IPCAudioDecoder::ScopedDisableForTesting::~ScopedDisableForTesting() {
-  g_enabled = true;
-}
-
-// An implementation of the DataSource interface that is a wrapper around
-// FFmpegURLProtocol.
-class IPCAudioDecoder::InMemoryDataSource : public DataSource {
- public:
-  explicit InMemoryDataSource(FFmpegURLProtocol* protocol);
-
-  // DataSource implementation.
-  void Read(int64_t position,
-            int size,
-            uint8_t* data,
-            const DataSource::ReadCB& read_cb) override;
-  void Stop() override;
-  bool GetSize(int64_t* size_out) override;
-  bool IsStreaming() override;
-  void SetBitrate(int bitrate) override;
-
-  std::string mime_type() const { return mime_type_; }
-
- private:
-  void OnMimeTypeSniffed(const std::string& mime_type);
-
-  std::string mime_type_;
-  FFmpegURLProtocol* protocol_;
-  bool stopped_;
-
-  DISALLOW_COPY_AND_ASSIGN(InMemoryDataSource);
-};
-
-IPCAudioDecoder::InMemoryDataSource::InMemoryDataSource(
-    FFmpegURLProtocol* protocol)
-    : protocol_(protocol), stopped_(false) {
-  DCHECK(protocol_);
-
-  ProtocolSniffer protocol_sniffer;
-  protocol_sniffer.SniffProtocol(
-      this, base::Bind(&InMemoryDataSource::OnMimeTypeSniffed,
-                       base::Unretained(this)));
-}
-
-void IPCAudioDecoder::InMemoryDataSource::Read(
-    int64_t position,
-    int size,
-    uint8_t* data,
-    const DataSource::ReadCB& read_cb) {
-  if (stopped_ || size < 0 || position < 0) {
-    read_cb.Run(kReadError);
-    return;
-  }
-
-  protocol_->SetPosition(position);
-  read_cb.Run(protocol_->Read(size, data));
-}
-
-void IPCAudioDecoder::InMemoryDataSource::Stop() {
-  stopped_ = true;
-}
-
-bool IPCAudioDecoder::InMemoryDataSource::GetSize(int64_t* size_out) {
-  return protocol_->GetSize(size_out);
-}
-
-bool IPCAudioDecoder::InMemoryDataSource::IsStreaming() {
-  return protocol_->IsStreaming();
-}
-
-void IPCAudioDecoder::InMemoryDataSource::SetBitrate(int bitrate) {
-  // Do nothing.
-}
-
-void IPCAudioDecoder::InMemoryDataSource::OnMimeTypeSniffed(
-    const std::string& mime_type) {
-  mime_type_ = mime_type;
-}
-
-IPCAudioDecoder::IPCAudioDecoder(FFmpegURLProtocol* protocol)
-    : data_source_(new InMemoryDataSource(protocol)),
-      channels_(0),
-      sample_rate_(0),
-      number_of_frames_(0),
-      bytes_per_frame_(0),
-      sample_format_(kUnknownSampleFormat),
-      audio_bus_(nullptr),
-      frames_read_(0),
-      media_task_done_(false, false) {
-  DCHECK(IsAvailable());
-}
-
-IPCAudioDecoder::~IPCAudioDecoder() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (!ipc_media_pipeline_host_)
-    return;
-
-  PostTaskAndWait(g_media_task_runner.Get(), FROM_HERE,
-                  base::Bind(&IPCMediaPipelineHost::Stop,
-                             base::Unretained(ipc_media_pipeline_host_.get())));
-
-  g_media_task_runner.Get()->DeleteSoon(FROM_HERE,
-                                        ipc_media_pipeline_host_.release());
-}
-
-// static
-bool IPCAudioDecoder::IsAvailable() {
-  if (!g_enabled)
-    return false;
-
-#if defined(OS_MACOSX)
-  if (!base::mac::IsOSYosemiteOrLater())
-    // The pre-10.10 PlatformMediaPipeline implementation decodes media by
-    // playing them at the regular playback rate.  This is unacceptable for Web
-    // Audio API.
-    return false;
-#endif
-
-  return IsPlatformMediaPipelineAvailable(media::PlatformMediaCheckType::BASIC);
-}
-
-// static
-void IPCAudioDecoder::Preinitialize(
-    const media::IPCMediaPipelineHost::Creator& ipc_media_pipeline_host_creator,
-    const scoped_refptr<base::SequencedTaskRunner>& main_task_runner,
-    const scoped_refptr<base::SequencedTaskRunner>& media_task_runner) {
-  DCHECK(IsAvailable());
-  DCHECK(!ipc_media_pipeline_host_creator.is_null());
-  DCHECK(main_task_runner);
-  DCHECK(media_task_runner);
-
-  g_ipc_media_pipeline_host_creator.Get() = ipc_media_pipeline_host_creator;
-  g_main_task_runner.Get() = main_task_runner;
-  g_media_task_runner.Get() = media_task_runner;
-}
-
-bool IPCAudioDecoder::Initialize() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(g_media_task_runner.Get()) << "Must call Preinitialize() first";
-
-  PostTaskAndWait(g_main_task_runner.Get(), FROM_HERE,
-                  base::Bind(&RunCreatorOnMainThread, data_source_.get(),
-                             &ipc_media_pipeline_host_));
-
-  g_media_task_runner.Get()->PostTask(
-      FROM_HERE, base::Bind(&IPCMediaPipelineHost::Initialize,
-                            base::Unretained(ipc_media_pipeline_host_.get()),
-                            data_source_->mime_type(),
-                            base::Bind(&IPCAudioDecoder::OnInitialized,
-                                       base::Unretained(this))));
-  media_task_done_.Wait();
-
-  return ipc_media_pipeline_host_ != nullptr;
-}
-
-void IPCAudioDecoder::OnInitialized(
-    bool success,
-    int bitrate,
-    const PlatformMediaTimeInfo& time_info,
-    const PlatformAudioConfig& audio_config,
-    const PlatformVideoConfig& /* video_config */) {
-  DCHECK(g_media_task_runner.Get()->RunsTasksOnCurrentThread());
-
-  if (success && audio_config.is_valid()) {
-    channels_ = audio_config.channel_count;
-    sample_rate_ = audio_config.samples_per_second;
-    number_of_frames_ = base::saturated_cast<int>(
-        ceil(time_info.duration.InSecondsF() * sample_rate_));
-    bytes_per_frame_ =
-        channels_ * SampleFormatToBytesPerChannel(audio_config.format);
-    sample_format_ = audio_config.format;
-    duration_ = time_info.duration;
-  } else {
-    ipc_media_pipeline_host_.reset();
-  }
-
-  media_task_done_.Signal();
-}
-
-int IPCAudioDecoder::Read(AudioBus* audio_bus) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (!ipc_media_pipeline_host_ || audio_bus->channels() != channels_)
-    return 0;
-
-  audio_bus_ = audio_bus;
-
-  g_media_task_runner.Get()->PostTask(
-      FROM_HERE,
-      base::Bind(&IPCAudioDecoder::ReadInternal, base::Unretained(this)));
-  media_task_done_.Wait();
-
-  return frames_read_;
-}
-
-void IPCAudioDecoder::ReadInternal() {
-  DCHECK(g_media_task_runner.Get()->RunsTasksOnCurrentThread());
-
-  ipc_media_pipeline_host_->ReadDecodedData(
-      PLATFORM_MEDIA_AUDIO,
-      base::Bind(&IPCAudioDecoder::DataReady, base::Unretained(this)));
-}
-
-void IPCAudioDecoder::DataReady(DemuxerStream::Status status,
-                                const scoped_refptr<DecoderBuffer>& buffer) {
-  DCHECK(g_media_task_runner.Get()->RunsTasksOnCurrentThread());
-
-  switch (status) {
-    case DemuxerStream::Status::kAborted:
-      frames_read_ = -1;
-      media_task_done_.Signal();
-      break;
-
-    case DemuxerStream::Status::kConfigChanged:
-      // When config changes the decoder buffer does not contain any useful
-      // data, so we need to explicitly ask for more.
-      ReadInternal();
-      break;
-
-    case DemuxerStream::Status::kOk:
-      if (buffer->end_of_stream()) {
-        media_task_done_.Signal();
-        break;
-      }
-
-      const int frame_count = std::min((int) buffer->data_size() / bytes_per_frame_,
-                                       audio_bus_->frames() - frames_read_);
-
-      // Deinterleave each channel. The final format should be 32bit
-      // floating-point planar.
-      if (sample_format_ == kSampleFormatF32) {
-        const float* decoded_audio_data =
-            reinterpret_cast<const float*>(buffer->data());
-        for (int channel_index = 0; channel_index < channels_;
-             ++channel_index) {
-          float* bus_data = audio_bus_->channel(channel_index) + frames_read_;
-          for (int frame_index = 0, channel_offset = channel_index;
-               frame_index < frame_count;
-               ++frame_index, channel_offset += channels_) {
-            bus_data[frame_index] = decoded_audio_data[channel_offset];
-          }
-        }
-      } else if (sample_format_ == kSampleFormatPlanarF32) {
-        const int channel_size = buffer->data_size() / channels_;
-        for (int channel_index = 0; channel_index < channels_;
-             ++channel_index) {
-          memcpy(audio_bus_->channel(channel_index) + frames_read_,
-                 buffer->data() + channel_index * channel_size,
-                 sizeof(float) * frame_count);
-        }
-      } else {
-        NOTREACHED();
-      }
-
-      frames_read_ += frame_count;
-
-      ReadInternal();
-      break;
-  }
-}
-
-}  // namespace media
diff --git a/media/filters/ipc_audio_decoder.h b/media/filters/ipc_audio_decoder.h
deleted file mode 100644
index 8f14861..0000000
--- a/media/filters/ipc_audio_decoder.h
+++ /dev/null
@@ -1,92 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_IPC_AUDIO_DECODER_H_
-#define MEDIA_FILTERS_IPC_AUDIO_DECODER_H_
-
-#include "base/lazy_instance.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/synchronization/waitable_event.h"
-#include "base/threading/thread_checker.h"
-#include "media/base/media_export.h"
-#include "media/filters/ipc_media_pipeline_host.h"
-
-namespace base {
-class SequencedTaskRunner;
-}
-
-namespace media {
-
-class AudioBus;
-class FFmpegURLProtocol;
-
-// Audio decoder based on the IPCMediaPipeline. It decodes in-memory audio file
-// data. It is used for Web Audio API, so its usage has to be synchronous.
-// The IPCMediaPipeline flow is asynchronous, so IPCAudioDecoder has to use some
-// synchronization tricks in order to appear synchronous.
-class MEDIA_EXPORT IPCAudioDecoder {
- public:
-  // TODO(wdzierzanowski): Only necessary because this class currently
-  // interferes with AudioFileReaderTest (DNA-45771).
-  class MEDIA_EXPORT ScopedDisableForTesting {
-   public:
-    ScopedDisableForTesting();
-    ~ScopedDisableForTesting();
-  };
-
-  explicit IPCAudioDecoder(FFmpegURLProtocol* protocol);
-  ~IPCAudioDecoder();
-
-  static bool IsAvailable();
-  static void Preinitialize(
-      const IPCMediaPipelineHost::Creator& ipc_media_pipeline_host_creator,
-      const scoped_refptr<base::SequencedTaskRunner>& main_task_runner,
-      const scoped_refptr<base::SequencedTaskRunner>& media_task_runner);
-
-  bool Initialize();
-
-  int Read(AudioBus* audio_bus);
-
-  int channels() const { return channels_; }
-  int sample_rate() const { return sample_rate_; }
-  int number_of_frames() const { return number_of_frames_; }
-  base::TimeDelta duration() const { return duration_; }
-
- private:
-  class InMemoryDataSource;
-
-  void OnInitialized(bool success,
-                     int bitrate,
-                     const PlatformMediaTimeInfo& time_info,
-                     const PlatformAudioConfig& audio_config,
-                     const PlatformVideoConfig& video_config);
-  void ReadInternal();
-  void DataReady(DemuxerStream::Status status,
-                 const scoped_refptr<DecoderBuffer>& buffer);
-
-  scoped_ptr<InMemoryDataSource> data_source_;
-
-  int channels_;
-  int sample_rate_;
-  int number_of_frames_;
-  int bytes_per_frame_;
-  media::SampleFormat sample_format_;
-  base::TimeDelta duration_;
-
-  AudioBus* audio_bus_;
-  int frames_read_;
-
-  scoped_ptr<IPCMediaPipelineHost> ipc_media_pipeline_host_;
-  base::WaitableEvent media_task_done_;
-
-  base::ThreadChecker thread_checker_;
-
-  DISALLOW_COPY_AND_ASSIGN(IPCAudioDecoder);
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_IPC_AUDIO_DECODER_H_
diff --git a/media/filters/ipc_demuxer.cc b/media/filters/ipc_demuxer.cc
deleted file mode 100644
index 0a3bfdb..0000000
--- a/media/filters/ipc_demuxer.cc
+++ /dev/null
@@ -1,239 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2013 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/ipc_demuxer.h"
-
-#include <algorithm>
-
-#include "base/bind.h"
-#include "base/callback_helpers.h"
-#include "base/strings/string_util.h"
-#include "media/base/media_log.h"
-#include "media/base/pipeline_stats.h"
-#include "media/filters/ipc_demuxer_stream.h"
-#include "media/filters/ipc_media_pipeline_host.h"
-#include "media/filters/platform_media_pipeline_types.h"
-#include "net/base/mime_util.h"
-#include "url/gurl.h"
-
-namespace {
-
-static const char* const kIPCMediaPipelineSupportedMimeTypes[] = {
-    "video/mp4",       "video/m4v",   "video/x-m4v", "video/mpeg",
-    "audio/mp4",       "audio/x-m4a", "audio/mp3",   "audio/x-mp3",
-    "audio/mpeg",      "audio/mpeg3", "audio/aac",   "audio/aacp",
-    "audio/3gpp",      "audio/3gpp2", "video/3gpp",  "video/3gpp2",
-#if defined(OS_MACOSX)
-    "video/quicktime",
-#endif
-};
-
-std::string MimeTypeFromContentTypeOrURL(const std::string& content_type,
-                                         const GURL& url) {
-  std::string mime_type = base::ToLowerASCII(content_type);
-  if (mime_type.empty()) {
-#if defined(OS_WIN)
-    base::FilePath file(base::FilePath::FromUTF8Unsafe(url.ExtractFileName()));
-#elif defined(OS_POSIX)
-    base::FilePath file(url.ExtractFileName());
-#endif
-    net::GetMimeTypeFromFile(file, &mime_type);
-  }
-  return mime_type;
-}
-
-}  // namespace
-
-namespace media {
-
-IPCDemuxer::IPCDemuxer(
-    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner,
-    DataSource* data_source,
-    scoped_ptr<IPCMediaPipelineHost> ipc_media_pipeline_host,
-    const std::string& content_type,
-    const GURL& url,
-    const scoped_refptr<MediaLog>& media_log)
-    : task_runner_(task_runner),
-      host_(NULL),
-      data_source_(data_source),
-      mimetype_(MimeTypeFromContentTypeOrURL(content_type, url)),
-      stopping_(false),
-      ipc_media_pipeline_host_(std::move(ipc_media_pipeline_host)),
-      media_log_(media_log),
-      weak_ptr_factory_(this) {
-  DCHECK(data_source_);
-  DCHECK(ipc_media_pipeline_host_.get());
-}
-
-IPCDemuxer::~IPCDemuxer() {
-  // We hand out weak pointers on the |task_runner_| thread.  Make sure they are
-  // all invalidated by the time we are destroyed (on the render thread).
-  DCHECK(!weak_ptr_factory_.HasWeakPtrs());
-
-  if (video_stream_)
-    pipeline_stats::RemoveStream(video_stream_.get());
-  if (audio_stream_)
-    pipeline_stats::RemoveStream(audio_stream_.get());
-}
-
-// static
-bool IPCDemuxer::CanPlayType(const std::string& content_type, const GURL& url) {
-  const std::string mime_type = MimeTypeFromContentTypeOrURL(content_type, url);
-  for (const auto supported_mime_type : kIPCMediaPipelineSupportedMimeTypes)
-    if (mime_type == supported_mime_type)
-      return true;
-
-  return false;
-}
-
-std::string IPCDemuxer::GetDisplayName() const {
-  return "IPCDemuxer";
-}
-
-void IPCDemuxer::Initialize(DemuxerHost* host,
-                            const PipelineStatusCB& status_cb,
-                            bool enable_text_tracks) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-  DCHECK(!stopping_);
-
-  host_ = host;
-  ipc_media_pipeline_host_->Initialize(
-      mimetype_,
-      base::Bind(&IPCDemuxer::OnInitialized,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 status_cb));
-}
-
-void IPCDemuxer::StartWaitingForSeek(base::TimeDelta seek_time) {
-  if (!stopping_)
-    ipc_media_pipeline_host_->StartWaitingForSeek();
-}
-
-void IPCDemuxer::CancelPendingSeek(base::TimeDelta seek_time) {
-}
-
-void IPCDemuxer::Seek(base::TimeDelta time, const PipelineStatusCB& status_cb) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  if (stopping_) {
-    status_cb.Run(PIPELINE_ERROR_ABORT);
-    return;
-  }
-
-  ipc_media_pipeline_host_->Seek(time, status_cb);
-}
-
-void IPCDemuxer::Stop() {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-  DCHECK(!stopping_);
-
-  stopping_ = true;
-
-  if (audio_stream_.get() != NULL)
-    audio_stream_->Stop();
-  if (video_stream_.get() != NULL)
-    video_stream_->Stop();
-
-  ipc_media_pipeline_host_->Stop();
-  // IPCMediaPipelineHost must only live on the |task_runner_| thread.
-  ipc_media_pipeline_host_.reset();
-
-  // We will be destroyed soon.  Invalidate all weak pointers while we're still
-  // on the |task_runner_| thread.
-  weak_ptr_factory_.InvalidateWeakPtrs();
-}
-
-DemuxerStream* IPCDemuxer::GetStream(DemuxerStream::Type type) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  switch (type) {
-    case DemuxerStream::AUDIO:
-      return audio_stream_.get();
-    case DemuxerStream::VIDEO:
-      return video_stream_.get();
-    default:
-      return NULL;
-  }
-}
-
-base::TimeDelta IPCDemuxer::GetStartTime() const {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  return start_time_;
-}
-
-base::Time IPCDemuxer::GetTimelineOffset() const {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  return base::Time();
-}
-
-int64_t IPCDemuxer::GetMemoryUsage() const {
-  // TODO(tmoniuszko): Implement me. DNA-45936
-  return 0;
-}
-
-void IPCDemuxer::OnInitialized(const PipelineStatusCB& callback,
-                               bool success,
-                               int bitrate,
-                               const PlatformMediaTimeInfo& time_info,
-                               const PlatformAudioConfig& audio_config,
-                               const PlatformVideoConfig& video_config) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  // Avoid counting audio-only media as HW-accelerated.  Unfortunately, we
-  // cannot reliably tell if media is audio-only when initialization wasn't
-  // successful.
-  const auto video_decoding_mode = success && !video_config.is_valid()
-                                       ? PlatformMediaDecodingMode::SOFTWARE
-                                       : video_config.decoding_mode;
-  pipeline_stats::ReportStartResult(success, video_decoding_mode);
-
-  if (stopping_) {
-    callback.Run(PIPELINE_ERROR_ABORT);
-    return;
-  }
-
-  if (!success) {
-    callback.Run(PIPELINE_ERROR_INITIALIZATION_FAILED);
-    return;
-  }
-
-  if (audio_config.is_valid()) {
-    audio_stream_.reset(new IPCDemuxerStream(DemuxerStream::AUDIO,
-                                             ipc_media_pipeline_host_.get()));
-    pipeline_stats::AddStream(audio_stream_.get(),
-                              PlatformMediaDecodingMode::SOFTWARE);
-  }
-
-  if (video_config.is_valid()) {
-    video_stream_.reset(new IPCDemuxerStream(DemuxerStream::VIDEO,
-                                             ipc_media_pipeline_host_.get()));
-    pipeline_stats::AddStream(video_stream_.get(), video_config.decoding_mode);
-
-#if defined(OS_WIN)
-    // |decoding_mode| might be misleading on OS X, because the platform
-    // decoder may or may not use HW acceleration internally.
-    const char* mode =
-        video_config.decoding_mode == PlatformMediaDecodingMode::HARDWARE
-            ? "hardware"
-            : "software";
-    MEDIA_LOG(INFO, media_log_) << GetDisplayName() << ": using " << mode
-                                << " video decoding";
-#endif
-  }
-
-  host_->SetDuration(time_info.duration);
-  data_source_->SetBitrate(bitrate);
-
-  // Make sure we abide by the Demuxer::GetStartTime() contract.  We cannot
-  // guarantee that the platform decoders return a non-negative value.
-  start_time_ = std::max(time_info.start_time, base::TimeDelta());
-
-  callback.Run(PIPELINE_OK);
-}
-
-}  // namespace media
diff --git a/media/filters/ipc_demuxer.h b/media/filters/ipc_demuxer.h
deleted file mode 100644
index 8cd189f..0000000
--- a/media/filters/ipc_demuxer.h
+++ /dev/null
@@ -1,106 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_IPC_DEMUXER_H_
-#define MEDIA_FILTERS_IPC_DEMUXER_H_
-
-#include <string>
-
-#include "base/memory/ref_counted.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/memory/weak_ptr.h"
-#include "media/base/demuxer.h"
-#include "media/base/media_export.h"
-
-class GURL;
-
-namespace base {
-class SingleThreadTaskRunner;
-}
-
-namespace media {
-
-class IPCDemuxerStream;
-class IPCMediaPipelineHost;
-class MediaLog;
-struct PlatformAudioConfig;
-struct PlatformMediaTimeInfo;
-struct PlatformVideoConfig;
-
-// An implementation of the demuxer interface. On its creation it should create
-// the media IPC. It is wrapping all of the demuxer functionality, so that the
-// IPC part is transparent. It is also responsible for providing the data
-// source for the IPCMediaPipelineHost.
-class MEDIA_EXPORT IPCDemuxer : public Demuxer {
- public:
-  IPCDemuxer(const scoped_refptr<base::SingleThreadTaskRunner>& task_runner,
-             DataSource* data_source,
-             scoped_ptr<IPCMediaPipelineHost> ipc_media_pipeline_host,
-             const std::string& content_type,
-             const GURL& url,
-             const scoped_refptr<MediaLog>& media_log);
-  ~IPCDemuxer() override;
-
-  // Checks if the content is supported by this demuxer.
-  static bool CanPlayType(const std::string& content_type, const GURL& url);
-
-  // Demuxer implementation.
-  //
-  // All Demuxer functions are expected to be called on |task_runner_|'s
-  // thread.
-  std::string GetDisplayName() const override;
-  void Initialize(DemuxerHost* host,
-                  const PipelineStatusCB& status_cb,
-                  bool enable_text_tracks) override;
-  void Seek(base::TimeDelta time, const PipelineStatusCB& status_cb) override;
-  void Stop() override;
-  DemuxerStream* GetStream(DemuxerStream::Type type) override;
-  base::TimeDelta GetStartTime() const override;
-  base::Time GetTimelineOffset() const override;
-  int64_t GetMemoryUsage() const override;
-
-  // Used to tell the demuxer that a seek request is about to arrive on the
-  // media thread.  This lets the demuxer drop everything it was doing and
-  // become ready to handle the seek request quickly.
-  //
-  // This function can be called on any thread.
-  void StartWaitingForSeek(base::TimeDelta seek_time) override;
-  void CancelPendingSeek(base::TimeDelta seek_time) override;
-
- private:
-  // Called when demuxer initiazlizes.
-  void OnInitialized(const PipelineStatusCB& callback,
-                     bool success,
-                     int bitrate,
-                     const PlatformMediaTimeInfo& time_info,
-                     const PlatformAudioConfig& audio_config,
-                     const PlatformVideoConfig& video_config);
-
-  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-
-  DemuxerHost* host_;
-  DataSource* data_source_;
-
-  std::string mimetype_;
-
-  base::TimeDelta start_time_;
-
-  bool stopping_;
-
-  scoped_ptr<IPCMediaPipelineHost> ipc_media_pipeline_host_;
-  scoped_ptr<IPCDemuxerStream> audio_stream_;
-  scoped_ptr<IPCDemuxerStream> video_stream_;
-
-  scoped_refptr<MediaLog> media_log_;
-
-  base::WeakPtrFactory<IPCDemuxer> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(IPCDemuxer);
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_IPC_DEMUXER_H_
diff --git a/media/filters/ipc_demuxer_stream.cc b/media/filters/ipc_demuxer_stream.cc
deleted file mode 100644
index 34f3991..0000000
--- a/media/filters/ipc_demuxer_stream.cc
+++ /dev/null
@@ -1,156 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/ipc_demuxer_stream.h"
-
-#include "base/bind.h"
-#include "base/callback_helpers.h"
-#include "media/base/decoder_buffer.h"
-#include "media/base/media_util.h"
-#include "media/filters/ipc_media_pipeline_host.h"
-#include "media/filters/platform_media_pipeline_types.h"
-
-namespace media {
-
-namespace {
-
-PlatformMediaDataType DemuxerTypeToPlatformMediaDataType(
-    DemuxerStream::Type type) {
-  switch (type) {
-    case DemuxerStream::AUDIO:
-      return PLATFORM_MEDIA_AUDIO;
-
-    case DemuxerStream::VIDEO:
-      return PLATFORM_MEDIA_VIDEO;
-
-    default:
-      NOTREACHED();
-      return PlatformMediaDataType();
-  }
-}
-
-}  // namespace
-
-IPCDemuxerStream::IPCDemuxerStream(
-    Type type,
-    IPCMediaPipelineHost* ipc_media_pipeline_host)
-    : type_(type),
-      ipc_media_pipeline_host_(ipc_media_pipeline_host),
-      weak_ptr_factory_(this) {
-  DCHECK(ipc_media_pipeline_host_);
-}
-
-IPCDemuxerStream::~IPCDemuxerStream() {
-}
-
-void IPCDemuxerStream::Read(const ReadCB& read_cb) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(read_cb_.is_null()) << "Overlapping reads are not supported";
-
-  // Don't accept any additional reads if we've been told to stop.
-  if (ipc_media_pipeline_host_ == NULL) {
-    read_cb.Run(kOk, DecoderBuffer::CreateEOSBuffer());
-    return;
-  }
-
-  read_cb_ = read_cb;
-
-  ipc_media_pipeline_host_->ReadDecodedData(
-      DemuxerTypeToPlatformMediaDataType(type_),
-      base::Bind(&IPCDemuxerStream::DataReady, weak_ptr_factory_.GetWeakPtr()));
-}
-
-AudioDecoderConfig IPCDemuxerStream::audio_decoder_config() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK_EQ(type_, AUDIO);
-
-  PlatformAudioConfig platform_audio_config =
-      ipc_media_pipeline_host_->audio_config();
-  DCHECK(platform_audio_config.is_valid());
-
-  // This demuxer stream is different from "normal" demuxers in that it outputs
-  // decoded data.  To fit into existing media pipeline we hard code some
-  // information, which is normally read from the data stream.
-  AudioDecoderConfig audio_config;
-  audio_config.Initialize(
-      kCodecPCM, platform_audio_config.format,
-      GuessChannelLayout(platform_audio_config.channel_count),
-      platform_audio_config.samples_per_second, EmptyExtraData(), Unencrypted(),
-      base::TimeDelta(), 0);
-
-  return audio_config;
-}
-
-VideoDecoderConfig IPCDemuxerStream::video_decoder_config() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK_EQ(type_, VIDEO);
-
-  PlatformVideoConfig platform_video_config =
-      ipc_media_pipeline_host_->video_config();
-  DCHECK(platform_video_config.is_valid());
-
-  // This demuxer stream is different from "normal" demuxers in that it outputs
-  // decoded data.  To fit into existing media pipeline we hard code some
-  // information, which is normally read from the data stream.
-  VideoDecoderConfig video_config;
-  video_config.Initialize(
-      kCodecH264, H264PROFILE_MAIN, PIXEL_FORMAT_YV12, COLOR_SPACE_UNSPECIFIED,
-      platform_video_config.coded_size, platform_video_config.visible_rect,
-      platform_video_config.natural_size,
-      std::vector<uint8_t>(
-          reinterpret_cast<const uint8_t*>(&platform_video_config.planes),
-          reinterpret_cast<const uint8_t*>(&platform_video_config.planes)
-              + sizeof(platform_video_config.planes)),
-      Unencrypted());
-
-  return video_config;
-}
-
-VideoRotation IPCDemuxerStream::video_rotation() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK_EQ(type_, VIDEO);
-  return ipc_media_pipeline_host_->video_config().rotation;
-}
-
-DemuxerStream::Type IPCDemuxerStream::type() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return type_;
-}
-
-void IPCDemuxerStream::EnableBitstreamConverter() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  /* Intentionally empty */
-}
-
-bool IPCDemuxerStream::SupportsConfigChanges() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-#if defined(OS_WIN)
-  return true;
-#else
-  return false;
-#endif
-}
-
-void IPCDemuxerStream::Stop() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (!read_cb_.is_null()) {
-    base::ResetAndReturn(&read_cb_)
-        .Run(DemuxerStream::kOk, DecoderBuffer::CreateEOSBuffer());
-  }
-
-  ipc_media_pipeline_host_ = NULL;
-}
-
-void IPCDemuxerStream::DataReady(Status status,
-                                 const scoped_refptr<DecoderBuffer>& buffer) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  if (!read_cb_.is_null())
-    base::ResetAndReturn(&read_cb_).Run(status, buffer);
-}
-
-}  // namespace media
diff --git a/media/filters/ipc_demuxer_stream.h b/media/filters/ipc_demuxer_stream.h
deleted file mode 100644
index cb52a78..0000000
--- a/media/filters/ipc_demuxer_stream.h
+++ /dev/null
@@ -1,53 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_IPC_DEMUXER_STREAM_H_
-#define MEDIA_FILTERS_IPC_DEMUXER_STREAM_H_
-
-#include "base/memory/weak_ptr.h"
-#include "base/threading/thread_checker.h"
-#include "media/base/demuxer_stream.h"
-#include "media/base/audio_decoder_config.h"
-#include "media/base/video_decoder_config.h"
-#include "media/filters/ipc_media_pipeline_host.h"
-
-namespace media {
-
-class IPCMediaPipelineHost;
-struct PlatformAudioConfig;
-struct PlatformVideoConfig;
-
-class IPCDemuxerStream : public DemuxerStream {
- public:
-  IPCDemuxerStream(Type type, IPCMediaPipelineHost* ipc_media_pipeline_host);
-  ~IPCDemuxerStream() override;
-
-  // DemuxerStream's implementation.
-  void Read(const ReadCB& read_cb) override;
-  AudioDecoderConfig audio_decoder_config() override;
-  VideoDecoderConfig video_decoder_config() override;
-  VideoRotation video_rotation() override;
-  Type type() const override;
-  void EnableBitstreamConverter() override;
-  bool SupportsConfigChanges() override;
-
-  void Stop();
-
- private:
-  void DataReady(Status status, const scoped_refptr<DecoderBuffer>& buffer);
-
-  Type type_;
-
-  IPCMediaPipelineHost* ipc_media_pipeline_host_;
-  ReadCB read_cb_;
-
-  base::ThreadChecker thread_checker_;
-  base::WeakPtrFactory<IPCDemuxerStream> weak_ptr_factory_;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_IPC_DEMUXER_STREAM_H_
diff --git a/media/filters/ipc_media_pipeline_host.h b/media/filters/ipc_media_pipeline_host.h
deleted file mode 100644
index b3d974e..0000000
--- a/media/filters/ipc_media_pipeline_host.h
+++ /dev/null
@@ -1,84 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_IPC_MEDIA_PIPELINE_HOST_H_
-#define MEDIA_FILTERS_IPC_MEDIA_PIPELINE_HOST_H_
-
-#include <string>
-
-#include "base/callback_forward.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/time/time.h"
-#include "media/base/demuxer_stream.h"
-#include "media/base/pipeline_status.h"
-#include "media/filters/platform_media_pipeline_types.h"
-
-namespace base {
-class SequencedTaskRunner;
-}
-
-namespace media {
-
-class DataSource;
-class GpuVideoAcceleratorFactories;
-
-// Represents the renderer side of the IPC connection between the IPCDemuxer
-// and the IPCMediaPipeline in the GPU process. It is responsible for
-// establishing the IPC connection. It provides methods needed by the demuxer
-// and the demuxer stream to work - talk to the decoders over the IPC. As well
-// as the methods for responding on the requests recived over IPC for the data
-// from the data source.
-class IPCMediaPipelineHost {
- public:
-  using Creator = base::Callback<scoped_ptr<IPCMediaPipelineHost>(
-      const scoped_refptr<base::SequencedTaskRunner>& task_runner,
-      media::DataSource* data_source)>;
-
-  using InitializeCB =
-      base::Callback<void(bool success,
-                          int bitrate,
-                          const PlatformMediaTimeInfo& time_info,
-                          const PlatformAudioConfig& audio_config,
-                          const PlatformVideoConfig& video_config)>;
-
-  virtual ~IPCMediaPipelineHost() {}
-
-  virtual void Initialize(const std::string& mimetype,
-                          const InitializeCB& callback) = 0;
-
-  // Used to inform the platform side of the pipeline that a seek request is
-  // about to arrive.  This lets the platform drop everything it was doing and
-  // become ready to handle the seek request quickly.
-  virtual void StartWaitingForSeek() = 0;
-
-  // Performs the seek over the IPC.
-  virtual void Seek(base::TimeDelta time,
-                    const PipelineStatusCB& status_cb) = 0;
-
-  // Stops the demuxer.
-  virtual void Stop() = 0;
-
-  // Starts an asynchronous read of decoded media data over the IPC.
-  virtual void ReadDecodedData(PlatformMediaDataType type,
-                               const DemuxerStream::ReadCB& read_cb) = 0;
-
-  // Wrapper for PlatformMediaPipeline::EnlargesBuffersOnUnderflow()
-  // (to let code in media module access it without breaking dependencies).
-  virtual bool PlatformEnlargesBuffersOnUnderflow() const = 0;
-
-  // Returns the target capacity of the raw media data buffer, in the backward
-  // and forward directions.  A return value of base::TimeDelta() means "use
-  // the default value".
-  virtual base::TimeDelta GetTargetBufferDurationBehind() const = 0;
-  virtual base::TimeDelta GetTargetBufferDurationAhead() const = 0;
-
-  virtual PlatformAudioConfig audio_config() const = 0;
-  virtual PlatformVideoConfig video_config() const = 0;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_IPC_MEDIA_PIPELINE_HOST_H_
diff --git a/media/filters/pass_through_audio_decoder.cc b/media/filters/pass_through_audio_decoder.cc
deleted file mode 100644
index a26f9f8..0000000
--- a/media/filters/pass_through_audio_decoder.cc
+++ /dev/null
@@ -1,39 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/filters/pass_through_audio_decoder.h"
-
-namespace media {
-
-PassThroughAudioDecoder::PassThroughAudioDecoder(
-    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner)
-    : impl_(task_runner) {
-}
-
-PassThroughAudioDecoder::~PassThroughAudioDecoder() {
-}
-
-void PassThroughAudioDecoder::Initialize(const AudioDecoderConfig& config,
-                                         CdmContext* cdm_context,
-                                         const InitCB& init_cb,
-                                         const OutputCB& output_cb) {
-  impl_.Initialize(config, init_cb, output_cb);
-}
-
-void PassThroughAudioDecoder::Decode(const scoped_refptr<DecoderBuffer>& buffer,
-                                     const DecodeCB& decode_cb) {
-  impl_.Decode(buffer, decode_cb);
-}
-
-void PassThroughAudioDecoder::Reset(const base::Closure& closure) {
-  impl_.Reset(closure);
-}
-
-std::string PassThroughAudioDecoder::GetDisplayName() const {
-  return "PassThroughAudioDecoder";
-}
-
-}  // namespace media
diff --git a/media/filters/pass_through_audio_decoder.h b/media/filters/pass_through_audio_decoder.h
deleted file mode 100644
index c19febb..0000000
--- a/media/filters/pass_through_audio_decoder.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_FILTERS_PASS_THROUGH_AUDIO_DECODER_H_
-#define MEDIA_FILTERS_PASS_THROUGH_AUDIO_DECODER_H_
-
-#include "media/base/audio_decoder.h"
-#include "media/filters/pass_through_decoder_impl.h"
-
-namespace media {
-
-class MEDIA_EXPORT PassThroughAudioDecoder : public AudioDecoder {
- public:
-  explicit PassThroughAudioDecoder(
-      const scoped_refptr<base::SingleThreadTaskRunner>& task_runner);
-  ~PassThroughAudioDecoder() override;
-
-  // AudioDecoder implementation.
-  void Initialize(const AudioDecoderConfig& config,
-                  CdmContext* cdm_context,
-                  const InitCB& init_cb,
-                  const OutputCB& output_cb) override;
-  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
-              const DecodeCB& decode_cb) override;
-  void Reset(const base::Closure& closure) override;
-  std::string GetDisplayName() const override;
-
- private:
-  PassThroughDecoderImpl<DemuxerStream::AUDIO> impl_;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_PASS_THROUGH_AUDIO_DECODER_H_
diff --git a/media/filters/pass_through_decoder_impl.cc b/media/filters/pass_through_decoder_impl.cc
deleted file mode 100644
index ba4c210..0000000
--- a/media/filters/pass_through_decoder_impl.cc
+++ /dev/null
@@ -1,190 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/filters/pass_through_decoder_impl.h"
-
-#include "base/bind.h"
-#include "base/location.h"
-#include "base/synchronization/waitable_event.h"
-#include "media/base/audio_buffer.h"
-#include "media/base/decoder_buffer.h"
-#include "media/base/video_frame.h"
-#include "media/filters/platform_media_pipeline_types.h"
-#include "third_party/skia/include/core/SkBitmap.h"
-
-namespace media {
-
-namespace {
-
-// This function is used as observer of frame of
-// VideoFrame::WrapExternalYuvData to make sure we keep reference to
-// DecoderBuffer object as long as we need it.
-void BufferHolder(const scoped_refptr<DecoderBuffer>& buffer) {
-  /* Intentionally empty */
-}
-
-const PlatformVideoConfig::Plane* GetPlanes(const VideoDecoderConfig& config) {
-  DCHECK(!config.extra_data().empty());
-  return reinterpret_cast<const PlatformVideoConfig::Plane*>(
-      &config.extra_data().front());
-}
-
-scoped_refptr<VideoFrame> GetVideoFrameFromMemory(
-    const scoped_refptr<DecoderBuffer>& buffer,
-    const VideoDecoderConfig& config) {
-  const PlatformVideoConfig::Plane* planes = GetPlanes(config);
-
-  for (size_t i = 0; i < VideoFrame::NumPlanes(PIXEL_FORMAT_YV12); ++i) {
-    if (planes[i].offset + planes[i].size > int(buffer->data_size())) {
-      DLOG(ERROR) << "Buffer doesn't match video format";
-      return nullptr;
-    }
-  }
-
-  // We need to ensure that our data buffer stays valid long enough.
-  // For this reason we pass it as an argument to |no_longer_needed_cb|, this
-  // way, thanks to base::Bind, we keep reference to the buffer.
-  scoped_refptr<VideoFrame> frame = VideoFrame::WrapExternalYuvData(
-      config.format(), config.coded_size(), config.visible_rect(),
-      config.natural_size(), planes[VideoFrame::kYPlane].stride,
-      planes[VideoFrame::kUPlane].stride, planes[VideoFrame::kVPlane].stride,
-      const_cast<uint8_t*>(buffer->data() + planes[VideoFrame::kYPlane].offset),
-      const_cast<uint8_t*>(buffer->data() + planes[VideoFrame::kUPlane].offset),
-      const_cast<uint8_t*>(buffer->data() + planes[VideoFrame::kVPlane].offset),
-      buffer->timestamp());
-  frame->AddDestructionObserver(base::Bind(&BufferHolder, buffer));
-  return frame;
-}
-
-scoped_refptr<VideoFrame> GetVideoFrameFromTexture(
-    const scoped_refptr<DecoderBuffer>& buffer,
-    const VideoDecoderConfig& config,
-    scoped_ptr<media::PassThroughDecoderTexture> texture) {
-  DCHECK(texture);
-  return VideoFrame::WrapNativeTexture(PIXEL_FORMAT_ARGB,
-      *texture->mailbox_holder, texture->mailbox_holder_release_cb,
-      config.coded_size(), config.visible_rect(), config.natural_size(),
-      buffer->timestamp());
-}
-
-}  // namespace
-
-template <DemuxerStream::Type StreamType>
-PassThroughDecoderImpl<StreamType>::PassThroughDecoderImpl(
-    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner)
-    : task_runner_(task_runner) {
-}
-
-template <DemuxerStream::Type StreamType>
-void PassThroughDecoderImpl<StreamType>::Initialize(
-    const DecoderConfig& config,
-    const InitCB& init_cb,
-    const OutputCB& output_cb) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(task_runner_->BelongsToCurrentThread());
-  DCHECK(config.IsValidConfig());
-
-  if (!IsValidConfig(config)) {
-    task_runner_->PostTask(FROM_HERE, base::Bind(init_cb, false));
-    return;
-  }
-
-  config_ = config;
-  output_cb_ = output_cb;
-
-  task_runner_->PostTask(FROM_HERE, base::Bind(init_cb, true));
-}
-
-template <DemuxerStream::Type StreamType>
-void PassThroughDecoderImpl<StreamType>::Decode(
-    const scoped_refptr<DecoderBuffer>& buffer,
-    const DecodeCB& decode_cb) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-  DCHECK(IsValidConfig(config_));
-
-  typename media::DecodeStatus status = media::DecodeStatus::OK;
-
-  if (!buffer->end_of_stream()) {
-    scoped_refptr<OutputType> output;
-    if (buffer->data_size() > 0)
-      output = DecoderBufferToOutputBuffer(buffer);
-    else
-      DVLOG(1) << "Detected " << DecoderTraits::ToString() << " decoding error";
-
-    if (output)
-      task_runner_->PostTask(FROM_HERE, base::Bind(output_cb_, output));
-    else
-      status = media::DecodeStatus::DECODE_ERROR;
-  }
-
-  task_runner_->PostTask(FROM_HERE, base::Bind(decode_cb, status));
-}
-
-template <DemuxerStream::Type StreamType>
-void PassThroughDecoderImpl<StreamType>::Reset(const base::Closure& closure) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-  task_runner_->PostTask(FROM_HERE, closure);
-}
-
-template <>
-bool PassThroughDecoderImpl<DemuxerStream::AUDIO>::IsValidConfig(
-    const DecoderConfig& config) {
-  return config.codec() == kCodecPCM &&
-         ChannelLayoutToChannelCount(config.channel_layout()) > 0 &&
-         config.bytes_per_frame() > 0;
-}
-
-template <>
-bool PassThroughDecoderImpl<DemuxerStream::VIDEO>::IsValidConfig(
-    const DecoderConfig& config) {
-  return config.codec() == kCodecH264 &&
-         config.extra_data().size() == sizeof(PlatformVideoConfig().planes);
-}
-
-template <>
-scoped_refptr<AudioBuffer>
-PassThroughDecoderImpl<DemuxerStream::AUDIO>::DecoderBufferToOutputBuffer(
-    const scoped_refptr<DecoderBuffer>& buffer) const {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  const int channel_count =
-      ChannelLayoutToChannelCount(config_.channel_layout());
-
-  const int channel_size = buffer->data_size() / channel_count;
-  const int frame_count = buffer->data_size() / config_.bytes_per_frame();
-
-  typedef const uint8_t* ChannelData;
-  scoped_ptr<ChannelData[]> data(new ChannelData[channel_count]);
-  for (int channel = 0; channel < channel_count; ++channel)
-    data[channel] = buffer->data() + channel * channel_size;
-
-  return AudioBuffer::CopyFrom(config_.sample_format(),
-                               config_.channel_layout(),
-                               channel_count,
-                               config_.samples_per_second(),
-                               frame_count,
-                               data.get(),
-                               buffer->timestamp());
-}
-
-template <>
-scoped_refptr<VideoFrame>
-PassThroughDecoderImpl<DemuxerStream::VIDEO>::DecoderBufferToOutputBuffer(
-    const scoped_refptr<DecoderBuffer>& buffer) const {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  scoped_ptr<AutoReleasedPassThroughDecoderTexture> wrapped_texture =
-      buffer->PassWrappedTexture();
-  if (wrapped_texture)
-    return GetVideoFrameFromTexture(buffer, config_, wrapped_texture->Pass());
-
-  return GetVideoFrameFromMemory(buffer, config_);
-}
-
-template class PassThroughDecoderImpl<DemuxerStream::AUDIO>;
-template class PassThroughDecoderImpl<DemuxerStream::VIDEO>;
-
-}  // namespace media
diff --git a/media/filters/pass_through_decoder_impl.h b/media/filters/pass_through_decoder_impl.h
deleted file mode 100644
index f4743a7..0000000
--- a/media/filters/pass_through_decoder_impl.h
+++ /dev/null
@@ -1,74 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#ifndef MEDIA_FILTERS_PASS_THROUGH_DECODER_IMPL_H_
-#define MEDIA_FILTERS_PASS_THROUGH_DECODER_IMPL_H_
-
-#include "base/single_thread_task_runner.h"
-#include "media/base/audio_decoder.h"
-#include "media/base/audio_decoder_config.h"
-#include "media/base/demuxer_stream.h"
-#include "media/base/video_decoder.h"
-#include "media/base/video_decoder_config.h"
-#include "media/filters/decoder_stream_traits.h"
-
-namespace media {
-
-template <DemuxerStream::Type StreamType>
-struct PassThroughDecoderImplTraits : public DecoderStreamTraits<StreamType> {};
-
-template <>
-struct PassThroughDecoderImplTraits<DemuxerStream::AUDIO>
-    : public DecoderStreamTraits<DemuxerStream::AUDIO> {
-  using DecoderConfigType = AudioDecoderConfig;
-};
-
-template <>
-struct PassThroughDecoderImplTraits<DemuxerStream::VIDEO>
-    : public DecoderStreamTraits<DemuxerStream::VIDEO> {
-  using DecoderConfigType = VideoDecoderConfig;
-};
-
-// A pass-through decoder is not a real media decoder, because the input and
-// output formats are always the same.  Its job is to repackage decoded media
-// data from DecoderBuffers into media-type-specific output buffers.
-template <DemuxerStream::Type StreamType>
-class PassThroughDecoderImpl {
- public:
-  using DecoderTraits = PassThroughDecoderImplTraits<StreamType>;
-  using DecoderConfig = typename DecoderTraits::DecoderConfigType;
-  using DecoderType = typename DecoderTraits::DecoderType;
-  using DecodeCB = typename DecoderType::DecodeCB;
-  using InitCB = typename DecoderType::InitCB;
-  using OutputCB = typename DecoderTraits::OutputCB;
-  using OutputType = typename DecoderTraits::OutputType;
-
-  explicit PassThroughDecoderImpl(
-      const scoped_refptr<base::SingleThreadTaskRunner>& task_runner);
-
-  void Initialize(const DecoderConfig& config,
-                  const InitCB& init_cb,
-                  const OutputCB& output_cb);
-  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
-              const DecodeCB& decode_cb);
-  void Reset(const base::Closure& closure);
-
- private:
-  // Performs decoder config checks specific to the pass-through decoder,
-  // beyond the generic DecoderConfig::IsValidConfig() check.
-  static bool IsValidConfig(const DecoderConfig& config);
-
-  scoped_refptr<OutputType> DecoderBufferToOutputBuffer(
-      const scoped_refptr<DecoderBuffer>& buffer) const;
-
-  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-  DecoderConfig config_;
-  OutputCB output_cb_;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_PASS_THROUGH_DECODER_IMPL_H_
diff --git a/media/filters/pass_through_decoder_texture.cc b/media/filters/pass_through_decoder_texture.cc
deleted file mode 100644
index 11344d5..0000000
--- a/media/filters/pass_through_decoder_texture.cc
+++ /dev/null
@@ -1,29 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/pass_through_decoder_texture.h"
-
-namespace media {
-
-PassThroughDecoderTexture::PassThroughDecoderTexture() = default;
-PassThroughDecoderTexture::~PassThroughDecoderTexture() = default;
-
-AutoReleasedPassThroughDecoderTexture::AutoReleasedPassThroughDecoderTexture(
-    scoped_ptr<PassThroughDecoderTexture> texture)
-    : texture_(std::move(texture)) {
-  DCHECK(texture_);
-}
-
-AutoReleasedPassThroughDecoderTexture::
-    ~AutoReleasedPassThroughDecoderTexture() {
-  // The texture didn't reach its user, it has to be released.
-  if (texture_) {
-    texture_->mailbox_holder_release_cb.Run(
-        texture_->mailbox_holder->sync_token);
-  }
-}
-
-}  // namespace media
diff --git a/media/filters/pass_through_decoder_texture.h b/media/filters/pass_through_decoder_texture.h
deleted file mode 100644
index 7853d9d..0000000
--- a/media/filters/pass_through_decoder_texture.h
+++ /dev/null
@@ -1,49 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_PASS_THROUGH_DECODER_TEXTURE_H_
-#define MEDIA_FILTERS_PASS_THROUGH_DECODER_TEXTURE_H_
-
-#include "base/memory/scoped_ptr.h"
-#include "gpu/command_buffer/common/mailbox_holder.h"
-#include "media/base/video_frame.h"
-
-namespace media {
-
-struct MEDIA_EXPORT PassThroughDecoderTexture {
-  PassThroughDecoderTexture();
-  ~PassThroughDecoderTexture();
-
-  uint32_t texture_id;
-  scoped_ptr<gpu::MailboxHolder> mailbox_holder;
-  VideoFrame::ReleaseMailboxCB mailbox_holder_release_cb;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(PassThroughDecoderTexture);
-};
-
-// Ensures that texture described by PassThroughDecoderTexture object is
-// properly released if it doesn't reach its final user.
-class MEDIA_EXPORT AutoReleasedPassThroughDecoderTexture {
- public:
-  explicit AutoReleasedPassThroughDecoderTexture(
-      scoped_ptr<PassThroughDecoderTexture> texture);
-  ~AutoReleasedPassThroughDecoderTexture();
-
-  scoped_ptr<PassThroughDecoderTexture> Pass() {
-    DCHECK(texture_);
-    return std::move(texture_);
-  }
-
- private:
-  scoped_ptr<PassThroughDecoderTexture> texture_;
-
-  DISALLOW_COPY_AND_ASSIGN(AutoReleasedPassThroughDecoderTexture);
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_PASS_THROUGH_DECODER_TEXTURE_H_
diff --git a/media/filters/pass_through_video_decoder.cc b/media/filters/pass_through_video_decoder.cc
deleted file mode 100644
index 0afa4f2..0000000
--- a/media/filters/pass_through_video_decoder.cc
+++ /dev/null
@@ -1,41 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/pass_through_video_decoder.h"
-
-namespace media {
-
-PassThroughVideoDecoder::PassThroughVideoDecoder(
-    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner)
-    : impl_(task_runner) {
-}
-
-PassThroughVideoDecoder::~PassThroughVideoDecoder() {
-}
-
-void PassThroughVideoDecoder::Initialize(const VideoDecoderConfig& config,
-                                         bool low_delay,
-                                         CdmContext* cdm_context,
-                                         const InitCB& init_cb,
-                                         const OutputCB& output_cb) {
-  impl_.Initialize(config, init_cb, output_cb);
-}
-
-void PassThroughVideoDecoder::Decode(
-    const scoped_refptr<DecoderBuffer>& buffer,
-    const DecodeCB& decode_cb) {
-  impl_.Decode(buffer, decode_cb);
-}
-
-void PassThroughVideoDecoder::Reset(const base::Closure& closure) {
-  impl_.Reset(closure);
-}
-
-std::string PassThroughVideoDecoder::GetDisplayName() const {
-  return "PassThroughVideoDecoder";
-}
-
-}  // namespace media
diff --git a/media/filters/pass_through_video_decoder.h b/media/filters/pass_through_video_decoder.h
deleted file mode 100644
index c11985e..0000000
--- a/media/filters/pass_through_video_decoder.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_PASS_THROUGH_VIDEO_DECODER_H_
-#define MEDIA_FILTERS_PASS_THROUGH_VIDEO_DECODER_H_
-
-#include "media/base/video_decoder.h"
-#include "media/filters/pass_through_decoder_impl.h"
-
-namespace media {
-
-class MEDIA_EXPORT PassThroughVideoDecoder : public VideoDecoder {
- public:
-  explicit PassThroughVideoDecoder(
-      const scoped_refptr<base::SingleThreadTaskRunner>& task_runner);
-  ~PassThroughVideoDecoder() override;
-
-  // VideoDecoder implementation.
-  void Initialize(const VideoDecoderConfig& config,
-                  bool low_delay,
-                  CdmContext* cdm_context,
-                  const InitCB& init_cb,
-                  const OutputCB& output_cb) override;
-  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
-              const DecodeCB& decode_cb) override;
-  void Reset(const base::Closure& closure) override;
-  std::string GetDisplayName() const override;
-
- private:
-  PassThroughDecoderImpl<DemuxerStream::VIDEO> impl_;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_PASS_THROUGH_VIDEO_DECODER_H_
diff --git a/media/filters/platform_media_pipeline_constants.cc b/media/filters/platform_media_pipeline_constants.cc
deleted file mode 100644
index 741b010..0000000
--- a/media/filters/platform_media_pipeline_constants.cc
+++ /dev/null
@@ -1,25 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/platform_media_pipeline_constants.h"
-
-#include "build/build_config.h"
-
-#if defined(OS_WIN)
-#include <windows.h>  // Required by <GL/gl.h> on Windows.
-#include <GL/gl.h>
-#endif  // defined(OS_WIN)
-
-#if defined(OS_MACOSX)
-#include <OpenGL/gl.h>
-#endif  // defined(OS_MACOSX)
-
-namespace media {
-
-const GLenum kPlatformMediaPipelineTextureFormat = GL_BGRA_EXT;
-const uint32_t kPlatformMediaPipelineTextureTarget = GL_TEXTURE_2D;
-
-}  // namespace media
diff --git a/media/filters/platform_media_pipeline_constants.h b/media/filters/platform_media_pipeline_constants.h
deleted file mode 100644
index 8d1e286..0000000
--- a/media/filters/platform_media_pipeline_constants.h
+++ /dev/null
@@ -1,22 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_PLATFORM_MEDIA_PIPELINE_CONSTANTS_H_
-#define MEDIA_FILTERS_PLATFORM_MEDIA_PIPELINE_CONSTANTS_H_
-
-#include <stdint.h>
-
-#include "gpu/command_buffer/common/gles2_cmd_format.h"
-#include "media/base/media_export.h"
-
-namespace media {
-
-MEDIA_EXPORT extern const GLenum kPlatformMediaPipelineTextureFormat;
-MEDIA_EXPORT extern const uint32_t kPlatformMediaPipelineTextureTarget;
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_PLATFORM_MEDIA_PIPELINE_CONSTANTS_H_
diff --git a/media/filters/platform_media_pipeline_types.cc b/media/filters/platform_media_pipeline_types.cc
deleted file mode 100644
index 707a7cd..0000000
--- a/media/filters/platform_media_pipeline_types.cc
+++ /dev/null
@@ -1,18 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/platform_media_pipeline_types.h"
-
-namespace media {
-
-PlatformVideoConfig::PlatformVideoConfig()
-    : rotation(VIDEO_ROTATION_0),
-      decoding_mode(PlatformMediaDecodingMode::SOFTWARE) {}
-
-PlatformVideoConfig::~PlatformVideoConfig() {
-}
-
-}  // namespace media
diff --git a/media/filters/platform_media_pipeline_types.h b/media/filters/platform_media_pipeline_types.h
deleted file mode 100644
index 62b46ce..0000000
--- a/media/filters/platform_media_pipeline_types.h
+++ /dev/null
@@ -1,93 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_PLATFORM_MEDIA_PIPELINE_TYPES_H_
-#define MEDIA_FILTERS_PLATFORM_MEDIA_PIPELINE_TYPES_H_
-
-#include "media/base/sample_format.h"
-#include "media/base/video_frame.h"
-#include "media/base/video_rotation.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/geometry/size.h"
-
-namespace media {
-
-// Order is important, be careful when adding new values.
-enum PlatformMediaDataType {
-  PLATFORM_MEDIA_AUDIO,
-  PLATFORM_MEDIA_VIDEO,
-  PLATFORM_MEDIA_DATA_TYPE_COUNT  // Always keep this as the last one.
-};
-
-enum MediaDataStatus {
-  kOk,
-  kEOS,
-  kError,
-  kConfigChanged,
-  kMediaDataStatusCount,
-};
-
-// Order is important, be careful when adding new values.
-enum class PlatformMediaDecodingMode {
-  SOFTWARE,
-  HARDWARE,
-  COUNT  // Always keep this as the last one.
-};
-
-struct PlatformMediaTimeInfo {
-  base::TimeDelta duration;
-  base::TimeDelta start_time;
-};
-
-struct PlatformAudioConfig {
-  PlatformAudioConfig()
-      : format(kUnknownSampleFormat),
-        channel_count(-1),
-        samples_per_second(-1) {}
-
-  bool is_valid() const {
-    return channel_count > 0 && samples_per_second > 0 &&
-           format != kUnknownSampleFormat;
-  }
-
-  media::SampleFormat format;
-  int channel_count;
-  int samples_per_second;
-};
-
-struct MEDIA_EXPORT PlatformVideoConfig {
-  struct Plane {
-    Plane() : stride(-1), offset(-1) {}
-
-    bool is_valid() const { return stride > 0 && offset >= 0 && size > 0; }
-
-    int stride;
-    int offset;
-    int size;
-  };
-
-  PlatformVideoConfig();
-  ~PlatformVideoConfig();
-
-  bool is_valid() const {
-    return !coded_size.IsEmpty() && !visible_rect.IsEmpty() &&
-           !natural_size.IsEmpty() && planes[VideoFrame::kYPlane].is_valid() &&
-           planes[VideoFrame::kVPlane].is_valid() &&
-           planes[VideoFrame::kUPlane].is_valid() &&
-           decoding_mode < PlatformMediaDecodingMode::COUNT;
-  }
-
-  gfx::Size coded_size;
-  gfx::Rect visible_rect;
-  gfx::Size natural_size;
-  Plane planes[VideoFrame::kMaxPlanes];
-  VideoRotation rotation;
-  PlatformMediaDecodingMode decoding_mode;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_PLATFORM_MEDIA_PIPELINE_TYPES_H_
diff --git a/media/filters/platform_media_pipeline_types_mac.h b/media/filters/platform_media_pipeline_types_mac.h
deleted file mode 100644
index 3c13ae6..0000000
--- a/media/filters/platform_media_pipeline_types_mac.h
+++ /dev/null
@@ -1,26 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_PLATFORM_MEDIA_PIPELINE_TYPES_MAC_H_
-#define MEDIA_FILTERS_PLATFORM_MEDIA_PIPELINE_TYPES_MAC_H_
-
-#include "media/filters/platform_media_pipeline_types.h"
-
-struct AudioStreamBasicDescription;
-@class AVAssetTrack;
-typedef const struct opaqueCMFormatDescription* CMFormatDescriptionRef;
-
-namespace media {
-
-base::TimeDelta MEDIA_EXPORT GetStartTimeFromTrack(AVAssetTrack* track);
-
-PlatformVideoConfig MEDIA_EXPORT GetPlatformVideoConfig(
-    CMFormatDescriptionRef description,
-    CGAffineTransform transform);
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_PLATFORM_MEDIA_PIPELINE_TYPES_MAC_H_
diff --git a/media/filters/platform_media_pipeline_types_mac.mm b/media/filters/platform_media_pipeline_types_mac.mm
deleted file mode 100644
index 5908844..0000000
--- a/media/filters/platform_media_pipeline_types_mac.mm
+++ /dev/null
@@ -1,125 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/platform_media_pipeline_types_mac.h"
-
-#import <AVFoundation/AVFoundation.h>
-#include <CoreAudio/CoreAudio.h>
-#import <Foundation/Foundation.h>
-
-#include "media/base/mac/coremedia_glue.h"
-#include "media/base/mac/framework_type_conversions.h"
-
-namespace media {
-
-namespace {
-
-VideoRotation AffineTransformToVideoRotation(
-    const CGAffineTransform& transform,
-    const gfx::Size& size) {
-  // See CGAffineTransform documentation for the meaning of the transformation
-  // matrix.
-  const struct {
-    CGAffineTransform transform;
-    VideoRotation rotation;
-  } kRotationMap[] = {
-        {{1, 0, 0, 1, 0, 0}, VIDEO_ROTATION_0},
-        {{0, 1, -1, 0, size.height(), 0}, VIDEO_ROTATION_90},
-        {{-1, 0, 0, -1, size.width(), size.height()}, VIDEO_ROTATION_180},
-        {{0, -1, 1, 0, 0, size.width()}, VIDEO_ROTATION_270},
-    };
-
-  for (size_t i = 0; i < arraysize(kRotationMap); ++i) {
-    if (CGAffineTransformEqualToTransform(transform, kRotationMap[i].transform))
-      return kRotationMap[i].rotation;
-  }
-
-  DVLOG(1) << "Unsupported affine transform, ignoring";
-  return VIDEO_ROTATION_0;
-}
-
-}  // namespace
-
-base::TimeDelta GetStartTimeFromTrack(AVAssetTrack* track) {
-  base::TimeDelta start_time;
-
-  for (AVAssetTrackSegment* segment in [track segments]) {
-    const CMTimeMapping mapping = [segment timeMapping];
-    // The start time is determined by the first valid track segment.
-    if (CMTIME_IS_VALID(mapping.source.start) &&
-        CMTIME_IS_VALID(mapping.target.start)) {
-      start_time = CMTimeToTimeDelta(mapping.target.start) -
-                   CMTimeToTimeDelta(mapping.source.start);
-      break;
-    }
-  }
-
-  return start_time;
-}
-
-PlatformVideoConfig GetPlatformVideoConfig(CMFormatDescriptionRef description,
-                                           CGAffineTransform transform) {
-  PlatformVideoConfig video_config;
-
-  const CoreMediaGlue::CMVideoDimensions coded_size =
-      CoreMediaGlue::CMVideoFormatDescriptionGetDimensions(description);
-  video_config.coded_size = gfx::Size(coded_size.width, coded_size.height);
-
-  video_config.visible_rect = gfx::Rect(
-      CoreMediaGlue::CMVideoFormatDescriptionGetCleanAperture(description, NO));
-
-  video_config.natural_size =
-      CoreMediaGlue::CMVideoFormatDescriptionGetPresentationDimensions(
-          description, YES, NO);
-
-  // An even width/height makes things easier for YV12 and appears to be the
-  // behavior expected by WebKit layout tests.
-  video_config.natural_size =
-      gfx::Size(video_config.natural_size.width() & ~1,
-                video_config.natural_size.height() & ~1);
-
-  // TODO(mkoss): Tentative implementation of stride calculation based on width.
-  // The stride must be a multiple of 32 for each plane.
-  video_config.planes[VideoFrame::kYPlane].stride =
-      (video_config.coded_size.width() + 31) & ~31;
-  video_config.planes[VideoFrame::kVPlane].stride =
-      (video_config.planes[VideoFrame::kYPlane].stride / 2 + 31) & ~31;
-  video_config.planes[VideoFrame::kUPlane].stride =
-      video_config.planes[VideoFrame::kVPlane].stride;
-
-  int rows = video_config.coded_size.height();
-
-  // Y plane is first and is not downsampled.
-  video_config.planes[VideoFrame::kYPlane].offset = 0;
-  video_config.planes[VideoFrame::kYPlane].size =
-      rows * video_config.planes[VideoFrame::kYPlane].stride;
-
-  // In YV12, V and U planes are downsampled vertically and horizontally by 2.
-  rows /= 2;
-
-  // V plane precedes U.
-  video_config.planes[VideoFrame::kVPlane].offset =
-      video_config.planes[VideoFrame::kYPlane].offset +
-      video_config.planes[VideoFrame::kYPlane].size;
-  video_config.planes[VideoFrame::kVPlane].size =
-      rows * video_config.planes[VideoFrame::kVPlane].stride;
-
-  video_config.planes[VideoFrame::kUPlane].offset =
-      video_config.planes[VideoFrame::kVPlane].offset +
-      video_config.planes[VideoFrame::kVPlane].size;
-  video_config.planes[VideoFrame::kUPlane].size =
-      rows * video_config.planes[VideoFrame::kUPlane].stride;
-
-  video_config.rotation = AffineTransformToVideoRotation(
-      transform,
-      gfx::Size(
-          CoreMediaGlue::CMVideoFormatDescriptionGetPresentationDimensions(
-              description, YES, NO)));
-
-  return video_config;
-}
-
-}  // namespace media
diff --git a/media/filters/protocol_sniffer.cc b/media/filters/protocol_sniffer.cc
deleted file mode 100644
index e4ada66..0000000
--- a/media/filters/protocol_sniffer.cc
+++ /dev/null
@@ -1,95 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/protocol_sniffer.h"
-
-#include "base/bind.h"
-#include "base/bind_helpers.h"
-#include "media/base/container_names.h"
-#include "media/base/data_source.h"
-
-namespace media {
-
-namespace {
-
-std::string DetermineContainer(const uint8_t* data, size_t data_size) {
-  const container_names::MediaContainerName container =
-      container_names::OperaDetermineContainer(data, data_size);
-
-  switch (container) {
-    case container_names::CONTAINER_AAC:
-      return "audio/aac";
-
-    case container_names::CONTAINER_MP3:
-      return "audio/mp3";
-
-    case container_names::CONTAINER_WAV:
-      return "audio/wav";
-
-    case container_names::CONTAINER_H264:
-      return "video/mp4";
-
-    default:
-      break;
-  }
-
-  // Also check for Shoutcast, a popular live streaming protocol.
-  if (data_size >= 3 && data[0] == 'I' && data[1] == 'C' && data[2] == 'Y')
-    return "audio/mp3";
-
-  // It might happen that we do not have enough data to correctly sniff mp3 with
-  // OperaDetermineContainer, so we assume mp3 just by checking the header tag.
-  if (data_size >= 3 && data[0] == 'I' && data[1] == 'D' && data[2] == '3')
-    return "audio/mp3";
-
-  return std::string();
-}
-
-}  // namespace
-
-ProtocolSniffer::ProtocolSniffer() : weak_ptr_factory_(this) {
-}
-
-ProtocolSniffer::~ProtocolSniffer() {
-  DCHECK(thread_checker_.CalledOnValidThread());
-}
-
-// static
-bool ProtocolSniffer::ShouldSniffProtocol(const std::string& content_type) {
-  return content_type == "application/octet-stream" ||
-         content_type == "binary/octet-stream";
-}
-
-void ProtocolSniffer::SniffProtocol(DataSource* data_source,
-                                    const Callback& callback) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  DCHECK(data_source);
-
-  // We read the first 8192 bytes, same as FFmpeg.
-  static const size_t kDataSize = 8192;
-  scoped_ptr<uint8_t[]> data_holder(new uint8_t[kDataSize]);
-  uint8_t* data = data_holder.get();
-
-  data_source->Read(
-      0, kDataSize, data,
-      base::Bind(&ProtocolSniffer::ReadDone, weak_ptr_factory_.GetWeakPtr(),
-                 base::Passed(&data_holder), callback));
-}
-
-void ProtocolSniffer::ReadDone(scoped_ptr<uint8_t[]> data,
-                               const Callback& callback,
-                               int size_read) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-
-  std::string mime_type;
-
-  if (size_read != DataSource::kReadError)
-    mime_type = DetermineContainer(data.get(), size_read);
-
-  callback.Run(mime_type);
-}
-
-}  // namespace media
diff --git a/media/filters/protocol_sniffer.h b/media/filters/protocol_sniffer.h
deleted file mode 100644
index 6db09d9..0000000
--- a/media/filters/protocol_sniffer.h
+++ /dev/null
@@ -1,51 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2014 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_PROTOCOL_SNIFFER_H_
-#define MEDIA_FILTERS_PROTOCOL_SNIFFER_H_
-
-#include <string>
-
-#include "base/callback.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/memory/weak_ptr.h"
-#include "base/threading/thread_checker.h"
-#include "media/base/media_export.h"
-
-namespace media {
-
-class DataSource;
-
-// When media data is not transferred through HTTP we can't determine support
-// by looking at the Content Type header, so we need to read the first few
-// bytes and try to guess the actual media type.
-class MEDIA_EXPORT ProtocolSniffer {
- public:
-  // Called when sniffing is complete.  |mime_type| contains the media type
-  // detected, or is empty on failure to detect.
-  using Callback = base::Callback<void(const std::string& mime_type)>;
-
-  ProtocolSniffer();
-  ~ProtocolSniffer();
-
-  static bool ShouldSniffProtocol(const std::string& content_type);
-
-  void SniffProtocol(DataSource* data_source, const Callback& callback);
-
- private:
-  void ReadDone(scoped_ptr<uint8_t[]> data,
-                const Callback& callback,
-                int size_read);
-
-  base::ThreadChecker thread_checker_;
-  base::WeakPtrFactory<ProtocolSniffer> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(ProtocolSniffer);
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_PROTOCOL_SNIFFER_H_
diff --git a/media/filters/stream_parser_factory.cc b/media/filters/stream_parser_factory.cc
index 851babf..693e651 100644
--- a/media/filters/stream_parser_factory.cc
+++ b/media/filters/stream_parser_factory.cc
@@ -26,10 +26,6 @@
 #endif
 
 #if defined(USE_PROPRIETARY_CODECS)
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "base/features/features.h"
-#include "media/base/platform_mime_util.h"
-#endif
 #if BUILDFLAG(ENABLE_MSE_MPEG2TS_STREAM_PARSER)
 #include "media/formats/mp2t/mp2t_stream_parser.h"
 #endif
@@ -330,17 +326,6 @@ static bool VerifyCodec(
     std::vector<CodecInfo::HistogramTag>* video_codecs) {
   switch (codec_info->type) {
     case CodecInfo::AUDIO:
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-      if (codec_info->tag == CodecInfo::HISTOGRAM_MP3) {
-        if (!IsPlatformAudioDecoderAvailable(kCodecMP3))
-          return false;
-      }
-      if (codec_info->tag == CodecInfo::HISTOGRAM_MPEG2AAC ||
-          codec_info->tag == CodecInfo::HISTOGRAM_MPEG4AAC) {
-        if (!IsPlatformAudioDecoderAvailable(kCodecAAC))
-          return false;
-      }
-#endif
       if (audio_codecs)
         audio_codecs->push_back(codec_info->tag);
       return true;
@@ -373,12 +358,6 @@ static bool VerifyCodec(
         return false;
       }
 #endif
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-      if (codec_info->tag == CodecInfo::HISTOGRAM_H264) {
-        if (!IsPlatformVideoDecoderAvailable())
-          return false;
-      }
-#endif
       if (video_codecs)
         video_codecs->push_back(codec_info->tag);
       return true;
@@ -411,16 +390,9 @@ static bool CheckTypeAndCodecs(
     ParserFactoryFunction* factory_function,
     std::vector<CodecInfo::HistogramTag>* audio_codecs,
     std::vector<CodecInfo::HistogramTag>* video_codecs) {
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (type == "audio/aac" || type == "audio/mpeg") {
-    if (!base::IsFeatureEnabled(base::kFeatureMseAudioMpegAac))
-      return false;
-  }
-#endif
   // Search for the SupportedTypeInfo for |type|.
   for (size_t i = 0; i < arraysize(kSupportedTypeInfo); ++i) {
     const SupportedTypeInfo& type_info = kSupportedTypeInfo[i];
-
     if (type == type_info.type) {
       if (codecs.empty()) {
         const CodecInfo* codec_info = type_info.codecs[0];
diff --git a/media/filters/wmf_audio_decoder.cc b/media/filters/wmf_audio_decoder.cc
deleted file mode 100644
index 181bc18..0000000
--- a/media/filters/wmf_audio_decoder.cc
+++ /dev/null
@@ -1,43 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/wmf_audio_decoder.h"
-
-#include "media/base/pipeline_stats.h"
-
-namespace media {
-
-WMFAudioDecoder::WMFAudioDecoder(
-    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner)
-    : impl_(task_runner) {
-}
-
-WMFAudioDecoder::~WMFAudioDecoder() {
-}
-
-std::string WMFAudioDecoder::GetDisplayName() const {
-  return "WMFAudioDecoder";
-}
-
-void WMFAudioDecoder::Initialize(const AudioDecoderConfig& config,
-                                 CdmContext* cdm_context,
-                                 const InitCB& init_cb,
-                                 const OutputCB& output_cb) {
-  pipeline_stats::AddDecoderClass(GetDisplayName());
-
-  impl_.Initialize(config, init_cb, output_cb);
-}
-
-void WMFAudioDecoder::Decode(const scoped_refptr<DecoderBuffer>& buffer,
-                             const DecodeCB& decode_cb) {
-  impl_.Decode(buffer, decode_cb);
-}
-
-void WMFAudioDecoder::Reset(const base::Closure& closure) {
-  impl_.Reset(closure);
-}
-
-}  // namespace media
diff --git a/media/filters/wmf_audio_decoder.h b/media/filters/wmf_audio_decoder.h
deleted file mode 100644
index e962646..0000000
--- a/media/filters/wmf_audio_decoder.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_WMF_AUDIO_DECODER_H_
-#define MEDIA_FILTERS_WMF_AUDIO_DECODER_H_
-
-#include <string>
-
-#include "media/base/audio_decoder.h"
-#include "media/filters/wmf_decoder_impl.h"
-
-namespace media {
-
-// Decodes AAC audio streams using Windows Media Foundation library.
-class MEDIA_EXPORT WMFAudioDecoder : public AudioDecoder {
- public:
-  WMFAudioDecoder(
-      const scoped_refptr<base::SingleThreadTaskRunner>& task_runner);
-  ~WMFAudioDecoder() override;
-
-  // AudioDecoder implementation.
-  std::string GetDisplayName() const override;
-  void Initialize(const AudioDecoderConfig& config,
-                  CdmContext* cdm_context,
-                  const InitCB& init_cb,
-                  const OutputCB& output_cb) override;
-  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
-              const DecodeCB& decode_cb) override;
-  void Reset(const base::Closure& closure) override;
-
- private:
-  WMFDecoderImpl<DemuxerStream::AUDIO> impl_;
-
-  DISALLOW_COPY_AND_ASSIGN(WMFAudioDecoder);
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_WMF_AUDIO_DECODER_H_
diff --git a/media/filters/wmf_decoder_impl.cc b/media/filters/wmf_decoder_impl.cc
deleted file mode 100644
index 7c2f7b5..0000000
--- a/media/filters/wmf_decoder_impl.cc
+++ /dev/null
@@ -1,841 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA.
-
-#include "media/filters/wmf_decoder_impl.h"
-
-#include <mferror.h>
-#include <wmcodecdsp.h>
-#include <algorithm>
-#include <string>
-
-#include "base/bind.h"
-#include "base/callback_helpers.h"
-#include "base/command_line.h"
-#include "base/features/features.h"
-#include "base/message_loop/message_loop.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/win/scoped_comptr.h"
-#include "base/win/windows_version.h"
-#include "media/base/audio_buffer.h"
-#include "media/base/channel_layout.h"
-#include "media/base/data_buffer.h"
-#include "media/base/decoder_buffer.h"
-#include "media/base/pipeline_stats.h"
-#include "media/base/platform_mime_util.h"
-#include "media/base/win/mf_initializer.h"
-#include "media/base/win/mf_util.h"
-
-namespace media {
-
-namespace {
-
-template <DemuxerStream::Type StreamType>
-void ReportInitResult(bool success);
-
-template <>
-void ReportInitResult<DemuxerStream::AUDIO>(bool success) {
-  pipeline_stats::ReportAudioDecoderInitResult(success);
-}
-
-template <>
-void ReportInitResult<DemuxerStream::VIDEO>(bool success) {
-  pipeline_stats::ReportVideoDecoderInitResult(success);
-}
-
-// This function is used as |no_longer_needed_cb| of
-// VideoFrame::WrapExternalYuvData to make sure we keep reference to DataBuffer
-// object as long as we need it.
-void BufferHolder(const scoped_refptr<DataBuffer>& buffer) {
-  /* Intentionally empty */
-}
-
-SampleFormat ConvertToSampleFormat(uint32_t sample_size) {
-  // We set output stream to use MFAudioFormat_PCM. MSDN does not state openly
-  // that this is an integer format but there is an example which shows that
-  // floating point PCM audio is set using MFAudioFormat_Float subtype for AAC
-  // decoder, so we have to assume that for an integer format we should use
-  // MFAudioFormat_PCM.
-  switch (sample_size) {
-    case 1:
-      return kSampleFormatU8;
-    case 2:
-      return kSampleFormatS16;
-    case 4:
-      return kSampleFormatS32;
-    default:
-      return kUnknownSampleFormat;
-  }
-}
-
-int CalculateBufferAlignment(DWORD alignment) {
-  return (alignment > 1) ? alignment - 1 : 0;
-}
-
-GUID AudioCodecToAudioSubtypeGUID(AudioCodec codec) {
-  switch (codec) {
-    case kCodecAAC:
-      return MFAudioFormat_AAC;
-    case kCodecMP3:
-      return MFAudioFormat_MP3;
-    default:
-      NOTREACHED();
-  }
-  return GUID();
-}
-
-}  // namespace
-
-template <DemuxerStream::Type StreamType>
-WMFDecoderImpl<StreamType>::WMFDecoderImpl(
-    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner)
-    : task_runner_(task_runner),
-      output_sample_size_(0),
-      get_stride_function_(nullptr) {}
-
-template <DemuxerStream::Type StreamType>
-void WMFDecoderImpl<StreamType>::Initialize(const DecoderConfig& config,
-                                            const InitCB& init_cb,
-                                            const OutputCB& output_cb) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  if (!IsValidConfig(config)) {
-    DVLOG(1) << "Unsupported decoder config";
-    init_cb.Run(false);
-    return;
-  }
-
-  InitializeMediaFoundation();
-
-  config_ = config;
-
-  decoder_ = CreateWMFDecoder(config_);
-  if (!decoder_ || !ConfigureDecoder()) {
-    ReportInitResult<StreamType>(false);
-    init_cb.Run(false);
-    return;
-  }
-
-  output_cb_ = output_cb;
-  ResetTimestampState();
-
-  ReportInitResult<StreamType>(true);
-  init_cb.Run(true);
-}
-
-template <DemuxerStream::Type StreamType>
-void WMFDecoderImpl<StreamType>::Decode(
-    const scoped_refptr<DecoderBuffer>& buffer,
-    const DecodeCB& decode_cb) {
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  if (buffer->end_of_stream()) {
-    DVLOG(5) << __FUNCTION__ << "(EOS)";
-    const bool drained_ok = Drain();
-    task_runner_->PostTask(
-        FROM_HERE,
-        base::Bind(decode_cb,
-                   drained_ok ? media::DecodeStatus::OK : media::DecodeStatus::DECODE_ERROR));
-    return;
-  }
-  DVLOG(5) << __FUNCTION__ << "(" << buffer->timestamp() << ")";
-
-  const HRESULT hr = ProcessInput(buffer);
-  DCHECK_NE(MF_E_NOTACCEPTING, hr)
-      << "The transform is neither producing output "
-         "nor accepting input? This must not happen, see ProcessOutputLoop()";
-  typename media::DecodeStatus status = SUCCEEDED(hr) && ProcessOutputLoop()
-                                            ? media::DecodeStatus::OK
-                                            : media::DecodeStatus::DECODE_ERROR;
-
-  if (status == media::DecodeStatus::OK &&
-      buffer->splice_timestamp() != kNoTimestamp()) {
-    DVLOG(1) << "Splice detected, must drain the decoder";
-    if (!Drain())
-      status = media::DecodeStatus::DECODE_ERROR;
-  }
-
-  task_runner_->PostTask(FROM_HERE, base::Bind(decode_cb, status));
-}
-
-template <DemuxerStream::Type StreamType>
-void WMFDecoderImpl<StreamType>::Reset(const base::Closure& closure) {
-  DVLOG(1) << __FUNCTION__;
-  DCHECK(task_runner_->BelongsToCurrentThread());
-
-  // Transform needs to be reset, skip this and seeking may fail.
-  decoder_->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);
-
-  ResetTimestampState();
-
-  task_runner_->PostTask(FROM_HERE, closure);
-}
-
-template <>
-bool WMFDecoderImpl<DemuxerStream::AUDIO>::IsValidConfig(
-    const DecoderConfig& config) {
-  if (config.codec() == kCodecMP3 &&
-      !base::IsFeatureEnabled(base::kFeatureMseAudioMpegAac)) {
-    return false;
-  }
-
-  if (config.codec() != kCodecMP3 && config.codec() != kCodecAAC)
-    return false;
-
-  return IsPlatformAudioDecoderAvailable(config.codec());
-}
-
-template <>
-bool WMFDecoderImpl<DemuxerStream::VIDEO>::IsValidConfig(
-    const DecoderConfig& config) {
-  if (!IsPlatformVideoDecoderAvailable())
-    return false;
-
-  return config.codec() == kCodecH264 && config.profile() >= H264PROFILE_MIN &&
-         config.profile() <= H264PROFILE_MAX;
-}
-
-// static
-template <>
-std::string WMFDecoderImpl<DemuxerStream::AUDIO>::GetModuleName(
-    const DecoderConfig& config) {
-  return GetMFAudioDecoderLibraryName(config.codec());
-}
-
-// static
-template <>
-std::string WMFDecoderImpl<DemuxerStream::VIDEO>::GetModuleName(
-    const DecoderConfig& /* config */) {
-  return GetMFVideoDecoderLibraryName();
-}
-
-// static
-template <>
-GUID WMFDecoderImpl<DemuxerStream::AUDIO>::GetMediaObjectGUID(
-    const DecoderConfig& config) {
-  switch (config.codec()) {
-    case kCodecAAC:
-      return __uuidof(CMSAACDecMFT);
-    case kCodecMP3:
-      return __uuidof(CMP3DecMediaObject);
-    default:
-      NOTREACHED();
-  }
-  return GUID();
-}
-
-// static
-template <>
-GUID WMFDecoderImpl<DemuxerStream::VIDEO>::GetMediaObjectGUID(
-    const DecoderConfig& /* config */) {
-  return __uuidof(CMSH264DecoderMFT);
-}
-
-// static
-template <DemuxerStream::Type StreamType>
-base::win::ScopedComPtr<IMFTransform>
-WMFDecoderImpl<StreamType>::CreateWMFDecoder(const DecoderConfig& config) {
-  base::win::ScopedComPtr<IMFTransform> decoder;
-
-  // CoCreateInstance() is not avaliable in the sandbox, must "reimplement it".
-  decltype(DllGetClassObject)* const get_class_object =
-      reinterpret_cast<decltype(DllGetClassObject)*>(GetFunctionFromLibrary(
-          "DllGetClassObject", GetModuleName(config).c_str()));
-  if (!get_class_object) {
-    DVLOG(1) << "Error while retrieving class object getter function.";
-    return decoder;
-  }
-
-  base::win::ScopedComPtr<IClassFactory> factory;
-  HRESULT hr =
-      get_class_object(GetMediaObjectGUID(config), __uuidof(IClassFactory),
-                       reinterpret_cast<void**>(factory.Receive()));
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while getting class object.";
-    return decoder;
-  }
-
-  hr = factory->CreateInstance(nullptr, __uuidof(IMFTransform),
-                               reinterpret_cast<void**>(decoder.Receive()));
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while creating decoder instance.";
-    return base::win::ScopedComPtr<IMFTransform>();
-  }
-
-  return decoder;
-}
-
-template <DemuxerStream::Type StreamType>
-bool WMFDecoderImpl<StreamType>::ConfigureDecoder() {
-  if (!SetInputMediaType())
-    return false;
-
-  if (!SetOutputMediaType())
-    return false;
-
-  if (!InitializeDecoderFunctions())
-    return false;
-
-  // It requires both input and output to be set.
-  HRESULT hr = decoder_->GetInputStreamInfo(0, &input_stream_info_);
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while getting input stream info.";
-    return false;
-  }
-
-  return true;
-}
-
-template <>
-bool WMFDecoderImpl<DemuxerStream::AUDIO>::SetInputMediaType() {
-  base::win::ScopedComPtr<IMFMediaType> media_type;
-  HRESULT hr = MFCreateMediaType(media_type.Receive());
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while creating media type.";
-    return false;
-  }
-
-  hr = media_type->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio);
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting media major type.";
-    return false;
-  }
-
-  hr = media_type->SetGUID(MF_MT_SUBTYPE,
-                           AudioCodecToAudioSubtypeGUID(config_.codec()));
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting media subtype.";
-    return false;
-  }
-
-  hr = media_type->SetUINT32(
-      MF_MT_AUDIO_NUM_CHANNELS,
-      ChannelLayoutToChannelCount(config_.channel_layout()));
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting channel number.";
-    return false;
-  }
-
-  hr = media_type->SetUINT32(MF_MT_AUDIO_SAMPLES_PER_SECOND,
-                             config_.input_samples_per_second());
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting samples per second.";
-    return false;
-  }
-
-  if (config_.codec() == kCodecAAC) {
-    hr = media_type->SetUINT32(MF_MT_AAC_PAYLOAD_TYPE, 0x1);
-    if (FAILED(hr)) {
-      DVLOG(1) << "Error while setting AAC payload type.";
-      return false;
-    }
-
-    // AAC decoder requires setting up HEAACWAVEINFO as a MF_MT_USER_DATA,
-    // without this decoder fails to work (e.g. ProcessOutput returns
-    // repeatedly with mysterious MF_E_TRANSFORM_STREAM_CHANGE status).
-    // mt_user_data size is 12 = size of relevant fields of HEAACWAVEINFO
-    // structure, see
-    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd742784%28v=vs.85%29.aspx
-    uint8_t mt_user_data[12] = {1};  // Set input type to adts.
-    hr = media_type->SetBlob(MF_MT_USER_DATA, mt_user_data,
-                             sizeof(mt_user_data));
-    if (FAILED(hr)) {
-      DVLOG(1) << "Error while setting AAC AudioSpecificConfig().";
-      return false;
-    }
-  }
-
-  hr = decoder_->SetInputType(0, media_type.get(), 0);  // No flags.
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting input type.";
-    return false;
-  }
-
-  return true;
-}
-
-template <>
-bool WMFDecoderImpl<DemuxerStream::VIDEO>::SetInputMediaType() {
-  base::win::ScopedComPtr<IMFMediaType> media_type;
-  HRESULT hr = MFCreateMediaType(media_type.Receive());
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while creating media type.";
-    return false;
-  }
-
-  hr = media_type->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting media major type.";
-    return false;
-  }
-
-  hr = media_type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_H264);
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting media subtype.";
-    return false;
-  }
-
-  hr = media_type->SetUINT32(MF_MT_INTERLACE_MODE,
-                             MFVideoInterlace_MixedInterlaceOrProgressive);
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting interlace mode.";
-    return false;
-  }
-
-  hr = MFSetAttributeSize(media_type.get(), MF_MT_FRAME_SIZE,
-                          config_.coded_size().width(),
-                          config_.coded_size().height());
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting frame size.";
-    return false;
-  }
-
-  hr = decoder_->SetInputType(0, media_type.get(), 0);  // No flags.
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while setting input type.";
-    return false;
-  }
-
-  return true;
-}
-
-template <DemuxerStream::Type StreamType>
-bool WMFDecoderImpl<StreamType>::SetOutputMediaType() {
-  DVLOG(1) << __FUNCTION__;
-
-  base::win::ScopedComPtr<IMFMediaType> out_media_type;
-
-  HRESULT hr = S_OK;
-  for (uint32_t i = 0; SUCCEEDED(
-           decoder_->GetOutputAvailableType(0, i, out_media_type.Receive()));
-       ++i) {
-    GUID out_subtype = {0};
-    hr = out_media_type->GetGUID(MF_MT_SUBTYPE, &out_subtype);
-    if (FAILED(hr)) {
-      DVLOG(1) << "Error while getting available output types.";
-      return false;
-    }
-
-    hr = SetOutputMediaTypeInternal(out_subtype, out_media_type.get());
-    if (hr == S_OK) {
-      break;
-    } else if (hr != S_FALSE) {
-      return false;
-    }
-
-    out_media_type.Release();
-  }
-
-  MFT_OUTPUT_STREAM_INFO output_stream_info = {0};
-  hr = decoder_->GetOutputStreamInfo(0, &output_stream_info);
-  if (FAILED(hr)) {
-    DVLOG(1) << "Error while getting stream info.";
-    return false;
-  }
-
-  output_sample_ = nullptr;
-  const bool decoder_creates_samples =
-      (output_stream_info.dwFlags & (MFT_OUTPUT_STREAM_PROVIDES_SAMPLES |
-                                     MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES)) !=
-      0;
-  if (!decoder_creates_samples) {
-    output_sample_ =
-        CreateSample(CalculateOutputBufferSize(output_stream_info),
-                     CalculateBufferAlignment(output_stream_info.cbAlignment));
-    if (!output_sample_) {
-      DVLOG(1) << "Couldn't create sample";
-      return false;
-    }
-  }
-
-  return true;
-}
-
-template <>
-HRESULT WMFDecoderImpl<DemuxerStream::AUDIO>::SetOutputMediaTypeInternal(
-    GUID subtype,
-    IMFMediaType* media_type) {
-  if (subtype == MFAudioFormat_PCM) {
-    HRESULT hr = decoder_->SetOutputType(0, media_type, 0);  // No flags.
-    if (FAILED(hr)) {
-      DVLOG(1) << "Error while setting output type.";
-      return hr;
-    }
-
-    hr = media_type->GetUINT32(MF_MT_AUDIO_BITS_PER_SAMPLE,
-                               &output_sample_size_);
-    if (FAILED(hr)) {
-      DVLOG(1) << "Error while getting sample size.";
-      return hr;
-    }
-    // We will need size in Bytes.
-    output_sample_size_ /= 8;
-    return S_OK;
-  }
-  return S_FALSE;
-}
-
-template <>
-HRESULT WMFDecoderImpl<DemuxerStream::VIDEO>::SetOutputMediaTypeInternal(
-    GUID subtype,
-    IMFMediaType* media_type) {
-  if (subtype == MFVideoFormat_YV12) {
-    HRESULT hr = decoder_->SetOutputType(0, media_type, 0);  // No flags.
-    if (FAILED(hr)) {
-      DVLOG(1) << "Error while setting output type.";
-      return hr;
-    }
-    return S_OK;
-  }
-  return S_FALSE;
-}
-
-template <>
-size_t WMFDecoderImpl<DemuxerStream::AUDIO>::CalculateOutputBufferSize(
-    const MFT_OUTPUT_STREAM_INFO& stream_info) const {
-  size_t buffer_size = stream_info.cbSize;
-
-  // Limit the buffer size for decoded MP3 audio so that |decoder_| doesn't
-  // output more than the MP3 frame size at a time.  This makes us behave more
-  // like FFmpeg and allows us to handle timestamp calculations and buffer
-  // discards using AudioDiscardHelper.
-  if (config_.codec() == kCodecMP3) {
-    // http://teslabs.com/openplayer/docs/docs/specs/mp3_structure2.pdf
-    static const size_t kMaxOutputSampleCount = 1152;
-    buffer_size = std::min(
-        buffer_size, kMaxOutputSampleCount *
-                         ChannelLayoutToChannelCount(config_.channel_layout()) *
-                         output_sample_size_);
-  }
-
-  return buffer_size;
-}
-
-template <>
-size_t WMFDecoderImpl<DemuxerStream::VIDEO>::CalculateOutputBufferSize(
-    const MFT_OUTPUT_STREAM_INFO& stream_info) const {
-  return stream_info.cbSize;
-}
-
-template <>
-bool WMFDecoderImpl<DemuxerStream::AUDIO>::InitializeDecoderFunctions() {
-  return true;
-}
-
-template <>
-bool WMFDecoderImpl<DemuxerStream::VIDEO>::InitializeDecoderFunctions() {
-  get_stride_function_ = reinterpret_cast<decltype(get_stride_function_)>(
-      GetFunctionFromLibrary("MFGetStrideForBitmapInfoHeader", "evr.dll"));
-  return get_stride_function_ != nullptr;
-}
-
-template <DemuxerStream::Type StreamType>
-HRESULT WMFDecoderImpl<StreamType>::ProcessInput(
-    const scoped_refptr<DecoderBuffer>& input) {
-  DVLOG(5) << __FUNCTION__;
-  DCHECK(input.get());
-
-  const base::win::ScopedComPtr<IMFSample> sample =
-      PrepareInputSample(input.get());
-  if (!sample) {
-    DVLOG(1) << "Failed to create input sample.";
-    return MF_E_UNEXPECTED;
-  }
-
-  const HRESULT hr = decoder_->ProcessInput(0, sample.get(), 0);
-
-  if (SUCCEEDED(hr))
-    RecordInput(input);
-
-  return hr;
-}
-
-template <>
-void WMFDecoderImpl<DemuxerStream::AUDIO>::RecordInput(
-    const scoped_refptr<DecoderBuffer>& input) {
-  // We use AudioDiscardHelper to calculate output audio timestamps and discard
-  // output buffers per the instructions in DecoderBuffer.  AudioDiscardHelper
-  // needs both the output buffers and the corresponsing input buffers to do
-  // its work, so we need to queue the input buffers to cover the case when
-  // Decode() doesn't produce output immediately.
-  queued_input_.push_back(input);
-}
-
-template <>
-void WMFDecoderImpl<DemuxerStream::VIDEO>::RecordInput(
-    const scoped_refptr<DecoderBuffer>& input) {
-  // Do nothing.  We obtain timestamps from IMFTransform::GetSampleTime() for
-  // video.
-}
-
-template <DemuxerStream::Type StreamType>
-HRESULT WMFDecoderImpl<StreamType>::ProcessOutput() {
-  DVLOG(5) << __FUNCTION__;
-
-  // Make the whole buffer available for use by |decoder_| again after it was
-  // filled with data by the previous call to ProcessOutput().
-  IMFMediaBuffer* buffer = nullptr;
-  HRESULT hr = output_sample_->ConvertToContiguousBuffer(&buffer);
-  if (FAILED(hr))
-    return hr;
-  hr = buffer->SetCurrentLength(0);
-  if (FAILED(hr))
-    return hr;
-
-  MFT_OUTPUT_DATA_BUFFER output_data_buffer = {0};
-  output_data_buffer.pSample = output_sample_.get();
-
-  DWORD process_output_status = 0;
-  hr = decoder_->ProcessOutput(0, 1, &output_data_buffer,
-                               &process_output_status);
-  IMFCollection* events = output_data_buffer.pEvents;
-  if (events != nullptr) {
-    // Even though we're not interested in events we have to clean them up.
-    events->Release();
-  }
-
-  switch (hr) {
-    case S_OK: {
-      scoped_refptr<OutputType> output_buffer =
-          CreateOutputBuffer(output_data_buffer);
-      if (!output_buffer)
-        return MF_E_UNEXPECTED;
-
-      if (!ProcessBuffer(output_buffer))
-        break;
-
-      if (!output_cb_.is_null()) {
-        task_runner_->PostTask(FROM_HERE,
-                               base::Bind(output_cb_, output_buffer));
-      } else {
-        return E_ABORT;
-      }
-
-      break;
-    }
-    case MF_E_TRANSFORM_NEED_MORE_INPUT:
-      DVLOG(5) << "NEED_MORE_INPUT";
-      // Need to wait for more input data to produce output.
-      break;
-    case MF_E_TRANSFORM_STREAM_CHANGE:
-      DVLOG(5) << "STREAM_CHANGE";
-      // For some reason we need to set up output media type again.
-      if (!SetOutputMediaType())
-        return MF_E_UNEXPECTED;
-      // This kind of change will probably prevent us from getting more output.
-      break;
-  }
-
-  return hr;
-}
-
-template <>
-bool WMFDecoderImpl<DemuxerStream::AUDIO>::ProcessBuffer(
-    const scoped_refptr<AudioBuffer>& output) {
-  if (queued_input_.empty())
-    return false;
-
-  const scoped_refptr<DecoderBuffer> dequeued_input = queued_input_.front();
-  queued_input_.pop_front();
-
-  return discard_helper_->ProcessBuffers(dequeued_input, output);
-}
-
-template <>
-bool WMFDecoderImpl<DemuxerStream::VIDEO>::ProcessBuffer(
-    const scoped_refptr<VideoFrame>& /* output */) {
-  // Nothing to do.
-  return true;
-}
-
-template <DemuxerStream::Type StreamType>
-bool WMFDecoderImpl<StreamType>::ProcessOutputLoop() {
-  for (;;) {
-    const HRESULT hr = ProcessOutput();
-    if (FAILED(hr)) {
-      // If ProcessOutput fails with MF_E_TRANSFORM_NEED_MORE_INPUT or
-      // MF_E_TRANSFORM_STREAM_CHANGE, it means it failed to get any output, but
-      // still this is not a decoding error - the decoder just needs more input
-      // data or reconfiguration on stream format change, so those errors do not
-      // mean that ProcessOutputLoop failed.
-      if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT)
-        return true;
-
-      if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
-        continue;
-
-      return false;
-    }
-  }
-}
-
-template <DemuxerStream::Type StreamType>
-bool WMFDecoderImpl<StreamType>::Drain() {
-  decoder_->ProcessMessage(MFT_MESSAGE_COMMAND_DRAIN, 0);
-  return ProcessOutputLoop();
-}
-
-template <DemuxerStream::Type StreamType>
-base::win::ScopedComPtr<IMFSample>
-WMFDecoderImpl<StreamType>::PrepareInputSample(
-    const scoped_refptr<DecoderBuffer>& input) const {
-  base::win::ScopedComPtr<IMFSample> sample =
-      CreateSample(input->data_size(),
-                   CalculateBufferAlignment(input_stream_info_.cbAlignment));
-  if (!sample)
-    return base::win::ScopedComPtr<IMFSample>();
-
-  IMFMediaBuffer* buffer = nullptr;
-  HRESULT hr = sample->GetBufferByIndex(0, &buffer);
-  if (FAILED(hr))
-    return base::win::ScopedComPtr<IMFSample>();
-
-  uint8_t* buff_ptr = nullptr;
-  hr = buffer->Lock(&buff_ptr, nullptr, nullptr);
-  if (FAILED(hr))
-    return base::win::ScopedComPtr<IMFSample>();
-
-  memcpy(buff_ptr, input->data(), input->data_size());
-
-  hr = buffer->Unlock();
-  if (FAILED(hr))
-    return base::win::ScopedComPtr<IMFSample>();
-
-  hr = buffer->SetCurrentLength(input->data_size());
-  if (FAILED(hr))
-    return base::win::ScopedComPtr<IMFSample>();
-
-  // IMFSample's timestamp is expressed in hundreds of nanoseconds.
-  hr = sample->SetSampleTime(input->timestamp().InMicroseconds() * 10);
-  if (FAILED(hr))
-    return base::win::ScopedComPtr<IMFSample>();
-
-  return sample;
-}
-
-template <DemuxerStream::Type StreamType>
-scoped_refptr<typename WMFDecoderImpl<StreamType>::OutputType>
-WMFDecoderImpl<StreamType>::CreateOutputBuffer(
-    const MFT_OUTPUT_DATA_BUFFER& output_data_buffer) {
-  base::win::ScopedComPtr<IMFMediaBuffer> media_buffer;
-  HRESULT hr = output_data_buffer.pSample->ConvertToContiguousBuffer(
-      media_buffer.Receive());
-  if (FAILED(hr)) {
-    return nullptr;
-  }
-
-  uint8_t* data = nullptr;
-  DWORD data_size = 0;
-  hr = media_buffer->Lock(&data, nullptr, &data_size);
-  if (FAILED(hr)) {
-    return nullptr;
-  }
-
-  LONGLONG sample_time = 0;
-  hr = output_data_buffer.pSample->GetSampleTime(&sample_time);
-  if (FAILED(hr))
-    return nullptr;
-  // The sample time in IMFSample is expressed in hundreds of nanoseconds.
-  const base::TimeDelta timestamp =
-      base::TimeDelta::FromMicroseconds(sample_time / 10);
-
-  scoped_refptr<typename WMFDecoderImpl<StreamType>::OutputType> output =
-      CreateOutputBufferInternal(data, data_size, timestamp);
-
-  media_buffer->Unlock();
-  return output;
-}
-
-template <>
-scoped_refptr<AudioBuffer>
-WMFDecoderImpl<DemuxerStream::AUDIO>::CreateOutputBufferInternal(
-    const uint8_t* data,
-    DWORD data_size,
-    base::TimeDelta /* timestamp */) {
-  DCHECK_GT(output_sample_size_, 0u) << "Division by zero";
-
-  const int frame_count = data_size / output_sample_size_ /
-                          ChannelLayoutToChannelCount(config_.channel_layout());
-
-  // The timestamp will be calculated by |discard_helper_| later on.
-  return AudioBuffer::CopyFrom(
-      ConvertToSampleFormat(output_sample_size_), config_.channel_layout(),
-      ChannelLayoutToChannelCount(config_.channel_layout()),
-      config_.samples_per_second(), frame_count, &data, kNoTimestamp());
-}
-
-template <>
-scoped_refptr<VideoFrame>
-WMFDecoderImpl<DemuxerStream::VIDEO>::CreateOutputBufferInternal(
-    const uint8_t* data,
-    DWORD data_size,
-    base::TimeDelta timestamp) {
-  const scoped_refptr<DataBuffer> data_buffer =
-      DataBuffer::CopyFrom(data, data_size);
-
-  LONG stride = 0;
-  HRESULT hr = get_stride_function_(MFVideoFormat_YV12.Data1,
-                                    config_.coded_size().width(), &stride);
-  stride = ((stride + 15) & ~15);  // Stride has to be divisible by 16.
-  if (FAILED(hr)) {
-    DVLOG(1) << "Failed to obtain stride.";
-    return nullptr;
-  }
-
-  // Number of rows has to be divisible by 16.
-  LONG rows = ((config_.coded_size().height() + 15) & ~15);
-
-  scoped_refptr<VideoFrame> frame = VideoFrame::WrapExternalYuvData(
-      PIXEL_FORMAT_YV12, config_.coded_size(), config_.visible_rect(),
-      config_.natural_size(), stride, stride / 2, stride / 2,
-      const_cast<uint8_t*>(data_buffer->data()),
-      const_cast<uint8_t*>(data_buffer->data() +
-                           (rows * stride + rows * stride / 4)),
-      const_cast<uint8_t*>(data_buffer->data() + (rows * stride)), timestamp);
-  frame->AddDestructionObserver(base::Bind(&BufferHolder, data_buffer));
-  return frame;
-}
-
-template <DemuxerStream::Type StreamType>
-base::win::ScopedComPtr<IMFSample> WMFDecoderImpl<StreamType>::CreateSample(
-    DWORD buffer_size,
-    int buffer_alignment) const {
-  base::win::ScopedComPtr<IMFSample> sample;
-  HRESULT hr = MFCreateSample(sample.Receive());
-  if (FAILED(hr))
-    return base::win::ScopedComPtr<IMFSample>();
-
-  base::win::ScopedComPtr<IMFMediaBuffer> buffer;
-  hr = MFCreateAlignedMemoryBuffer(buffer_size, buffer_alignment,
-                                   buffer.Receive());
-  if (FAILED(hr))
-    return base::win::ScopedComPtr<IMFSample>();
-
-  hr = sample->AddBuffer(buffer.get());
-  if (FAILED(hr))
-    return base::win::ScopedComPtr<IMFSample>();
-
-  return sample;
-}
-
-template <>
-void WMFDecoderImpl<DemuxerStream::AUDIO>::ResetTimestampState() {
-  discard_helper_.reset(new AudioDiscardHelper(config_.samples_per_second(),
-                                               config_.codec_delay()));
-  discard_helper_->Reset(config_.codec_delay());
-
-  queued_input_.clear();
-}
-
-template <>
-void WMFDecoderImpl<DemuxerStream::VIDEO>::ResetTimestampState() {
-  // Nothing to do.
-}
-
-template class WMFDecoderImpl<DemuxerStream::AUDIO>;
-template class WMFDecoderImpl<DemuxerStream::VIDEO>;
-
-}  // namespace media
diff --git a/media/filters/wmf_decoder_impl.h b/media/filters/wmf_decoder_impl.h
deleted file mode 100644
index 26a9e5d4..0000000
--- a/media/filters/wmf_decoder_impl.h
+++ /dev/null
@@ -1,127 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_WMF_DECODER_IMPL_H_
-#define MEDIA_FILTERS_WMF_DECODER_IMPL_H_
-
-#include <mfapi.h>
-#include <mftransform.h>
-
-#include <deque>
-#include <string>
-
-#include "base/single_thread_task_runner.h"
-#include "base/strings/string_piece.h"
-#include "base/win/scoped_comptr.h"
-#include "media/base/audio_decoder.h"
-#include "media/base/audio_decoder_config.h"
-#include "media/base/audio_discard_helper.h"
-#include "media/base/sample_format.h"
-#include "media/base/video_decoder.h"
-#include "media/base/video_decoder_config.h"
-#include "media/filters/decoder_stream_traits.h"
-
-namespace media {
-
-template <DemuxerStream::Type StreamType>
-struct WMFDecoderImplTraits : public DecoderStreamTraits<StreamType> {};
-
-template <>
-struct WMFDecoderImplTraits<DemuxerStream::AUDIO>
-    : public DecoderStreamTraits<DemuxerStream::AUDIO> {
-  using DecoderConfigType = AudioDecoderConfig;
-};
-
-template <>
-struct WMFDecoderImplTraits<DemuxerStream::VIDEO>
-    : public DecoderStreamTraits<DemuxerStream::VIDEO> {
-  using DecoderConfigType = VideoDecoderConfig;
-};
-
-// Decodes AAC audio or H.264 video streams using Windows Media Foundation
-// library.
-template <DemuxerStream::Type StreamType>
-class WMFDecoderImpl {
- public:
-  using DecoderTraits = WMFDecoderImplTraits<StreamType>;
-  using DecoderConfig = typename DecoderTraits::DecoderConfigType;
-  using DecoderType = typename DecoderTraits::DecoderType;
-  using DecodeCB = typename DecoderType::DecodeCB;
-  using InitCB = typename DecoderType::InitCB;
-  using OutputCB = typename DecoderTraits::OutputCB;
-  using OutputType = typename DecoderTraits::OutputType;
-
-  explicit WMFDecoderImpl(
-      const scoped_refptr<base::SingleThreadTaskRunner>& task_runner);
-
-  void Initialize(const DecoderConfig& config,
-                  const InitCB& init_cb,
-                  const OutputCB& output_cb);
-  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
-              const DecodeCB& decode_cb);
-  void Reset(const base::Closure& closure);
-
- private:
-  // Performs decoder config checks specific to the WMFDecoder, beyond the
-  // generic DecoderConfig::IsValidConfig() check.
-  static bool IsValidConfig(const DecoderConfig& config);
-  static std::string GetModuleName(const DecoderConfig& config);
-  static GUID GetMediaObjectGUID(const DecoderConfig& config);
-  static base::win::ScopedComPtr<IMFTransform> CreateWMFDecoder(
-      const DecoderConfig& config);
-
-  // Methods used for initialization and configuration.
-  bool ConfigureDecoder();
-  bool SetInputMediaType();
-  bool SetOutputMediaType();
-  HRESULT SetOutputMediaTypeInternal(GUID subtype, IMFMediaType* media_type);
-  size_t CalculateOutputBufferSize(
-      const MFT_OUTPUT_STREAM_INFO& stream_info) const;
-  bool InitializeDecoderFunctions();
-
-  // Methods used during decoding.
-  HRESULT ProcessInput(const scoped_refptr<DecoderBuffer>& input);
-  void RecordInput(const scoped_refptr<DecoderBuffer>& input);
-  HRESULT ProcessOutput();
-  bool ProcessBuffer(const scoped_refptr<OutputType>& output);
-  bool ProcessOutputLoop();
-  bool Drain();
-  base::win::ScopedComPtr<IMFSample> PrepareInputSample(
-      const scoped_refptr<DecoderBuffer>& input) const;
-  scoped_refptr<OutputType> CreateOutputBuffer(
-      const MFT_OUTPUT_DATA_BUFFER& output_data_buffer);
-  scoped_refptr<OutputType> CreateOutputBufferInternal(
-      const uint8_t* data,
-      DWORD data_size,
-      base::TimeDelta timestamp);
-  base::win::ScopedComPtr<IMFSample> CreateSample(DWORD buffer_size,
-                                                  int buffer_alignment) const;
-  void ResetTimestampState();
-
-  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-  base::win::ScopedComPtr<IMFTransform> decoder_;
-  DecoderConfig config_;
-  OutputCB output_cb_;
-  MFT_INPUT_STREAM_INFO input_stream_info_;
-  base::win::ScopedComPtr<IMFSample> output_sample_;
-  uint32_t output_sample_size_;  // in Bytes
-
-  std::deque<scoped_refptr<DecoderBuffer>> queued_input_;
-  scoped_ptr<AudioDiscardHelper> discard_helper_;
-
-  // We always call MFGetStrideForBitmapInfoHeader() through this pointer.
-  // This guarantees the call succeeds both on Vista and newer systems.  On
-  // Vista, the function is provided by evr.dll, but we build Opera on newer
-  // Windows, where the function is provided by mfplat.dll.  We set up this
-  // pointer to the function in evr.dll explicitly.  Luckily, on newer Windows
-  // evr.dll still provides a stub that calls the function in mfplat.dll, so
-  // this approach always works.
-  decltype(MFGetStrideForBitmapInfoHeader)* get_stride_function_;
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_WMF_DECODER_IMPL_H_
diff --git a/media/filters/wmf_video_decoder.cc b/media/filters/wmf_video_decoder.cc
deleted file mode 100644
index 38622120..0000000
--- a/media/filters/wmf_video_decoder.cc
+++ /dev/null
@@ -1,44 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#include "media/filters/wmf_video_decoder.h"
-
-#include "media/base/pipeline_stats.h"
-
-namespace media {
-
-WMFVideoDecoder::WMFVideoDecoder(
-    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner)
-    : impl_(task_runner) {
-}
-
-WMFVideoDecoder::~WMFVideoDecoder() {
-}
-
-std::string WMFVideoDecoder::GetDisplayName() const {
-  return "WMFVideoDecoder";
-}
-
-void WMFVideoDecoder::Initialize(const VideoDecoderConfig& config,
-                                 bool low_delay,
-                                 CdmContext* cdm_context,
-                                 const InitCB& init_cb,
-                                 const OutputCB& output_cb) {
-  pipeline_stats::AddDecoderClass(GetDisplayName());
-
-  impl_.Initialize(config, init_cb, output_cb);
-}
-
-void WMFVideoDecoder::Decode(const scoped_refptr<DecoderBuffer>& buffer,
-                             const DecodeCB& decode_cb) {
-  impl_.Decode(buffer, decode_cb);
-}
-
-void WMFVideoDecoder::Reset(const base::Closure& closure) {
-  impl_.Reset(closure);
-}
-
-}  // namespace media
diff --git a/media/filters/wmf_video_decoder.h b/media/filters/wmf_video_decoder.h
deleted file mode 100644
index 22d03b8..0000000
--- a/media/filters/wmf_video_decoder.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-//
-// Copyright (C) 2015 Opera Software ASA.  All rights reserved.
-//
-// This file is an original work developed by Opera Software ASA
-
-#ifndef MEDIA_FILTERS_WMF_VIDEO_DECODER_H_
-#define MEDIA_FILTERS_WMF_VIDEO_DECODER_H_
-
-#include <string>
-
-#include "media/base/video_decoder.h"
-#include "media/filters/wmf_decoder_impl.h"
-
-namespace media {
-
-// Decodes H.264 video streams using Windows Media Foundation library.
-class MEDIA_EXPORT WMFVideoDecoder : public VideoDecoder {
- public:
-  WMFVideoDecoder(
-      const scoped_refptr<base::SingleThreadTaskRunner>& task_runner);
-  ~WMFVideoDecoder() override;
-
-  // VideoDecoder implementation.
-  std::string GetDisplayName() const override;
-  void Initialize(const VideoDecoderConfig& config,
-                  bool low_delay,
-                  CdmContext* cdm_context,
-                  const InitCB& init_cb,
-                  const OutputCB& output_cb) override;
-  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
-              const DecodeCB& decode_cb) override;
-  void Reset(const base::Closure& closure) override;
-
- private:
-  WMFDecoderImpl<DemuxerStream::VIDEO> impl_;
-
-  DISALLOW_COPY_AND_ASSIGN(WMFVideoDecoder);
-};
-
-}  // namespace media
-
-#endif  // MEDIA_FILTERS_WMF_VIDEO_DECODER_H_
diff --git a/media/formats/mp4/aac.cc b/media/formats/mp4/aac.cc
index b89eadc..93dbe67 100644
--- a/media/formats/mp4/aac.cc
+++ b/media/formats/mp4/aac.cc
@@ -29,7 +29,7 @@ AAC::~AAC() {
 
 bool AAC::Parse(const std::vector<uint8_t>& data,
                 const scoped_refptr<MediaLog>& media_log) {
-#if defined(OS_ANDROID) || defined(USE_SYSTEM_PROPRIETARY_CODECS)
+#if defined(OS_ANDROID)
   codec_specific_data_ = data;
 #endif
   if (data.empty())
@@ -158,12 +158,6 @@ bool AAC::Parse(const std::vector<uint8_t>& data,
   return true;
 }
 
-int AAC::GetSamplesPerSecond() const {
-  if (extension_frequency_ > 0)
-    return extension_frequency_;
-  return frequency_;
-}
-
 int AAC::GetOutputSamplesPerSecond(bool sbr_in_mimetype) const {
   if (extension_frequency_ > 0)
     return extension_frequency_;
diff --git a/media/formats/mp4/aac.h b/media/formats/mp4/aac.h
index 5a97098..ac694cd 100644
--- a/media/formats/mp4/aac.h
+++ b/media/formats/mp4/aac.h
@@ -37,13 +37,6 @@ class MEDIA_EXPORT AAC {
   bool Parse(const std::vector<uint8_t>& data,
              const scoped_refptr<MediaLog>& media_log);
 
-  // Gets the actual sample rate of the AAC stream.  Returns the
-  // input_samples_per_second value that should be used in an
-  // AudioDecoderConfig.
-  // TODO(wdzierzanowski): This should become unnecessary when DNA-35764 is
-  // fixed.
-  int GetSamplesPerSecond() const;
-
   // Gets the output sample rate for the AAC stream.
   // |sbr_in_mimetype| should be set to true if the SBR mode is
   // signalled in the mimetype. (ie mp4a.40.5 in the codecs parameter).
@@ -64,7 +57,7 @@ class MEDIA_EXPORT AAC {
   // unchanged.
   bool ConvertEsdsToADTS(std::vector<uint8_t>* buffer) const;
 
-#if defined(OS_ANDROID) || defined(USE_SYSTEM_PROPRIETARY_CODECS)
+#if defined(OS_ANDROID)
   // Returns the codec specific data needed by android MediaCodec.
   std::vector<uint8_t> codec_specific_data() const {
     return codec_specific_data_;
@@ -82,7 +75,7 @@ class MEDIA_EXPORT AAC {
   uint8_t frequency_index_;
   uint8_t channel_config_;
 
-#if defined(OS_ANDROID) || defined(USE_SYSTEM_PROPRIETARY_CODECS)
+#if defined(OS_ANDROID)
   // The codec specific data needed by the android MediaCodec.
   std::vector<uint8_t> codec_specific_data_;
 #endif
diff --git a/media/formats/mp4/box_definitions.cc b/media/formats/mp4/box_definitions.cc
index d3ea14c0..b7f1815 100644
--- a/media/formats/mp4/box_definitions.cc
+++ b/media/formats/mp4/box_definitions.cc
@@ -687,6 +687,7 @@ FourCC ElementaryStreamDescriptor::BoxType() const {
 }
 
 bool ElementaryStreamDescriptor::Parse(BoxReader* reader) {
+  std::vector<uint8_t> data;
   ESDescriptor es_desc;
 
   RCHECK(reader->ReadFullBoxHeader());
diff --git a/media/formats/mp4/box_definitions.h b/media/formats/mp4/box_definitions.h
index ffbb33b..0113880 100644
--- a/media/formats/mp4/box_definitions.h
+++ b/media/formats/mp4/box_definitions.h
@@ -255,7 +255,6 @@ struct MEDIA_EXPORT ElementaryStreamDescriptor : Box {
 
   uint8_t object_type;
   AAC aac;
-  std::vector<uint8_t> data;
 };
 
 struct MEDIA_EXPORT AudioSampleEntry : Box {
diff --git a/media/formats/mp4/mp4_stream_parser.cc b/media/formats/mp4/mp4_stream_parser.cc
index 5f204d8..49acc87 100644
--- a/media/formats/mp4/mp4_stream_parser.cc
+++ b/media/formats/mp4/mp4_stream_parser.cc
@@ -271,7 +271,6 @@ bool MP4StreamParser::ParseMoov(BoxReader* reader) {
       AudioCodec codec = kUnknownAudioCodec;
       ChannelLayout channel_layout = CHANNEL_LAYOUT_NONE;
       int sample_per_second = 0;
-      int input_samples_per_second = 0;
       std::vector<uint8_t> extra_data;
       // Check if it is MPEG4 AAC defined in ISO 14496 Part 3 or
       // supported MPEG2 AAC varients.
@@ -279,11 +278,8 @@ bool MP4StreamParser::ParseMoov(BoxReader* reader) {
         codec = kCodecAAC;
         channel_layout = aac.GetChannelLayout(has_sbr_);
         sample_per_second = aac.GetOutputSamplesPerSecond(has_sbr_);
-        input_samples_per_second = aac.GetSamplesPerSecond();
 #if defined(OS_ANDROID)
         extra_data = aac.codec_specific_data();
-#elif defined(USE_SYSTEM_PROPRIETARY_CODECS)
-        extra_data = entry.esds.data;
 #endif
 #if BUILDFLAG(ENABLE_AC3_EAC3_AUDIO_DEMUXING)
       } else if (audio_type == kAC3) {
@@ -320,7 +316,6 @@ bool MP4StreamParser::ParseMoov(BoxReader* reader) {
           codec, sample_format, channel_layout, sample_per_second, extra_data,
           is_audio_track_encrypted_ ? AesCtrEncryptionScheme() : Unencrypted(),
           base::TimeDelta(), 0);
-      audio_config.set_input_samples_per_second(input_samples_per_second);
       has_audio_ = true;
       audio_track_id_ = track->header.track_id;
       media_tracks->AddAudioTrack(
diff --git a/media/media.gyp b/media/media.gyp
index 23fa7fc..9752856 100644
--- a/media/media.gyp
+++ b/media/media.gyp
@@ -696,73 +696,6 @@
             'filters/vpx_video_decoder.h',
           ],
         }],
-        ['system_proprietary_codecs==1 and OS=="mac"', {
-          'sources': [
-            'filters/at_aac_helper.cc',
-            'filters/at_aac_helper.h',
-            'filters/at_audio_decoder.cc',
-            'filters/at_audio_decoder.h',
-            'filters/at_codec_helper.h',
-            'filters/at_mp3_helper.cc',
-            'filters/at_mp3_helper.h',
-            'filters/core_audio_demuxer.cc',
-            'filters/core_audio_demuxer.h',
-            'filters/core_audio_demuxer_stream.cc',
-            'filters/core_audio_demuxer_stream.h',
-          ],
-        }],
-        ['system_proprietary_codecs==1 and OS=="win"', {
-          'sources': [
-            'filters/wmf_audio_decoder.cc',
-            'filters/wmf_audio_decoder.h',
-            'filters/wmf_decoder_impl.cc',
-            'filters/wmf_decoder_impl.h',
-            'filters/wmf_video_decoder.cc',
-            'filters/wmf_video_decoder.h',
-          ],
-        }],
-        ['system_proprietary_codecs==1', {
-          'dependencies': [
-            '<(DEPTH)/net/net.gyp:net', # For GetMimeTypeFromFile
-          ],
-          'sources': [
-            'base/mac/framework_type_conversions.h',
-            'base/mac/framework_type_conversions.mm',
-            'base/mac/mediatoolbox_glue.h',
-            'base/mac/mediatoolbox_glue.mm',
-            'base/mac/scoped_audio_queue_ref.h',
-            'base/pipeline_stats.cc',
-            'base/pipeline_stats.h',
-            'base/platform_mime_util.h',
-            'base/platform_mime_util_mac.mm',
-            'base/platform_mime_util_win.cc',
-            'base/win/mf_util.cc',
-            'base/win/mf_util.h',
-            'filters/ipc_audio_decoder.cc',
-            'filters/ipc_audio_decoder.h',
-            'filters/ipc_demuxer.cc',
-            'filters/ipc_demuxer.h',
-            'filters/ipc_demuxer_stream.cc',
-            'filters/ipc_demuxer_stream.h',
-            'filters/ipc_media_pipeline_host.h',
-            'filters/pass_through_audio_decoder.cc',
-            'filters/pass_through_audio_decoder.h',
-            'filters/pass_through_decoder_impl.cc',
-            'filters/pass_through_decoder_impl.h',
-            'filters/pass_through_decoder_texture.cc',
-            'filters/pass_through_decoder_texture.h',
-            'filters/pass_through_video_decoder.cc',
-            'filters/pass_through_video_decoder.h',
-            'filters/platform_media_pipeline_constants.cc',
-            'filters/platform_media_pipeline_constants.h',
-            'filters/platform_media_pipeline_types.cc',
-            'filters/platform_media_pipeline_types.h',
-            'filters/platform_media_pipeline_types_mac.h',
-            'filters/platform_media_pipeline_types_mac.mm',
-            'filters/protocol_sniffer.cc',
-            'filters/protocol_sniffer.h',
-          ],
-        }],
         ['OS=="android"', {
           'dependencies': [
             'capture_java',
@@ -894,7 +827,6 @@
             '<!@(<(pkg-config) --cflags libpulse)',
           ],
           'defines': [
-            'BRANDING="<(branding)"',
             'USE_PULSEAUDIO',
           ],
           'conditions': [
@@ -1645,13 +1577,6 @@
         'video/mock_video_decode_accelerator.cc',
         'video/mock_video_decode_accelerator.h',
       ],
-      'conditions': [
-        ['system_proprietary_codecs==1', {
-          'sources': [
-            'test/pipeline_integration_test_base.cc',
-          ],
-        }],
-      ],
     },
     {
       # Minimal target for NaCl and other renderer side media clients which
diff --git a/media/renderers/audio_renderer_impl.h b/media/renderers/audio_renderer_impl.h
index a4450f6..0b2d400 100644
--- a/media/renderers/audio_renderer_impl.h
+++ b/media/renderers/audio_renderer_impl.h
@@ -92,12 +92,6 @@ class MEDIA_EXPORT AudioRendererImpl
   void StartPlaying() override;
   void SetVolume(float volume) override;
 
-  // Determines whether the decoded audio queue size is increased as part of
-  // underflow handling.
-  void set_increase_queue_size_on_underflow(bool increase) {
-    increase_queue_size_on_underflow_ = increase;
-  }
-
  private:
   friend class AudioRendererImplTest;
 
@@ -249,7 +243,6 @@ class MEDIA_EXPORT AudioRendererImpl
   // Algorithm for scaling audio.
   double playback_rate_;
   scoped_ptr<AudioRendererAlgorithm> algorithm_;
-  bool increase_queue_size_on_underflow_;
 
   // Simple state tracking variable.
   State state_;
diff --git a/media/renderers/default_renderer_factory.cc b/media/renderers/default_renderer_factory.cc
index 214a62e..e09f90e 100644
--- a/media/renderers/default_renderer_factory.cc
+++ b/media/renderers/default_renderer_factory.cc
@@ -29,20 +29,6 @@
 #include "media/filters/vpx_video_decoder.h"
 #endif
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/base/pipeline_stats.h"
-#include "media/filters/ipc_demuxer.h"
-#include "media/filters/pass_through_audio_decoder.h"
-#include "media/filters/pass_through_video_decoder.h"
-#if defined(OS_MACOSX)
-#include "media/filters/at_audio_decoder.h"
-#endif
-#if defined(OS_WIN)
-#include "media/filters/wmf_audio_decoder.h"
-#include "media/filters/wmf_video_decoder.h"
-#endif
-#endif
-
 namespace media {
 
 DefaultRendererFactory::DefaultRendererFactory(
@@ -59,31 +45,16 @@ DefaultRendererFactory::~DefaultRendererFactory() {
 }
 
 ScopedVector<AudioDecoder> DefaultRendererFactory::CreateAudioDecoders(
-    const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner,
-    bool use_platform_media_pipeline) {
+    const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner) {
   // Create our audio decoders and renderer.
   ScopedVector<AudioDecoder> audio_decoders;
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (use_platform_media_pipeline) {
-    audio_decoders.push_back(new PassThroughAudioDecoder(media_task_runner));
-  } else {
-#if defined(OS_MACOSX)
-    audio_decoders.push_back(new ATAudioDecoder(media_task_runner));
-#elif defined(OS_WIN)
-    audio_decoders.push_back(new WMFAudioDecoder(media_task_runner));
-#endif
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 #if !defined(MEDIA_DISABLE_FFMPEG)
   audio_decoders.push_back(
       new FFmpegAudioDecoder(media_task_runner, media_log_));
 #endif
 
   audio_decoders.push_back(new OpusAudioDecoder(media_task_runner));
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  }
-#endif
 
   // Use an external decoder only if we cannot otherwise decode in the
   // renderer.
@@ -96,8 +67,7 @@ ScopedVector<AudioDecoder> DefaultRendererFactory::CreateAudioDecoders(
 ScopedVector<VideoDecoder> DefaultRendererFactory::CreateVideoDecoders(
     const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner,
     const RequestSurfaceCB& request_surface_cb,
-    GpuVideoAcceleratorFactories* gpu_factories,
-    bool use_platform_media_pipeline) {
+    GpuVideoAcceleratorFactories* gpu_factories) {
   // Create our video decoders and renderer.
   ScopedVector<VideoDecoder> video_decoders;
 
@@ -112,29 +82,10 @@ ScopedVector<VideoDecoder> DefaultRendererFactory::CreateVideoDecoders(
   DCHECK(!gpu_factories ||
          (gpu_factories->GetTaskRunner() == media_task_runner.get()));
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (use_platform_media_pipeline) {
-    video_decoders.push_back(new PassThroughVideoDecoder(media_task_runner));
-  } else {
-#endif
-
-  // TODO(pgraszka): When chrome fixes the dropping frames issue in the
-  // GpuVideoDecoder, we should make it our first choice on the list of video
-  // decoders, for more details see: DNA-36050,
-  // https://code.google.com/p/chromium/issues/detail?id=470466.
   if (gpu_factories)
     video_decoders.push_back(
         new GpuVideoDecoder(gpu_factories, request_surface_cb));
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#if defined(OS_WIN)
-    video_decoders.push_back(new WMFVideoDecoder(media_task_runner));
-#elif defined(OS_MACOSX)
-    if (!gpu_factories)
-      pipeline_stats::ReportNoGpuProcessForDecoder();
-#endif
-#endif
-
 #if !defined(MEDIA_DISABLE_LIBVPX)
   video_decoders.push_back(new VpxVideoDecoder());
 #endif
@@ -143,9 +94,6 @@ ScopedVector<VideoDecoder> DefaultRendererFactory::CreateVideoDecoders(
   video_decoders.push_back(new FFmpegVideoDecoder());
 #endif
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  }
-#endif
   return video_decoders;
 }
 
@@ -154,15 +102,12 @@ scoped_ptr<Renderer> DefaultRendererFactory::CreateRenderer(
     const scoped_refptr<base::TaskRunner>& worker_task_runner,
     AudioRendererSink* audio_renderer_sink,
     VideoRendererSink* video_renderer_sink,
-    const RequestSurfaceCB& request_surface_cb,
-    bool use_platform_media_pipeline,
-    bool platform_pipeline_enlarges_buffers_on_underflow) {
+    const RequestSurfaceCB& request_surface_cb) {
   DCHECK(audio_renderer_sink);
 
   scoped_ptr<AudioRenderer> audio_renderer(
       new AudioRendererImpl(media_task_runner, audio_renderer_sink,
-                            CreateAudioDecoders(media_task_runner,
-                                use_platform_media_pipeline),
+                            CreateAudioDecoders(media_task_runner),
                             audio_hardware_config_, media_log_));
 
   GpuVideoAcceleratorFactories* gpu_factories = nullptr;
@@ -171,8 +116,7 @@ scoped_ptr<Renderer> DefaultRendererFactory::CreateRenderer(
 
   scoped_ptr<VideoRenderer> video_renderer(new VideoRendererImpl(
       media_task_runner, worker_task_runner, video_renderer_sink,
-      CreateVideoDecoders(media_task_runner, request_surface_cb, gpu_factories,
-                          use_platform_media_pipeline),
+      CreateVideoDecoders(media_task_runner, request_surface_cb, gpu_factories),
       true, gpu_factories, media_log_));
 
   return scoped_ptr<Renderer>(new RendererImpl(
diff --git a/media/renderers/default_renderer_factory.h b/media/renderers/default_renderer_factory.h
index 6ce0384..e701014 100644
--- a/media/renderers/default_renderer_factory.h
+++ b/media/renderers/default_renderer_factory.h
@@ -38,19 +38,15 @@ class MEDIA_EXPORT DefaultRendererFactory : public RendererFactory {
       const scoped_refptr<base::TaskRunner>& worker_task_runner,
       AudioRendererSink* audio_renderer_sink,
       VideoRendererSink* video_renderer_sink,
-      const RequestSurfaceCB& request_surface_cb,
-      bool use_platform_media_pipeline,
-      bool platform_pipeline_enlarges_buffers_on_underflow) final;
+      const RequestSurfaceCB& request_surface_cb) final;
 
  private:
   ScopedVector<AudioDecoder> CreateAudioDecoders(
-      const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner,
-      bool use_platform_media_pipeline);
+      const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner);
   ScopedVector<VideoDecoder> CreateVideoDecoders(
       const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner,
       const RequestSurfaceCB& request_surface_cb,
-      GpuVideoAcceleratorFactories* gpu_factories,
-      bool use_platform_media_pipeline);
+      GpuVideoAcceleratorFactories* gpu_factories);
 
   scoped_refptr<MediaLog> media_log_;
 
diff --git a/media/renderers/gpu_video_accelerator_factories.h b/media/renderers/gpu_video_accelerator_factories.h
index 4d41606..be6f0bc 100644
--- a/media/renderers/gpu_video_accelerator_factories.h
+++ b/media/renderers/gpu_video_accelerator_factories.h
@@ -109,12 +109,6 @@ class MEDIA_EXPORT GpuVideoAcceleratorFactories {
   virtual VideoEncodeAccelerator::SupportedProfiles
       GetVideoEncodeAcceleratorSupportedProfiles() = 0;
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  // Returns route ID used internally by the factory to communicate with
-  // GPU process.
-  virtual int GetRouteID() = 0;
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
  protected:
   friend class base::RefCounted<GpuVideoAcceleratorFactories>;
   virtual ~GpuVideoAcceleratorFactories() {}
diff --git a/media/renderers/mock_gpu_video_accelerator_factories.cc b/media/renderers/mock_gpu_video_accelerator_factories.cc
index 856d61c..4a0eaaa 100644
--- a/media/renderers/mock_gpu_video_accelerator_factories.cc
+++ b/media/renderers/mock_gpu_video_accelerator_factories.cc
@@ -110,9 +110,7 @@ void MockGpuVideoAcceleratorFactories::
 
 scoped_ptr<base::SharedMemory>
 MockGpuVideoAcceleratorFactories::CreateSharedMemory(size_t size) {
-  scoped_ptr<base::SharedMemory> shared_buffer(new base::SharedMemory);
-  return shared_buffer->CreateAndMapAnonymous(size) ? std::move(shared_buffer)
-                                                    : nullptr;
+  return nullptr;
 }
 
 scoped_ptr<VideoDecodeAccelerator>
diff --git a/media/renderers/mock_gpu_video_accelerator_factories.h b/media/renderers/mock_gpu_video_accelerator_factories.h
index ea27814..6fe9646 100644
--- a/media/renderers/mock_gpu_video_accelerator_factories.h
+++ b/media/renderers/mock_gpu_video_accelerator_factories.h
@@ -73,10 +73,6 @@ class MockGpuVideoAcceleratorFactories : public GpuVideoAcceleratorFactories {
 
   void SetGpuMemoryBuffersInUseByMacOSWindowServer(bool in_use);
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  MOCK_METHOD0(GetRouteID, int());
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
   scoped_ptr<base::SharedMemory> CreateSharedMemory(size_t size) override;
 
   scoped_ptr<VideoDecodeAccelerator> CreateVideoDecodeAccelerator() override;
diff --git a/media/renderers/renderer_impl.cc b/media/renderers/renderer_impl.cc
index a1bdfd6..38f49d4 100644
--- a/media/renderers/renderer_impl.cc
+++ b/media/renderers/renderer_impl.cc
@@ -24,10 +24,6 @@
 #include "media/base/video_renderer.h"
 #include "media/base/wall_clock_time_source.h"
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include "media/base/pipeline_stats.h"
-#endif
-
 namespace media {
 
 // See |video_underflow_threshold_|.
@@ -317,8 +313,7 @@ void RendererImpl::InitializeAudioRenderer() {
       base::Bind(&RendererImpl::OnBufferingStateChanged, weak_this_,
                  &audio_buffering_state_),
       base::Bind(&RendererImpl::OnAudioRendererEnded, weak_this_),
-      base::Bind(&RendererImpl::OnError, weak_this_,
-                 demuxer_stream_provider_->GetStream(DemuxerStream::AUDIO)),
+      base::Bind(&RendererImpl::OnError, weak_this_),
       waiting_for_decryption_key_cb_);
 }
 
@@ -335,11 +330,6 @@ void RendererImpl::OnAudioRendererInitializeDone(PipelineStatus status) {
   }
 
   if (status != PIPELINE_OK) {
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    pipeline_stats::ReportStreamError(
-        demuxer_stream_provider_->GetStream(DemuxerStream::AUDIO));
-#endif
-
     FinishInitialization(status);
     return;
   }
@@ -369,8 +359,7 @@ void RendererImpl::InitializeVideoRenderer() {
       base::Bind(&RendererImpl::OnBufferingStateChanged, weak_this_,
                  &video_buffering_state_),
       base::Bind(&RendererImpl::OnVideoRendererEnded, weak_this_),
-      base::Bind(&RendererImpl::OnError, weak_this_,
-                 demuxer_stream_provider_->GetStream(DemuxerStream::VIDEO)),
+      base::Bind(&RendererImpl::OnError, weak_this_),
       base::Bind(&RendererImpl::GetWallClockTimes, base::Unretained(this)),
       waiting_for_decryption_key_cb_);
 }
@@ -391,11 +380,6 @@ void RendererImpl::OnVideoRendererInitializeDone(PipelineStatus status) {
   DCHECK(!init_cb_.is_null());
 
   if (status != PIPELINE_OK) {
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    pipeline_stats::ReportStreamError(
-        demuxer_stream_provider_->GetStream(DemuxerStream::VIDEO));
-#endif
-
     FinishInitialization(status);
     return;
   }
@@ -656,7 +640,7 @@ void RendererImpl::RunEndedCallbackIfNeeded() {
   ended_cb_.Run();
 }
 
-void RendererImpl::OnError(const DemuxerStream* stream, PipelineStatus error) {
+void RendererImpl::OnError(PipelineStatus error) {
   DVLOG(1) << __FUNCTION__ << "(" << error << ")";
   DCHECK(task_runner_->BelongsToCurrentThread());
   DCHECK_NE(PIPELINE_OK, error) << "PIPELINE_OK isn't an error!";
@@ -665,10 +649,6 @@ void RendererImpl::OnError(const DemuxerStream* stream, PipelineStatus error) {
   if (state_ == STATE_ERROR)
     return;
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  pipeline_stats::ReportStreamError(stream);
-#endif
-
   const State old_state = state_;
   state_ = STATE_ERROR;
 
diff --git a/media/renderers/renderer_impl.h b/media/renderers/renderer_impl.h
index a82ffa3..fc17f6c 100644
--- a/media/renderers/renderer_impl.h
+++ b/media/renderers/renderer_impl.h
@@ -29,7 +29,6 @@ class SingleThreadTaskRunner;
 namespace media {
 
 class AudioRenderer;
-class DemuxerStream;
 class DemuxerStreamProvider;
 class TimeSource;
 class VideoRenderer;
@@ -129,7 +128,7 @@ class MEDIA_EXPORT RendererImpl : public Renderer {
   void RunEndedCallbackIfNeeded();
 
   // Callback executed when a runtime error happens.
-  void OnError(const DemuxerStream* stream, PipelineStatus error);
+  void OnError(PipelineStatus error);
 
   State state_;
 
diff --git a/media/test/pipeline_integration_test.cc b/media/test/pipeline_integration_test.cc
index 27a1095..ea8cd6e 100644
--- a/media/test/pipeline_integration_test.cc
+++ b/media/test/pipeline_integration_test.cc
@@ -81,20 +81,12 @@
 #define MAYBE_CLOCKLESS(test) test
 #endif
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS) && defined(OS_MACOSX)
-#include "base/mac/mac_util.h"
-#endif
-
 using testing::_;
 using testing::AnyNumber;
 using testing::AtLeast;
 using testing::AtMost;
 using testing::SaveArg;
 
-#if defined(OS_LINUX)
-#undef USE_PROPRIETARY_CODECS
-#endif
-
 namespace media {
 
 const char kSourceId[] = "SourceId";
@@ -105,16 +97,12 @@ const char kAudioOnlyWebM[] = "video/webm; codecs=\"vorbis\"";
 const char kOpusAudioOnlyWebM[] = "video/webm; codecs=\"opus\"";
 const char kVideoOnlyWebM[] = "video/webm; codecs=\"vp8\"";
 #if defined(USE_PROPRIETARY_CODECS)
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 const char kADTS[] = "audio/aac";
 const char kMP4[] = "video/mp4; codecs=\"avc1.4D4041,mp4a.40.2\"";
-#endif
 const char kMP4VideoAVC3[] = "video/mp4; codecs=\"avc3.64001f\"";
 const char kMP4Video[] = "video/mp4; codecs=\"avc1.4D4041\"";
 const char kMP4Audio[] = "audio/mp4; codecs=\"mp4a.40.2\"";
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 const char kMP3[] = "audio/mpeg";
-#endif
 #endif  // defined(USE_PROPRIETARY_CODECS)
 
 // Key used to encrypt test files.
@@ -159,11 +147,9 @@ static const char kOpusEndTrimmingHash_3[] =
 #endif  // !defined(MOJO_RENDERER)
 
 #if defined(USE_PROPRIETARY_CODECS)
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 const int k640IsoFileDurationMs = 2737;
 const int k640IsoCencFileDurationMs = 2736;
 const int k1280IsoFileDurationMs = 2736;
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 const int k1280IsoAVC3FileDurationMs = 2736;
 #endif  // defined(USE_PROPRIETARY_CODECS)
 
@@ -495,8 +481,7 @@ class MockMediaSource {
   MockMediaSource(const std::string& filename,
                   const std::string& mimetype,
                   size_t initial_append_size)
-      : file_path_(GetTestDataFilePath(filename)),
-        current_position_(0),
+      : current_position_(0),
         initial_append_size_(initial_append_size),
         mimetype_(mimetype),
         chunk_demuxer_(new ChunkDemuxer(
@@ -517,8 +502,6 @@ class MockMediaSource {
 
   virtual ~MockMediaSource() {}
 
-  const base::FilePath file_path() { return file_path_; }
-
   scoped_ptr<Demuxer> GetDemuxer() { return std::move(owned_chunk_demuxer_); }
 
   void set_encrypted_media_init_data_cb(
@@ -660,7 +643,6 @@ class MockMediaSource {
 
  private:
   scoped_refptr<DecoderBuffer> file_data_;
-  base::FilePath file_path_;
   size_t current_position_;
   size_t initial_append_size_;
   std::string mimetype_;
@@ -711,10 +693,6 @@ class PipelineIntegrationTest : public PipelineIntegrationTestHost {
     hashing_enabled_ = test_type & kHashed;
     clockless_playback_ = test_type & kClockless;
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    EnableMockVDA();
-#endif
-
     EXPECT_CALL(*source, InitSegmentReceived(_)).Times(AtLeast(1));
     EXPECT_CALL(*this, OnMetadata(_))
         .Times(AtMost(1))
@@ -729,7 +707,7 @@ class PipelineIntegrationTest : public PipelineIntegrationTestHost {
 
     demuxer_ = source->GetDemuxer();
     pipeline_->Start(
-        demuxer_.get(), CreateRenderer(source->file_path()),
+        demuxer_.get(), CreateRenderer(),
         base::Bind(&PipelineIntegrationTest::OnEnded, base::Unretained(this)),
         base::Bind(&PipelineIntegrationTest::OnError, base::Unretained(this)),
         base::Bind(&PipelineIntegrationTest::OnStatusCallback,
@@ -749,10 +727,6 @@ class PipelineIntegrationTest : public PipelineIntegrationTestHost {
 
   void StartPipelineWithEncryptedMedia(MockMediaSource* source,
                                        FakeEncryptedMedia* encrypted_media) {
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    EnableMockVDA();
-#endif
-
     EXPECT_CALL(*source, InitSegmentReceived(_)).Times(AtLeast(1));
     EXPECT_CALL(*this, OnMetadata(_))
         .Times(AtMost(1))
@@ -774,7 +748,7 @@ class PipelineIntegrationTest : public PipelineIntegrationTestHost {
                                  base::Unretained(this)));
 
     pipeline_->Start(
-        demuxer_.get(), CreateRenderer(source->file_path()),
+        demuxer_.get(), CreateRenderer(),
         base::Bind(&PipelineIntegrationTest::OnEnded, base::Unretained(this)),
         base::Bind(&PipelineIntegrationTest::OnError, base::Unretained(this)),
         base::Bind(&PipelineIntegrationTest::OnStatusCallback,
@@ -892,7 +866,6 @@ TEST_P(BasicMSEPlaybackTest, PlayToEnd) {
 }
 
 #if defined(USE_PROPRIETARY_CODECS)
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 
 const PlaybackTestData kADTSTests[] = {
     {"bear-audio-main-aac.aac", 0, 2724},
@@ -918,7 +891,6 @@ INSTANTIATE_TEST_CASE_P(PropritaryCodecs,
                         BasicMSEPlaybackTest,
                         testing::ValuesIn(kMediaSourceADTSTests));
 
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 #endif  // defined(USE_PROPRIETARY_CODECS)
 
 TEST_F(PipelineIntegrationTest, BasicPlayback) {
@@ -1133,25 +1105,6 @@ TEST_F(PipelineIntegrationTest, BasicPlayback_MediaSource_VP9_WebM) {
   Stop();
 }
 
-#if defined(USE_PROPRIETARY_CODECS)
-TEST_F(PipelineIntegrationTest, BasicPlayback_MediaSource_MP4_AudioOnly) {
-  MockMediaSource source("what-does-the-fox-say.mp4",
-                         "audio/mp4; codecs=\"mp4a.40.5\"", kAppendWholeFile);
-  StartPipelineWithMediaSource(&source);
-  source.EndOfStream();
-
-  EXPECT_EQ(1u, pipeline_->GetBufferedTimeRanges().size());
-  EXPECT_EQ(0, pipeline_->GetBufferedTimeRanges().start(0).InMilliseconds());
-  EXPECT_EQ(1493, pipeline_->GetBufferedTimeRanges().end(0).InMilliseconds());
-
-  Play();
-
-  ASSERT_TRUE(WaitUntilOnEnded());
-  source.Shutdown();
-  Stop();
-}
-#endif
-
 TEST_F(PipelineIntegrationTest, BasicPlayback_MediaSource_VP8A_WebM) {
   MockMediaSource source("bear-vp8a.webm", kVideoOnlyWebM, kAppendWholeFile);
   StartPipelineWithMediaSource(&source);
@@ -1379,7 +1332,7 @@ TEST_F(PipelineIntegrationTest,
   source.Shutdown();
 }
 
-#if defined(USE_PROPRIETARY_CODECS) && defined(USE_SYSTEM_PROPRIETARY_CODECS)
+#if defined(USE_PROPRIETARY_CODECS)
 
 TEST_F(PipelineIntegrationTest, BasicPlaybackHi10P) {
   ASSERT_EQ(PIPELINE_OK, Start("bear-320x180-hi10p.mp4", kClockless));
@@ -1389,8 +1342,6 @@ TEST_F(PipelineIntegrationTest, BasicPlaybackHi10P) {
   ASSERT_TRUE(WaitUntilOnEnded());
 }
 
-// USE_SYSTEM_PROPRIETARY_CODECS supports the MP4 container format only.
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 TEST_F(PipelineIntegrationTest, MediaSource_ADTS) {
   MockMediaSource source("sfx.adts", kADTS, kAppendWholeFile);
   StartPipelineWithMediaSource(&source);
@@ -1432,20 +1383,10 @@ TEST_F(PipelineIntegrationTest, MediaSource_ADTS_TimestampOffset) {
 
   EXPECT_TRUE(WaitUntilOnEnded());
 
-  // TODO(wdzierzanowski): Clarify decoder delay differences (DNA-44158).
   // Verify preroll is stripped.
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS) && defined(OS_MACOSX)
-  EXPECT_HASH_EQ("-1.76,-1.35,-0.72,0.70,1.24,0.52,", GetAudioHash());
-#elif defined(USE_SYSTEM_PROPRIETARY_CODECS) && defined(OS_WIN)
-  EXPECT_HASH_EQ("-1.73,-1.32,-0.69,0.73,1.26,0.54,", GetAudioHash());
-#else
   EXPECT_HASH_EQ("-0.06,0.97,-0.90,-0.70,-0.53,-0.34,", GetAudioHash());
-#endif
 }
 
-// USE_SYSTEM_PROPRIETARY_CODECS requires a different test setup for non-MSE
-// tests, see PlatformMediaPipelineIntegrationTest.
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 TEST_F(PipelineIntegrationTest, BasicPlaybackHashed_MP3) {
   ASSERT_EQ(PIPELINE_OK, Start("sfx.mp3", kHashed));
 
@@ -1456,10 +1397,8 @@ TEST_F(PipelineIntegrationTest, BasicPlaybackHashed_MP3) {
   // Verify codec delay and preroll are stripped.
   EXPECT_HASH_EQ("1.30,2.72,4.56,5.08,3.74,2.03,", GetAudioHash());
 }
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 
 #if !defined(DISABLE_CLOCKLESS_TESTS)
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 class Mp3FastSeekParams {
  public:
   Mp3FastSeekParams(const char* filename, const char* hash)
@@ -1530,12 +1469,8 @@ INSTANTIATE_TEST_CASE_P(
     Mp3FastSeekIntegrationTest,
     ::testing::Values(Mp3FastSeekParams("bear-audio-10s-VBR-no-TOC.mp3",
                                         "-0.22,0.80,1.19,0.73,-0.31,-1.12,")));
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 #endif  // !defined(DISABLE_CLOCKLESS_TESTS)
 
-// USE_SYSTEM_PROPRIETARY_CODECS supports the MP4 container format only.
-// MediaSource_MP3 tests are new in Opera 34 and don't yet pass in Vivaldi.
-#if 0 &&  !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 TEST_F(PipelineIntegrationTest, MediaSource_MP3) {
   MockMediaSource source("sfx.mp3", kMP3, kAppendWholeFile);
   StartPipelineWithMediaSource(&source, kHashed);
@@ -1550,60 +1485,9 @@ TEST_F(PipelineIntegrationTest, MediaSource_MP3) {
   EXPECT_TRUE(WaitUntilOnEnded());
 
   // Verify that codec delay was stripped.
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS) && defined(OS_MACOSX)
-  EXPECT_HASH_EQ("1.00,2.70,4.17,4.31,3.03,1.11,", GetAudioHash());
-#elif defined(USE_SYSTEM_PROPRIETARY_CODECS) && defined(OS_WIN)
-  EXPECT_HASH_EQ("1.02,2.71,4.18,4.32,3.04,1.12,", GetAudioHash());
-#else
   EXPECT_HASH_EQ("1.01,2.71,4.18,4.32,3.04,1.12,", GetAudioHash());
-#endif
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-// This file triggers a different sequence of "provide data", "output buffers"
-// events in ATAudioDecoder.
-TEST_F(PipelineIntegrationTest, MediaSource_MP3_a440) {
-  MockMediaSource source("a440.mp3", kMP3, kAppendWholeFile);
-  StartHashedPipelineWithMediaSource(&source);
-  source.EndOfStream();
-
-  ASSERT_EQ(1u, pipeline_->GetBufferedTimeRanges().size());
-  EXPECT_EQ(0, pipeline_->GetBufferedTimeRanges().start(0).InMilliseconds());
-  EXPECT_EQ(444, pipeline_->GetBufferedTimeRanges().end(0).InMilliseconds());
-
-  Play();
-
-  EXPECT_TRUE(WaitUntilOnEnded());
-
-#if defined(OS_MACOSX)
-  // Alas, our workaround for EOS flushing doesn't always yield the same
-  // results as the proper AudioConverter flushing would do.
-  if (base::mac::IsOSMavericksOrEarlier())
-    EXPECT_HASH_EQ("-2.44,-2.50,-1.71,-0.66,-0.13,-0.81,", GetAudioHash());
-  else
-    EXPECT_HASH_EQ("-1.41,-0.55,-0.29,-0.82,-1.76,-2.40,", GetAudioHash());
-#elif defined(OS_WIN)
-  EXPECT_HASH_EQ("-0.67,-0.72,0.06,1.11,1.64,0.96,", GetAudioHash());
-#endif
-}
-
-TEST_F(PipelineIntegrationTest, MediaSource_MP3_Seek) {
-  MockMediaSource source("sfx.mp3", kMP3, kAppendWholeFile);
-  StartHashedPipelineWithMediaSource(&source);
-  source.EndOfStream();
-
-  Play();
-
-  WaitUntilCurrentTimeIsAfter(base::TimeDelta::FromMilliseconds(100));
-
-  const base::TimeDelta seek_time;
-  source.Seek(seek_time);
-  Seek(seek_time);
-
-  EXPECT_TRUE(WaitUntilOnEnded());
-}
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 TEST_F(PipelineIntegrationTest, MediaSource_MP3_TimestampOffset) {
   MockMediaSource source("sfx.mp3", kMP3, kAppendWholeFile);
   StartPipelineWithMediaSource(&source);
@@ -1631,7 +1515,6 @@ TEST_F(PipelineIntegrationTest, MediaSource_MP3_TimestampOffset) {
 
   EXPECT_TRUE(WaitUntilOnEnded());
 }
-#endif  // 0
 
 TEST_F(PipelineIntegrationTest, MediaSource_MP3_Icecast) {
   MockMediaSource source("icy_sfx.mp3", kMP3, kAppendWholeFile);
@@ -1667,36 +1550,6 @@ TEST_F(PipelineIntegrationTest, MediaSource_ConfigChange_MP4) {
   Stop();
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-TEST_F(PipelineIntegrationTest, MediaSource_ConfigChange_MP4_Resampled) {
-  AudioParameters out_params(AudioParameters::AUDIO_PCM_LOW_LATENCY,
-                             CHANNEL_LAYOUT_STEREO, 16000, 16, 512);
-  hardware_config_.UpdateOutputConfig(out_params);
-
-  MockMediaSource source("bear-640x360-av_frag.mp4", kMP4, kAppendWholeFile);
-  StartPipelineWithMediaSource(&source);
-
-  scoped_refptr<DecoderBuffer> second_file =
-      ReadTestDataFile("bear-1280x720-av_frag.mp4");
-
-  source.AppendAtTime(base::TimeDelta::FromSeconds(kAppendTimeSec),
-                      second_file->data(), second_file->data_size());
-
-  source.EndOfStream();
-
-  EXPECT_EQ(1u, pipeline_->GetBufferedTimeRanges().size());
-  EXPECT_EQ(0, pipeline_->GetBufferedTimeRanges().start(0).InMilliseconds());
-  EXPECT_EQ(kAppendTimeMs + k1280IsoFileDurationMs,
-            pipeline_->GetBufferedTimeRanges().end(0).InMilliseconds());
-
-  Play();
-
-  EXPECT_TRUE(WaitUntilOnEnded());
-  source.Shutdown();
-  Stop();
-}
-#endif
-
 TEST_F(PipelineIntegrationTest,
        MAYBE_EME(MediaSource_ConfigChange_Encrypted_MP4_CENC_VideoOnly)) {
   MockMediaSource source("bear-640x360-v_frag-cenc.mp4", kMP4Video,
@@ -1812,15 +1665,12 @@ TEST_F(PipelineIntegrationTest,
   source.Shutdown();
 }
 
-// USE_SYSTEM_PROPRIETARY_CODECS supports the MP4 container format only.
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 // Verify files which change configuration midstream fail gracefully.
 TEST_F(PipelineIntegrationTest, MidStreamConfigChangesFail) {
   ASSERT_EQ(PIPELINE_OK, Start("midstream_config_change.mp3"));
   Play();
   ASSERT_EQ(WaitUntilEndedOrError(), PIPELINE_ERROR_DECODE);
 }
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
 #endif  // defined(USE_PROPRIETARY_CODECS)
 
 TEST_F(PipelineIntegrationTest, BasicPlayback_16x9AspectRatio) {
@@ -1877,7 +1727,7 @@ TEST_F(PipelineIntegrationTest,
   Stop();
 }
 
-#if defined(USE_PROPRIETARY_CODECS) && defined(USE_SYSTEM_PROPRIETARY_CODECS)
+#if defined(USE_PROPRIETARY_CODECS)
 TEST_F(PipelineIntegrationTest,
        MAYBE_EME(EncryptedPlayback_MP4_CENC_VideoOnly)) {
   MockMediaSource source("bear-1280x720-v_frag-cenc.mp4", kMP4Video,
@@ -2016,7 +1866,6 @@ TEST_F(PipelineIntegrationTest, BasicPlayback_MediaSource_VideoOnly_MP4_AVC3) {
 }
 
 #endif  // defined(USE_PROPRIETARY_CODECS)
-#endif  // !defined(OS_LINUX) && defined(USE_PROPRIETARY_CODECS)
 
 TEST_F(PipelineIntegrationTest, SeekWhilePaused) {
   ASSERT_EQ(PIPELINE_OK, Start("bear-320x240.webm"));
@@ -2092,9 +1941,7 @@ TEST_F(PipelineIntegrationTest, SuspendWhilePlaying) {
   ASSERT_TRUE(WaitUntilOnEnded());
 }
 
-// USE_SYSTEM_PROPRIETARY_CODECS requires a different test setup for non-MSE
-// tests, see PlatformMediaPipelineIntegrationTest.
-#if 0
+#if defined(USE_PROPRIETARY_CODECS)
 TEST_F(PipelineIntegrationTest, Rotated_Metadata_0) {
   ASSERT_EQ(PIPELINE_OK, Start("bear_rotate_0.mp4"));
   ASSERT_EQ(VIDEO_ROTATION_0, metadata_.video_rotation);
@@ -2114,7 +1961,7 @@ TEST_F(PipelineIntegrationTest, Rotated_Metadata_270) {
   ASSERT_EQ(PIPELINE_OK, Start("bear_rotate_270.mp4"));
   ASSERT_EQ(VIDEO_ROTATION_270, metadata_.video_rotation);
 }
-#endif  // !defined(USE_SYSTEM_PROPRIETARY_CODECS)
+#endif  // defined(USE_PROPRIETARY_CODECS)
 
 // Verify audio decoder & renderer can handle aborted demuxer reads.
 TEST_F(PipelineIntegrationTest, ChunkDemuxerAbortRead_AudioOnly) {
diff --git a/media/test/pipeline_integration_test_base.cc b/media/test/pipeline_integration_test_base.cc
index f1c99b8..17647ba 100644
--- a/media/test/pipeline_integration_test_base.cc
+++ b/media/test/pipeline_integration_test_base.cc
@@ -7,7 +7,6 @@
 #include <utility>
 
 #include "base/bind.h"
-#include "base/features/features.h"
 #include "base/memory/scoped_vector.h"
 #include "media/base/cdm_context.h"
 #include "media/base/media_log.h"
@@ -28,26 +27,6 @@
 #include "media/filters/vpx_video_decoder.h"
 #endif
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-#include <limits>
-#include <queue>
-
-#include "gpu/GLES2/gl2extchromium.h"
-#include "media/base/limits.h"
-#if defined(OS_MACOSX)
-#include "media/filters/at_audio_decoder.h"
-#elif defined(OS_WIN)
-#include "media/filters/wmf_audio_decoder.h"
-#include "media/filters/wmf_video_decoder.h"
-#endif
-#include "media/filters/gpu_video_decoder.h"
-#include "media/filters/ipc_demuxer.h"
-#include "media/filters/pass_through_audio_decoder.h"
-#include "media/filters/pass_through_video_decoder.h"
-#include "media/renderers/mock_gpu_video_accelerator_factories.h"
-#include "media/video/mock_video_decode_accelerator.h"
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 using ::testing::_;
 using ::testing::AnyNumber;
 using ::testing::AtLeast;
@@ -61,152 +40,6 @@ namespace media {
 const char kNullVideoHash[] = "d41d8cd98f00b204e9800998ecf8427e";
 const char kNullAudioHash[] = "0.00,0.00,0.00,0.00,0.00,0.00,";
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-namespace {
-
-const int kNumPictureBuffers = media::limits::kMaxVideoFrames + 1;
-const int kMaxPictureWidth = 1920;
-const int kMaxPictureHeight = 1080;
-
-bool CreateTextures(int32_t count,
-                    const gfx::Size& size,
-                    std::vector<uint32_t>* texture_ids,
-                    std::vector<gpu::Mailbox>* texture_mailboxes,
-                    uint32_t texture_target) {
-  CHECK_EQ(count, kNumPictureBuffers);
-  for (int i = 0; i < count; ++i) {
-    texture_ids->push_back(i + 1);
-    texture_mailboxes->push_back(gpu::Mailbox());
-  }
-  return true;
-}
-
-VideoDecodeAccelerator::SupportedProfiles GetSupportedProfiles() {
-  VideoDecodeAccelerator::SupportedProfile profile_prototype;
-  profile_prototype.max_resolution.SetSize(std::numeric_limits<int>::max(),
-                                           std::numeric_limits<int>::max());
-
-  VideoDecodeAccelerator::SupportedProfiles all_profiles;
-  for (int i = VIDEO_CODEC_PROFILE_MIN + 1; i <= VIDEO_CODEC_PROFILE_MAX; ++i) {
-    profile_prototype.profile = static_cast<VideoCodecProfile>(i);
-    all_profiles.push_back(profile_prototype);
-  }
-
-  return all_profiles;
-}
-
-}  // namespace
-
-// A MockVideoDecodeAccelerator that pretends it reallly decodes.
-class PipelineIntegrationTestBase::DecodingMockVDA
-    : public MockVideoDecodeAccelerator {
- public:
-  DecodingMockVDA() : client_(nullptr), enabled_(false) {
-    EXPECT_CALL(*this, Initialize(_, _))
-        .WillRepeatedly(testing::Invoke(this, &DecodingMockVDA::DoInitialize));
-  }
-
-  void Enable() {
-    enabled_ = true;
-
-    EXPECT_CALL(*this, AssignPictureBuffers(_))
-        .WillRepeatedly(
-            testing::Invoke(this, &DecodingMockVDA::SetPictureBuffers));
-    EXPECT_CALL(*this, ReusePictureBuffer(_))
-        .WillRepeatedly(
-            testing::Invoke(this, &DecodingMockVDA::DoReusePictureBuffer));
-    EXPECT_CALL(*this, Decode(_))
-        .WillRepeatedly(testing::Invoke(this, &DecodingMockVDA::DoDecode));
-    EXPECT_CALL(*this, Flush())
-        .WillRepeatedly(testing::Invoke(this, &DecodingMockVDA::DoFlush));
-  }
-
- private:
-  enum { kFlush = -1 };
-
-  bool DoInitialize(const Config &config, Client* client) {
-    // This makes this VDA and GpuVideoDecoder unusable by default and will
-    // require opt-in (see |Enable()|).
-    if (!enabled_)
-      return false;
-
-    if (config.profile < media::H264PROFILE_MIN ||
-      config.profile > media::H264PROFILE_MAX)
-      return false;
-
-    client_ = client;
-    client_->ProvidePictureBuffers(
-        kNumPictureBuffers, 1, gfx::Size(kMaxPictureWidth, kMaxPictureHeight),
-        GL_TEXTURE_RECTANGLE_ARB);
-    return true;
-  }
-
-  void SetPictureBuffers(const std::vector<PictureBuffer>& buffers) {
-    CHECK_EQ(buffers.size(), base::checked_cast<size_t>(kNumPictureBuffers));
-    CHECK(available_picture_buffer_ids_.empty());
-
-    for (const PictureBuffer& buffer : buffers)
-      available_picture_buffer_ids_.push(buffer.id());
-  }
-
-  void DoReusePictureBuffer(int32_t id) {
-    available_picture_buffer_ids_.push(id);
-    if (!finished_bitstream_buffers_ids_.empty())
-      SendPicture();
-  }
-
-  void DoDecode(const BitstreamBuffer& bitstream_buffer) {
-    finished_bitstream_buffers_ids_.push(bitstream_buffer.id());
-
-    if (!available_picture_buffer_ids_.empty())
-      SendPicture();
-  }
-
-  void SendPicture() {
-    CHECK(!available_picture_buffer_ids_.empty());
-    CHECK(!finished_bitstream_buffers_ids_.empty());
-
-    const int32_t bitstream_buffer_id = finished_bitstream_buffers_ids_.front();
-    finished_bitstream_buffers_ids_.pop();
-
-    client_->PictureReady(
-        Picture(available_picture_buffer_ids_.front(), bitstream_buffer_id,
-                gfx::Rect(kMaxPictureWidth, kMaxPictureHeight), false));
-    available_picture_buffer_ids_.pop();
-
-    base::MessageLoop::current()->PostTask(
-        FROM_HERE,
-        base::Bind(&VideoDecodeAccelerator::Client::NotifyEndOfBitstreamBuffer,
-                   base::Unretained(client_), bitstream_buffer_id));
-
-    if (!finished_bitstream_buffers_ids_.empty() &&
-        finished_bitstream_buffers_ids_.front() == kFlush) {
-      finished_bitstream_buffers_ids_.pop();
-      base::MessageLoop::current()->PostTask(
-          FROM_HERE,
-          base::Bind(&VideoDecodeAccelerator::Client::NotifyFlushDone,
-                     base::Unretained(client_)));
-    }
-  }
-
-  void DoFlush() {
-    // Enqueue a special "flush marker" picture.  It will be picked up in
-    // |SendPicture()| when all the pictures enqueued before the marker have
-    // been sent.
-    finished_bitstream_buffers_ids_.push(kFlush);
-
-    while (!finished_bitstream_buffers_ids_.empty() &&
-           !available_picture_buffer_ids_.empty())
-      SendPicture();
-  }
-
-  VideoDecodeAccelerator::Client* client_;
-  std::queue<int32_t> available_picture_buffer_ids_;
-  std::queue<int32_t> finished_bitstream_buffers_ids_;
-  bool enabled_;
-};
-#endif
-
 PipelineIntegrationTestBase::PipelineIntegrationTestBase()
     : hashing_enabled_(false),
       clockless_playback_(false),
@@ -215,12 +48,6 @@ PipelineIntegrationTestBase::PipelineIntegrationTestBase()
       pipeline_status_(PIPELINE_OK),
       last_video_frame_format_(PIXEL_FORMAT_UNKNOWN),
       last_video_frame_color_space_(COLOR_SPACE_UNSPECIFIED),
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-      mock_video_accelerator_factories_(
-          new MockGpuVideoAcceleratorFactories(nullptr)),
-      mock_vda_(new DecodingMockVDA),
-      mse_mpeg_aac_enabler_(base::kFeatureMseAudioMpegAac, true),
-#endif
       hardware_config_(AudioParameters(), AudioParameters()) {
   base::MD5Init(&md5_context_);
 }
@@ -314,7 +141,7 @@ PipelineStatus PipelineIntegrationTestBase::StartInternal(
   EXPECT_CALL(*this, OnWaitingForDecryptionKey()).Times(0);
 
   pipeline_->Start(
-      demuxer_.get(), CreateRenderer(GetTestDataFilePath(filename_)),
+      demuxer_.get(), CreateRenderer(),
       base::Bind(&PipelineIntegrationTestBase::OnEnded, base::Unretained(this)),
       base::Bind(&PipelineIntegrationTestBase::OnError, base::Unretained(this)),
       base::Bind(&PipelineIntegrationTestBase::OnStatusCallback,
@@ -392,14 +219,9 @@ bool PipelineIntegrationTestBase::Suspend() {
 bool PipelineIntegrationTestBase::Resume(base::TimeDelta seek_time) {
   ended_ = false;
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  if (!mock_vda_)
-    mock_vda_.reset(new DecodingMockVDA);
-#endif
-
   EXPECT_CALL(*this, OnBufferingStateChanged(BUFFERING_HAVE_ENOUGH))
       .WillOnce(InvokeWithoutArgs(&message_loop_, &base::MessageLoop::QuitNow));
-  pipeline_->Resume(CreateRenderer(GetTestDataFilePath(filename_)), seek_time,
+  pipeline_->Resume(CreateRenderer(), seek_time,
                     base::Bind(&PipelineIntegrationTestBase::OnSeeked,
                                base::Unretained(this), seek_time));
   message_loop_.Run();
@@ -464,57 +286,8 @@ void PipelineIntegrationTestBase::CreateDemuxer(
 #endif
 }
 
-scoped_ptr<Renderer> PipelineIntegrationTestBase::CreateRenderer(
-    const base::FilePath& file_path) {
+scoped_ptr<Renderer> PipelineIntegrationTestBase::CreateRenderer() {
   ScopedVector<VideoDecoder> video_decoders;
-  ScopedVector<AudioDecoder> audio_decoders;
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  const std::string content_type;
-  const GURL url("file://" + file_path.AsUTF8Unsafe());
-  if (IPCDemuxer::CanPlayType(content_type, url)) {
-    audio_decoders.push_back(
-        new PassThroughAudioDecoder(message_loop_.task_runner()));
-    video_decoders.push_back(
-        new PassThroughVideoDecoder(message_loop_.task_runner()));
-  }
-
-#if defined(OS_MACOSX)
-  audio_decoders.push_back(
-      new ATAudioDecoder(message_loop_.task_runner()));
-#elif defined(OS_WIN)
-  audio_decoders.push_back(
-      new media::WMFAudioDecoder(message_loop_.task_runner()));
-  video_decoders.push_back(
-      new media::WMFVideoDecoder(message_loop_.task_runner()));
-#endif
-
-  video_decoders.push_back(
-      new GpuVideoDecoder(mock_video_accelerator_factories_.get(),
-                          RequestSurfaceCB()));
-
-  media::VideoDecodeAccelerator::Capabilities capabilities;
-  capabilities.supported_profiles = GetSupportedProfiles();
-
-  EXPECT_CALL(*mock_video_accelerator_factories_, GetTaskRunner())
-      .WillRepeatedly(testing::Return(message_loop_.task_runner()));
-  EXPECT_CALL(*mock_video_accelerator_factories_,
-              GetVideoDecodeAcceleratorCapabilities())
-      .WillRepeatedly(testing::Return(capabilities));
-  EXPECT_CALL(*mock_video_accelerator_factories_,
-              DoCreateVideoDecodeAccelerator())
-      .WillRepeatedly(testing::Return(mock_vda_.get()));
-  EXPECT_CALL(*mock_video_accelerator_factories_, CreateTextures(_, _, _, _, _))
-      .WillRepeatedly(testing::Invoke(&CreateTextures));
-  EXPECT_CALL(*mock_video_accelerator_factories_, DeleteTexture(_))
-      .Times(testing::AnyNumber());
-  EXPECT_CALL(*mock_video_accelerator_factories_, WaitSyncToken(_))
-      .Times(testing::AnyNumber());
-  DCHECK(mock_vda_);
-  EXPECT_CALL(*mock_vda_, Destroy())
-      .WillRepeatedly(
-          testing::Invoke(this, &PipelineIntegrationTestBase::DestroyMockVDA));
-#endif  // defined(USE_SYSTEM_PROPRIETARY_CODECS)
-
 #if !defined(MEDIA_DISABLE_LIBVPX)
   video_decoders.push_back(new VpxVideoDecoder());
 #endif  // !defined(MEDIA_DISABLE_LIBVPX)
@@ -542,6 +315,8 @@ scoped_ptr<Renderer> PipelineIntegrationTestBase::CreateRenderer(
     clockless_audio_sink_ = new ClocklessAudioSink();
   }
 
+  ScopedVector<AudioDecoder> audio_decoders;
+
 #if !defined(MEDIA_DISABLE_FFMPEG)
   audio_decoders.push_back(
       new FFmpegAudioDecoder(message_loop_.task_runner(), new MediaLog()));
@@ -553,10 +328,6 @@ scoped_ptr<Renderer> PipelineIntegrationTestBase::CreateRenderer(
   if (!hashing_enabled_) {
     AudioParameters out_params(AudioParameters::AUDIO_PCM_LOW_LATENCY,
                                CHANNEL_LAYOUT_STEREO, 44100, 16, 512);
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-    // Allow tests to specify their own output config.
-    if (!hardware_config_.GetOutputConfig().IsValid())
-#endif
     hardware_config_.UpdateOutputConfig(out_params);
   }
 
@@ -623,14 +394,4 @@ base::TimeTicks DummyTickClock::NowTicks() {
   return now_;
 }
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-void PipelineIntegrationTestBase::EnableMockVDA() {
-  mock_vda_->Enable();
-}
-
-void PipelineIntegrationTestBase::DestroyMockVDA() {
-  mock_vda_.reset();
-}
-#endif
-
 }  // namespace media
diff --git a/media/test/pipeline_integration_test_base.h b/media/test/pipeline_integration_test_base.h
index aeb24d7..8230489 100644
--- a/media/test/pipeline_integration_test_base.h
+++ b/media/test/pipeline_integration_test_base.h
@@ -7,7 +7,6 @@
 
 #include <stdint.h>
 
-#include "base/features/scoped_test_feature_override.h"
 #include "base/md5.h"
 #include "base/message_loop/message_loop.h"
 #include "media/audio/clockless_audio_sink.h"
@@ -31,7 +30,6 @@ class FilePath;
 namespace media {
 
 class CdmContext;
-class MockGpuVideoAcceleratorFactories;
 
 // Empty MD5 hash string.  Used to verify empty video tracks.
 extern const char kNullVideoHash[];
@@ -118,8 +116,6 @@ class PipelineIntegrationTestBase {
   }
 
  protected:
-  class DecodingMockVDA;
-
   base::MessageLoop message_loop_;
   base::MD5Context md5_context_;
   bool hashing_enabled_;
@@ -136,15 +132,8 @@ class PipelineIntegrationTestBase {
   VideoPixelFormat last_video_frame_format_;
   ColorSpace last_video_frame_color_space_;
   DummyTickClock dummy_clock_;
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  scoped_ptr<MockGpuVideoAcceleratorFactories>
-      mock_video_accelerator_factories_;
-  scoped_ptr<DecodingMockVDA> mock_vda_;
-  base::ScopedTestFeatureOverride mse_mpeg_aac_enabler_;
-#endif
   AudioHardwareConfig hardware_config_;
   PipelineMetadata metadata_;
-  std::string filename_;
 
   PipelineStatus StartInternal(scoped_ptr<DataSource> data_source,
                                CdmContext* cdm_context,
@@ -166,18 +155,13 @@ class PipelineIntegrationTestBase {
   void QuitAfterCurrentTimeTask(const base::TimeDelta& quit_time);
 
   // Creates Demuxer and sets |demuxer_|.
-  virtual void CreateDemuxer(scoped_ptr<DataSource> data_source);
+  void CreateDemuxer(scoped_ptr<DataSource> data_source);
 
   // Creates and returns a Renderer.
-  virtual scoped_ptr<Renderer> CreateRenderer(const base::FilePath& file_path);
+  virtual scoped_ptr<Renderer> CreateRenderer();
 
   void OnVideoFramePaint(const scoped_refptr<VideoFrame>& frame);
 
-#if defined(USE_SYSTEM_PROPRIETARY_CODECS)
-  void EnableMockVDA();
-  void DestroyMockVDA();
-#endif
-
   MOCK_METHOD1(OnMetadata, void(PipelineMetadata));
   MOCK_METHOD1(OnBufferingStateChanged, void(BufferingState));
   MOCK_METHOD1(DecryptorAttached, void(bool));
diff --git a/third_party/WebKit/Source/modules/mediasource/MediaSource.cpp b/third_party/WebKit/Source/modules/mediasource/MediaSource.cpp
index 22ac196..06dee75 100644
--- a/third_party/WebKit/Source/modules/mediasource/MediaSource.cpp
+++ b/third_party/WebKit/Source/modules/mediasource/MediaSource.cpp
@@ -250,16 +250,12 @@ bool MediaSource::isTypeSupported(const String& type)
         return false;
     }
 
-    // The reasoning below is not correct with USE_SYSTEM_PROPRIETARY_CODECS, because for HTMLMediaElement we need system libraries for both
-    // demuxing and decoding, while for MediaSource we only use system libraries to implement decoding.
-#if !defined(USE_SYSTEM_PROPRIETARY_CODECS)
     // Note: MediaSource.isTypeSupported() returning true implies that HTMLMediaElement.canPlayType() will return "maybe" or "probably"
     // since it does not make sense for a MediaSource to support a type the HTMLMediaElement knows it cannot play.
     if (HTMLMediaElement::supportsType(contentType) == WebMimeRegistry::IsNotSupported) {
         WTF_LOG(Media, "MediaSource::isTypeSupported(%s) -> false (not supported by HTMLMediaElement)", type.ascii().data());
         return false;
     }
-#endif
 
     // 3. If type contains a media type or media subtype that the MediaSource does not support, then return false.
     // 4. If type contains at a codec that the MediaSource does not support, then return false.
diff --git a/third_party/opera/LICENSE.txt b/third_party/opera/LICENSE.txt
deleted file mode 100644
index bcf0e39..0000000
--- a/third_party/opera/LICENSE.txt
+++ /dev/null
@@ -1,30 +0,0 @@
-All original work by Opera Softare ASA contained in this source
-code distribution is licensed as follows:
-
-Copyright (c) 2013, Opera Software ASA. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-1. Redistributions of source code must retain the above copyright
-   notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-   notice, this list of conditions and the following disclaimer in the
-   documentation and/or other materials provided with the distribution.
-3. Neither the name of Opera Software ASA nor the names of its
-   contributors may be used to endorse or promote products derived
-   from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
-OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/tools/licenses.py b/tools/licenses.py
index bb6f94a..9a6602b 100755
--- a/tools/licenses.py
+++ b/tools/licenses.py
@@ -246,12 +246,6 @@ SPECIAL_CASES = {
         "License": "Apache 2.0",
         "License File": "NOT_SHIPPED",
     },
-    os.path.join('third_party', 'opera'): {
-        "Name": "Opera",
-        "URL": "http://www.opera.com/",
-        "License": "BSD",
-        "License File": "/third_party/opera/LICENSE.txt",
-    },
 }
 
 # Special value for 'License File' field used to indicate that the license file
